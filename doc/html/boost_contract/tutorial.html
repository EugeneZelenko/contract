<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Tutorial</title>
<link rel="stylesheet" href="../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;Boost.Contract 1.0">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;Boost.Contract 1.0">
<link rel="prev" href="contract_programming_overview.html" title="Contract Programming Overview">
<link rel="next" href="advanced_topics.html" title="Advanced Topics">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../..//boost.png"></td>
<td align="center"><a href="../../..//index.html">Home</a></td>
<td align="center"><a href="../../..//libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../..//more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="contract_programming_overview.html"><img src="../../..//doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../..//doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../..//doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="advanced_topics.html"><img src="../../..//doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="boost_contract.tutorial"></a><a class="link" href="tutorial.html" title="Tutorial">Tutorial</a>
</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="tutorial.html#boost_contract.tutorial.non_member_functions">Non-Member
      Functions</a></span></dt>
<dt><span class="section"><a href="tutorial.html#boost_contract.tutorial.preconditions">Preconditions</a></span></dt>
<dt><span class="section"><a href="tutorial.html#boost_contract.tutorial.postconditions">Postconditions</a></span></dt>
<dt><span class="section"><a href="tutorial.html#boost_contract.tutorial.return_value">Return Value</a></span></dt>
<dt><span class="section"><a href="tutorial.html#boost_contract.tutorial.old_values">Old Values</a></span></dt>
<dt><span class="section"><a href="tutorial.html#boost_contract.tutorial.class_invariants">Class Invariants</a></span></dt>
<dt><span class="section"><a href="tutorial.html#boost_contract.tutorial.constructors">Constructors</a></span></dt>
<dt><span class="section"><a href="tutorial.html#boost_contract.tutorial.destructors">Destructors</a></span></dt>
<dt><span class="section"><a href="tutorial.html#boost_contract.tutorial.public_functions">Public Functions</a></span></dt>
<dt><span class="section"><a href="tutorial.html#boost_contract.tutorial.virtual_public_functions">Virtual
      Public Functions</a></span></dt>
<dt><span class="section"><a href="tutorial.html#boost_contract.tutorial.public_function_overrides__subcontracting_">Public
      Function Overrides (Subcontracting)</a></span></dt>
<dt><span class="section"><a href="tutorial.html#boost_contract.tutorial.base_classes__subcontracting_">Base
      Classes (Subcontracting)</a></span></dt>
<dt><span class="section"><a href="tutorial.html#boost_contract.tutorial.static_public_functions">Static
      Public Functions</a></span></dt>
<dt><span class="section"><a href="tutorial.html#boost_contract.tutorial.private_and_protected_functions">Private
      and Protected Functions</a></span></dt>
</dl></div>
<p>
      This section illustrates basic uses of this library.
    </p>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_contract.tutorial.non_member_functions"></a><a class="link" href="tutorial.html#boost_contract.tutorial.non_member_functions" title="Non-Member Functions">Non-Member
      Functions</a>
</h3></div></div></div>
<p>
        Consider the following non-member function <code class="computeroutput"><span class="identifier">inc</span></code>
        which increments its argument <code class="computeroutput"><span class="identifier">x</span></code>
        by <code class="computeroutput"><span class="number">1</span></code> and returns the value <code class="computeroutput"><span class="identifier">x</span></code> had before the increment (this function
        is equivalent to the usual C++ operation <code class="computeroutput"><span class="identifier">x</span><span class="special">++</span></code>). Let's write contracts for <code class="computeroutput"><span class="identifier">inc</span></code> using code comments (see also <a href="../../../example/features/function_comments.cpp" target="_top"><code class="literal">function_comments.cpp</code></a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">int</span> <span class="identifier">inc</span><span class="special">(</span><span class="keyword">int</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span>
    <span class="comment">// Precondition:    x &lt; std::numeric_limits&lt;int&gt;::max()</span>
    <span class="comment">// Postcondition:   x == oldof(x) + 1</span>
    <span class="comment">//                  result == oldof(x)</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">x</span><span class="special">++;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        The precondition states that the argument to increment must be strictly smaller
        than the maximum allowable value of its type (to avoid overflow). The postconditions
        state that the argument was actually incremented by <code class="computeroutput"><span class="number">1</span></code>
        and that the function return value is equal to the argument before it was
        incremented.
      </p>
<p>
        Now let's program this function and its contract using the <code class="computeroutput"><a class="link" href="../boost/contract/function.html" title="Function function">boost::contract::function</a></code>
        function from this library (see also <a href="../../../example/features/function.cpp" target="_top"><code class="literal">function.cpp</code></a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">contract</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">int</span> <span class="identifier">inc</span><span class="special">(</span><span class="keyword">int</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">int</span> <span class="identifier">result</span><span class="special">;</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">old_ptr</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">old_x</span> <span class="special">=</span> <span class="identifier">BOOST_CONTRACT_OLDOF</span><span class="special">(</span><span class="identifier">x</span><span class="special">);</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">function</span><span class="special">()</span>
        <span class="special">.</span><span class="identifier">precondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
            <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">x</span> <span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">numeric_limits</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;::</span><span class="identifier">max</span><span class="special">());</span>
        <span class="special">})</span>
        <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
            <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">x</span> <span class="special">==</span> <span class="special">*</span><span class="identifier">old_x</span> <span class="special">+</span> <span class="number">1</span><span class="special">);</span>
            <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">result</span> <span class="special">==</span> <span class="special">*</span><span class="identifier">old_x</span><span class="special">);</span>
        <span class="special">})</span>
    <span class="special">;</span>

    <span class="keyword">return</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">x</span><span class="special">++;</span> <span class="comment">// Function body.</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        All necessary header files of this library are included by <code class="computeroutput"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">contract</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>.
        Alternatively, programmers can selectively include only the header files
        they actually need among <code class="literal">boost/contract/*.hpp</code> (see <a class="link" href="getting_started.html" title="Getting Started">Getting Started</a>).
      </p>
<p>
        It is possible to specify both preconditions and postconditions for non-member
        functions (see <a class="link" href="tutorial.html#boost_contract.tutorial.preconditions" title="Preconditions">Preconditions</a>
        and <a class="link" href="tutorial.html#boost_contract.tutorial.postconditions" title="Postconditions">Postconditions</a>).
      </p>
<p>
        The <code class="computeroutput"><a class="link" href="../boost/contract/function.html" title="Function function">boost::contract::function</a></code>
        function returns an RAII object that must always be assigned to a local variable
        of type <code class="computeroutput"><a class="link" href="../boost/contract/guard.html" title="Class guard">boost::contract::guard</a></code>
        otherwise the library will generate a run-time error (note that C++11 <code class="computeroutput"><span class="keyword">auto</span></code> declarations cannot be used here and
        the <code class="computeroutput"><a class="link" href="../boost/contract/guard.html" title="Class guard">boost::contract::guard</a></code>
        type must be explicitly specified). <a href="#ftn.boost_contract.tutorial.non_member_functions.f0" class="footnote" name="boost_contract.tutorial.non_member_functions.f0"><sup class="footnote">[12]</sup></a> The function body is programmed right after the declaration of
        this RAII object.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          In some cases, it might be necessary to program some code before the contract.
          For example for acquiring resources that will be used while checking the
          contract like old values, but also to lock mutexes (or other synchronization
          mechanisms) in multi-threaded programs (as usual with C++, in these cases
          it is generally preferred to use RAII objects to automatically control
          acquisition and release of the resources).
        </p></td></tr>
</table></div>
<p>
        At construction, the RAII object returned by <code class="computeroutput"><a class="link" href="../boost/contract/function.html" title="Function function">boost::contract::function</a></code>
        does the following:
      </p>
<div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
            Check preconditions, by calling the nullary functor <code class="literal"><span class="emphasis"><em>f</em></span></code><code class="computeroutput"><span class="special">()</span></code> passed to <code class="computeroutput"><span class="special">.</span><span class="identifier">precondition</span><span class="special">(</span></code><code class="literal"><span class="emphasis"><em>f</em></span></code><code class="computeroutput"><span class="special">)</span></code>.
          </li></ol></div>
<p>
        At destruction instead:
      </p>
<div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
            If the function body did not throw an exception:
            <div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
                  Check postconditions, by calling the nullary functor <code class="literal"><span class="emphasis"><em>g</em></span></code><code class="computeroutput"><span class="special">()</span></code> passed to <code class="computeroutput"><span class="special">.</span><span class="identifier">postcondition</span><span class="special">(</span></code><code class="literal"><span class="emphasis"><em>g</em></span></code><code class="computeroutput"><span class="special">)</span></code>.
                </li></ol></div>
          </li></ol></div>
<p>
        This ensures that non-member function contracts are correctly checked at
        run-time (see <a class="link" href="contract_programming_overview.html#boost_contract.contract_programming_overview.function_calls" title="Function Calls">Function
        Calls</a>).
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          A non-member function can avoid calling <code class="computeroutput"><a class="link" href="../boost/contract/function.html" title="Function function">boost::contract::function</a></code>
          for efficiency but only when it has no preconditions and no postconditions.
        </p></td></tr>
</table></div>
<p>
        The same considerations also apply to private and protected member functions
        because their contracts are also programmed using <code class="computeroutput"><a class="link" href="../boost/contract/function.html" title="Function function">boost::contract::function</a></code>
        like for non-member functions (see <a class="link" href="tutorial.html#boost_contract.tutorial.private_and_protected_functions" title="Private and Protected Functions">Private
        and Protected Functions</a>).
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_contract.tutorial.preconditions"></a><a class="link" href="tutorial.html#boost_contract.tutorial.preconditions" title="Preconditions">Preconditions</a>
</h3></div></div></div>
<p>
        When preconditions are specified, they are programmed using a functor that
        can be called with no parameter <code class="literal"><span class="emphasis"><em>f</em></span></code><code class="computeroutput"><span class="special">()</span></code> and it is passed to <code class="computeroutput"><span class="special">.</span><span class="identifier">precondition</span><span class="special">(</span></code><code class="literal"><span class="emphasis"><em>f</em></span></code><code class="computeroutput"><span class="special">)</span></code>. Contracts that do not have preconditions
        simply do not call <code class="computeroutput"><span class="special">.</span><span class="identifier">precondition</span><span class="special">(...)</span></code>. When both preconditions and postconditions
        are specified, preconditions must appear before postconditions (see <a class="link" href="tutorial.html#boost_contract.tutorial.postconditions" title="Postconditions">Postconditions</a>).
      </p>
<p>
        C++11 lambda functions are very convenient to program preconditions, but
        any other nullary functor can be used (see also <a class="link" href="advanced_topics.html#boost_contract.advanced_topics.no_lambda_functions__no_c__11_" title="No Lambda Functions (No C++11)">No
        Lambda Functions</a>). <a href="#ftn.boost_contract.tutorial.preconditions.f0" class="footnote" name="boost_contract.tutorial.preconditions.f0"><sup class="footnote">[13]</sup></a> For example, for <code class="computeroutput"><a class="link" href="../boost/contract/function.html" title="Function function">boost::contract::function</a></code>
        (but same for all other contracts):
      </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">function</span><span class="special">()</span>  <span class="comment">// Same for all other contracts.</span>
    <span class="special">.</span><span class="identifier">precondition</span><span class="special">([&amp;]</span> <span class="special">{</span>                                 <span class="comment">// Capture by reference or value...</span>
        <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(...);</span>                     <span class="comment">// ...but should not modify captures.</span>
        <span class="special">...</span>
    <span class="special">})</span>
    <span class="special">...</span>
<span class="special">;</span>
</pre>
<p>
        The precondition functor should capture all the variables that it needs to
        assert the preconditions. These variables can be captured by value when the
        overhead of copying such variables is acceptable (but in this documentation
        preconditions often capture these variables by reference to avoid such overhead).
        In any case, precondition assertions should not modify the value of the captured
        variables, even when those are captured by reference (see <a class="link" href="contract_programming_overview.html#boost_contract.contract_programming_overview.constant_correctness" title="Constant-Correctness">Constant-Correctness</a>).
      </p>
<p>
        Any code can be programmed for the precondition functor, but it is recommended
        to keep this code simple using mainly assertions and if-statements (to avoid
        programming complex preconditions that might be buggy and slow to execute
        at run-time). It is also recommended to use the <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_ASSERT.html" title="Macro BOOST_CONTRACT_ASSERT">BOOST_CONTRACT_ASSERT</a></code>
        macro to program precondition assertions because it enables this library
        to print very informative error messages when the asserted conditions are
        evaluated to be false at run-time (this is not a variadic macro, see also
        <a class="link" href="advanced_topics.html#boost_contract.advanced_topics.no_macros__no_c__11_" title="No Macros (No C++11)">No Macros</a>):
      </p>
<pre class="programlisting"><span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="emphasis"><em>boolean-condition</em></span><span class="special">)</span>
<span class="comment">// Or, if condition has commas `,` not already within parenthesis `(...)`.</span>
<span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">((</span><span class="emphasis"><em>boolean-condition</em></span><span class="special">))</span>
</pre>
<p>
        This library will automatically call <code class="computeroutput">boost::contract::precondition_failure</code>
        if any of the <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_ASSERT.html" title="Macro BOOST_CONTRACT_ASSERT">BOOST_CONTRACT_ASSERT</a></code>
        macro conditions are <code class="computeroutput"><span class="keyword">false</span></code> and
        also if calling the functor specified via <code class="computeroutput"><span class="special">.</span><span class="identifier">precondition</span><span class="special">(...)</span></code>
        throws an exception (by default, this terminates the program calling <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">terminate</span></code>,
        but see <a class="link" href="advanced_topics.html#boost_contract.advanced_topics.throw_on_failure" title="Throw on Failure">Throw
        on Failure</a> to throw exceptions, exit the program with an error code,
        etc.).
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
<p>
          Contracts are most useful when their assertions only use public members
          that are accessible to the caller so the caller can properly check and
          use the contract. In particular, preconditions of a public member function
          or constructor that use non-public members are essentially incorrect because
          they cannot be fully checked by the caller (in fact, Eiffel generates a
          compile-time error in this case).
        </p>
<p>
          This library leaves it up to the programmers to only use public members
          when programming contracts and especially when programming preconditions
          (see also <a class="link" href="contract_programming_overview.html#boost_contract.contract_programming_overview.specification_and_implementation" title="Specification and Implementation">Specification
          and Implementation</a>).
        </p>
</td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_contract.tutorial.postconditions"></a><a class="link" href="tutorial.html#boost_contract.tutorial.postconditions" title="Postconditions">Postconditions</a>
</h3></div></div></div>
<p>
        When postconditions are specified, they are programmed using a functor that
        can be called with no parameter <code class="literal"><span class="emphasis"><em>g</em></span></code><code class="computeroutput"><span class="special">()</span></code> and it is passed to <code class="computeroutput"><span class="special">.</span><span class="identifier">postcondition</span><span class="special">(</span></code><code class="literal"><span class="emphasis"><em>g</em></span></code><code class="computeroutput"><span class="special">)</span></code>. Contracts that do not have postconditions
        simply do not call <code class="computeroutput"><span class="special">.</span><span class="identifier">postcondition</span><span class="special">(...)</span></code>. When both preconditions and postconditions
        are specified, postconditions must appear after preconditions (see <a class="link" href="tutorial.html#boost_contract.tutorial.preconditions" title="Preconditions">Preconditions</a>).
      </p>
<p>
        C++11 lambda functions are very convenient to program postconditions, but
        any other nullary functor can be used (see also <a class="link" href="advanced_topics.html#boost_contract.advanced_topics.no_lambda_functions__no_c__11_" title="No Lambda Functions (No C++11)">No
        Lambda Functions</a>). For example, for <code class="computeroutput"><a class="link" href="../boost/contract/function.html" title="Function function">boost::contract::function</a></code>
        (but same for all other contracts):
      </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">function</span><span class="special">()</span>  <span class="comment">// Same for all other contracts.</span>
    <span class="special">...</span>
    <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">{</span>                                <span class="comment">// Capture by reference...</span>
        <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(...);</span>                     <span class="comment">// ...but should not modify captures.</span>
        <span class="special">...</span>
    <span class="special">})</span>
<span class="special">;</span>
</pre>
<p>
        The postcondition functor should capture all variables that it needs to assert
        the postconditions. In general, these variables should be captured by reference
        and not by value (because postconditions need to access the value that these
        variables will have at function exit, and not the value these variables had
        when the postcondition functor was first constructed). Postconditions can
        also capture return and old values (see <a class="link" href="tutorial.html#boost_contract.tutorial.return_value" title="Return Value">Return
        Value</a> and <a class="link" href="tutorial.html#boost_contract.tutorial.old_values" title="Old Values">Old Values</a>).
        In any case, postcondition assertions should not modify the value of the
        captured variables (see also <a class="link" href="contract_programming_overview.html#boost_contract.contract_programming_overview.constant_correctness" title="Constant-Correctness">Constant-Correctness</a>).
      </p>
<p>
        Any code can be programmed for the postcondition functor, but it is recommended
        to keep this code simple using mainly assertions and if-statements (to avoid
        programming complex postconditions that might be buggy and slow to execute
        at run-time). It is also recommended to use the <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_ASSERT.html" title="Macro BOOST_CONTRACT_ASSERT">BOOST_CONTRACT_ASSERT</a></code>
        macro to program postcondition assertions because it enables this library
        to print very informative error messages when the asserted conditions are
        evaluated to be false at run-time (this is not a variadic macro, but see
        also <a class="link" href="advanced_topics.html#boost_contract.advanced_topics.no_macros__no_c__11_" title="No Macros (No C++11)">No
        Macros</a>):
      </p>
<pre class="programlisting"><span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="emphasis"><em>boolean-condition</em></span><span class="special">)</span>
<span class="comment">// Or, if condition has commas `,` not already within parenthesis `(...)`.</span>
<span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">((</span><span class="emphasis"><em>boolean-condition</em></span><span class="special">))</span>
</pre>
<p>
        This library will automatically call <code class="computeroutput">boost::contract::postcondition_failure</code>
        if any of the <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_ASSERT.html" title="Macro BOOST_CONTRACT_ASSERT">BOOST_CONTRACT_ASSERT</a></code>
        macro conditions are <code class="computeroutput"><span class="keyword">false</span></code> and
        also if calling the functor specified via <code class="computeroutput"><span class="special">.</span><span class="identifier">postcondition</span><span class="special">(...)</span></code>
        throws an exception (by default, this terminates the program calling <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">terminate</span></code>,
        but see <a class="link" href="advanced_topics.html#boost_contract.advanced_topics.throw_on_failure" title="Throw on Failure">Throw
        on Failure</a> to throw exceptions, exit the program with an error code,
        etc.).
      </p>
<p>
        For non-void public functions, the functor passed to <code class="computeroutput"><span class="special">.</span><span class="identifier">postcondition</span><span class="special">(...)</span></code>
        is not a nullary functor. Instead, it is a unary functor taking a variable
        holding the return value as its one parameter (see also <a class="link" href="tutorial.html#boost_contract.tutorial.public_functions" title="Public Functions">Public
        Functions</a>).
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_contract.tutorial.return_value"></a><a class="link" href="tutorial.html#boost_contract.tutorial.return_value" title="Return Value">Return Value</a>
</h3></div></div></div>
<p>
        In non-void functions, postconditions can access the function return value
        to program assertions. In this case, programmers are responsible to declare
        a local variable before the contract and to assign it to the return value
        at function exit (when the function does not throw an exception). <a href="#ftn.boost_contract.tutorial.return_value.f0" class="footnote" name="boost_contract.tutorial.return_value.f0"><sup class="footnote">[14]</sup></a> For example, for <code class="computeroutput"><a class="link" href="../boost/contract/function.html" title="Function function">boost::contract::function</a></code>
        (but same for all other contracts):
      </p>
<pre class="programlisting"><span class="emphasis"><em>return-type</em></span> <span class="identifier">result</span><span class="special">;</span>                                     <span class="comment">// Must be assigned to return value.</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">function</span><span class="special">()</span>  <span class="comment">// Same for all other contracts.</span>
    <span class="special">...</span>
    <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">{</span>                                <span class="comment">// Also capture `result` reference...</span>
        <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">result</span> <span class="special">...);</span>              <span class="comment">// ...but should not modify captures.</span>
        <span class="special">...</span>
    <span class="special">})</span>
<span class="special">;</span>
</pre>
<p>
        At any point where the enclosing function returns, programmers are responsible
        to assign the result variable to the expression being returned. This can
        be easily done by making sure that <span class="emphasis"><em>all</em></span> <code class="computeroutput"><span class="keyword">return</span></code> statements in the function are of the
        form:
      </p>
<pre class="programlisting"><span class="keyword">return</span> <span class="identifier">result</span> <span class="special">=</span> <span class="emphasis"><em>expression</em></span><span class="special">;</span>                             <span class="comment">// Assign `result` at each return.</span>
</pre>
<p>
        The functor used to program postconditions should capture the result variable
        by reference and not by value (because postconditions must access the value
        the result variable will have at function exit, and not the value the result
        variable had when the postcondition functor was first constructed). The return
        value should never be used in preconditions (because the return value is
        not yet evaluated and set when preconditions are checked). In any case, programmers
        should not modify the result variable in the contract assertions (see also
        <a class="link" href="contract_programming_overview.html#boost_contract.contract_programming_overview.constant_correctness" title="Constant-Correctness">Constant-Correctness</a>).
      </p>
<p>
        It is also possible to declared the result variables using <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">optional</span></code> when the function return type
        does not have a default constructor, or if the default constructor is too
        expensive or undesirable to execute (see <a class="link" href="advanced_topics.html#boost_contract.advanced_topics.optional_return_value" title="Optional Return Value">Optional
        Return Value</a>).
      </p>
<p>
        Non-void virtual and overriding public member functions must always declare
        and use a result variable even when postconditions do not directly use the
        function return value (so to properly support subcontracting, see <a class="link" href="tutorial.html#boost_contract.tutorial.virtual_public_functions" title="Virtual Public Functions">Virtual
        Public Functions</a> and __Overriding_Public_Functions__).
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_contract.tutorial.old_values"></a><a class="link" href="tutorial.html#boost_contract.tutorial.old_values" title="Old Values">Old Values</a>
</h3></div></div></div>
<p>
        When old values are used in postconditions, programmes are responsible to
        declare local variables before the contract and to assign them to related
        old value expressions using the <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OLDOF.html" title="Macro BOOST_CONTRACT_OLDOF">BOOST_CONTRACT_OLDOF</a></code>
        macro. <a href="#ftn.boost_contract.tutorial.old_values.f0" class="footnote" name="boost_contract.tutorial.old_values.f0"><sup class="footnote">[15]</sup></a> For example, for <code class="computeroutput"><a class="link" href="../boost/contract/function.html" title="Function function">boost::contract::function</a></code>
        (but same for all other contracts):
      </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">old_ptr</span><span class="special">&lt;</span><span class="emphasis"><em>type</em></span><span class="special">&gt;</span> <span class="identifier">old_</span><span class="emphasis"><em>name</em></span> <span class="special">=</span> <span class="identifier">BOOST_CONTRACT_OLDOF</span><span class="special">(</span><span class="emphasis"><em>expression</em></span><span class="special">);</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">function</span><span class="special">()</span>  <span class="comment">// Same for all other contracts.</span>
    <span class="special">...</span>
    <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">{</span>                                <span class="comment">// Capture by reference...</span>
        <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(*</span><span class="identifier">old_</span><span class="emphasis"><em>name</em></span> <span class="special">...);</span>           <span class="comment">// ...but should not modify captures.</span>
        <span class="special">...</span>
    <span class="special">})</span>
<span class="special">;</span>
</pre>
<p>
        Old values are handled by this library using the smart pointer class template
        <code class="computeroutput"><a class="link" href="../boost/contract/old_ptr.html" title="Class template old_ptr">boost::contract::old_ptr</a></code>
        (so programmers do not directly manage the allocation and deallocation of
        the pointed memory). The pointed old value is automatically qualified as
        <code class="computeroutput"><span class="keyword">const</span></code> (so old values cannot
        be mistakenly changed by the contract assertions, see also <a class="link" href="contract_programming_overview.html#boost_contract.contract_programming_overview.constant_correctness" title="Constant-Correctness">Constant-Correctness</a>).
        This library ensures that old value pointers are always not null by the time
        postconditions are checked (so programmers can safely dereference these pointers
        in postcondition assertions using <code class="computeroutput"><span class="keyword">operator</span><span class="special">*</span></code> or <code class="computeroutput"><span class="keyword">operator</span><span class="special">-&gt;</span></code> without having to check if old value
        pointers are not null first).
      </p>
<p>
        Old values should never be used in preconditions (because old values are
        the same as the original values when preconditions are checked). This library
        does not even guarantee that old value pointers are not null when precondition
        functors are called (for example, when postcondition contract checking is
        disabled using <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_NO_POSTCONDITIONS.html" title="Macro BOOST_CONTRACT_NO_POSTCONDITIONS">BOOST_CONTRACT_NO_POSTCONDITIONS</a></code>,
        when checking an overridden virtual public function contract via subcontracting,
        etc.). Finally, see <a class="link" href="advanced_topics.html#boost_contract.advanced_topics.old_values_at_body" title="Old Values at Body">Old
        Values at Body</a> for delaying the assignment of old values until after
        preconditions (and possibly class invariants) are checked (this allows to
        program old value expressions under the simplifying assumption that precondition
        and class invariant assertions are satisfied already).
      </p>
<p>
        The <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OLDOF.html" title="Macro BOOST_CONTRACT_OLDOF">BOOST_CONTRACT_OLDOF</a></code>
        macro is actually a variadic macro and it takes an extra parameter when used
        in virtual or overriding public functions (see <a class="link" href="tutorial.html#boost_contract.tutorial.virtual_public_functions" title="Virtual Public Functions">Virtual
        Public Functions</a> and __Overriding_Public_Functions__). C++11 auto
        declarations can be used with <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OLDOF.html" title="Macro BOOST_CONTRACT_OLDOF">BOOST_CONTRACT_OLDOF</a></code>
        for brevity <code class="computeroutput"><span class="keyword">auto</span> </code><code class="literal">old_<span class="emphasis"><em>name</em></span>
        = BOOST_CONTRACT_OLDOF(<span class="emphasis"><em>expression</em></span>)</code>. See <a class="link" href="advanced_topics.html#boost_contract.advanced_topics.no_macros__no_c__11_" title="No Macros (No C++11)">No Macros</a>
        to program old values without using <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OLDOF.html" title="Macro BOOST_CONTRACT_OLDOF">BOOST_CONTRACT_OLDOF</a></code>
        (e.g., on compilers that do not support variadic macros).
      </p>
<p>
        This library ensures that old values are copied only once and that they are
        never copied when postcondition contract checking is disabled using <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_NO_POSTCONDITIONS.html" title="Macro BOOST_CONTRACT_NO_POSTCONDITIONS">BOOST_CONTRACT_NO_POSTCONDITIONS</a></code>.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_contract.tutorial.class_invariants"></a><a class="link" href="tutorial.html#boost_contract.tutorial.class_invariants" title="Class Invariants">Class Invariants</a>
</h3></div></div></div>
<p>
        When class invariants are specified, they are programmed in a public <code class="computeroutput"><span class="keyword">const</span></code> member function named <code class="computeroutput"><span class="identifier">invariant</span></code> taking no argument and returning
        <code class="computeroutput"><span class="keyword">void</span></code>. Classes that do not have
        invariants, simply do not declare the <code class="computeroutput"><span class="identifier">invariant</span></code>
        member function. <a href="#ftn.boost_contract.tutorial.class_invariants.f0" class="footnote" name="boost_contract.tutorial.class_invariants.f0"><sup class="footnote">[16]</sup></a> For example:
      </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">a</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>                                 <span class="comment">// Must be public.</span>
    <span class="keyword">void</span> <span class="identifier">invariant</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span>            <span class="comment">// Must be const.</span>
        <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(...);</span>
        <span class="special">...</span>
    <span class="special">}</span>

    <span class="special">...</span>
<span class="special">};</span>
</pre>
<p>
        This member function must be <code class="computeroutput"><span class="keyword">const</span></code>
        because contracts should not modify the object state (see also <a class="link" href="contract_programming_overview.html#boost_contract.contract_programming_overview.constant_correctness" title="Constant-Correctness">Constant-Correctness</a>).
        This library will generate a compile-time error if the <code class="computeroutput"><span class="keyword">const</span></code>
        qualifier is missing (unless the <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_PERMISSIVE.html" title="Macro BOOST_CONTRACT_PERMISSIVE">BOOST_CONTRACT_PERMISSIVE</a></code>
        macro is defined).
      </p>
<p>
        Any code can be programmed in the <code class="computeroutput"><span class="identifier">invariant</span></code>
        function, but it is recommended to keep this code simple using mainly assertions
        and if-statements (to avoid programming complex invariants that might be
        buggy and slow to execute at run-time). It is also recommended to use the
        <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_ASSERT.html" title="Macro BOOST_CONTRACT_ASSERT">BOOST_CONTRACT_ASSERT</a></code>
        macro to program class invariant assertions because it enables this library
        to print very informative error messages when the asserted conditions are
        evaluated to be false at run-time (this is not a variadic macro, but see
        also <a class="link" href="advanced_topics.html#boost_contract.advanced_topics.no_macros__no_c__11_" title="No Macros (No C++11)">No
        Macros</a>):
      </p>
<pre class="programlisting"><span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="emphasis"><em>boolean-condition</em></span><span class="special">)</span>
<span class="comment">// Or, if condition has commas `,` not already within parenthesis `(...)`.</span>
<span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">((</span><span class="emphasis"><em>boolean-condition</em></span><span class="special">))</span>
</pre>
<p>
        This library will automatically call <code class="computeroutput">boost::contract::entry_invariant_failure</code>
        or <code class="computeroutput">boost::contract::exit_invariant_failure</code>
        if any of the <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_ASSERT.html" title="Macro BOOST_CONTRACT_ASSERT">BOOST_CONTRACT_ASSERT</a></code>
        macro conditions are <code class="computeroutput"><span class="keyword">false</span></code> and
        also if the <code class="computeroutput"><span class="identifier">invariant</span></code> function
        throws an exception (by default, this terminates the program calling <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">terminate</span></code>,
        but see <a class="link" href="advanced_topics.html#boost_contract.advanced_topics.throw_on_failure" title="Throw on Failure">Throw
        on Failure</a> to throw exceptions, exit the program with an error code,
        etc.).
      </p>
<p>
        See __Access__ to avoid making the <code class="computeroutput"><span class="identifier">invariant</span></code>
        member function <code class="computeroutput"><span class="keyword">public</span></code>. <a href="#ftn.boost_contract.tutorial.class_invariants.f1" class="footnote" name="boost_contract.tutorial.class_invariants.f1"><sup class="footnote">[17]</sup></a> See the <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_INVARIANT.html" title="Macro BOOST_CONTRACT_INVARIANT">BOOST_CONTRACT_INVARIANT</a></code>
        macro to use a name different from <code class="computeroutput"><span class="identifier">invariant</span></code>
        (e.g., because <code class="computeroutput"><span class="identifier">invariant</span></code>
        clashes with other names in user-defined classes).
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          No contracts are checked (not event class invariants) when a data member
          is accessed directly (this is different from Eiffel where even accessing
          public data members checks class invariants). Therefore, it might be best
          for both <code class="computeroutput"><span class="keyword">class</span></code>es and <code class="computeroutput"><span class="keyword">struct</span></code>s that have invariants to have no
          mutable public data members and to access data members publicly only via
          appropriate public member functions that can check the class invariants.
        </p></td></tr>
</table></div>
<h5>
<a name="boost_contract.tutorial.class_invariants.h0"></a>
        <span class="phrase"><a name="boost_contract.tutorial.class_invariants.static_class_invariants"></a></span><a class="link" href="tutorial.html#boost_contract.tutorial.class_invariants.static_class_invariants">Static
        Class Invariants</a>
      </h5>
<p>
        When static class invariants are specified, they are programmed in a public
        <code class="computeroutput"><span class="keyword">static</span></code> member functions named
        <code class="computeroutput"><span class="identifier">static_invariant</span></code> taking no
        argument and returning <code class="computeroutput"><span class="keyword">void</span></code>.
        Classes that do not have static class invariants, simply do not declare a
        <code class="computeroutput"><span class="identifier">static_invariant</span></code> member function.
        <a href="#ftn.boost_contract.tutorial.class_invariants.f2" class="footnote" name="boost_contract.tutorial.class_invariants.f2"><sup class="footnote">[18]</sup></a> For example:
      </p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">a</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>                                 <span class="comment">// Must be public.</span>
    <span class="keyword">static</span> <span class="keyword">void</span> <span class="identifier">static_invariant</span><span class="special">()</span> <span class="special">{</span>    <span class="comment">// Must be static.</span>
        <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(...);</span>
        <span class="special">...</span>
    <span class="special">}</span>

    <span class="special">...</span>
<span class="special">};</span>
</pre>
<p>
        This member function must be <code class="computeroutput"><span class="keyword">static</span></code>
        so it correctly cannot access the object <code class="computeroutput"><span class="keyword">this</span></code>.
        This library will generate a compile-time error if the <code class="computeroutput"><span class="keyword">static</span></code>
        classifier is missing (unless the <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_PERMISSIVE.html" title="Macro BOOST_CONTRACT_PERMISSIVE">BOOST_CONTRACT_PERMISSIVE</a></code>
        macro is defined).
      </p>
<p>
        Any code can be programmed in the <code class="computeroutput"><span class="identifier">static_invariant</span></code>
        function, but it is recommended to keep this code simple using mainly assertions
        and if-statements (to avoid programming complex static invariants that might
        be buggy and slow to execute at run-time). It is also recommended to use
        the <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_ASSERT.html" title="Macro BOOST_CONTRACT_ASSERT">BOOST_CONTRACT_ASSERT</a></code>
        macro to program the assertions because it enables this library to print
        very informative error messages when the asserted conditions are evaluated
        to be false at run-time (this is not a variadic macro, but see also <a class="link" href="advanced_topics.html#boost_contract.advanced_topics.no_macros__no_c__11_" title="No Macros (No C++11)">No Macros</a>):
      </p>
<pre class="programlisting"><span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="emphasis"><em>boolean-condition</em></span><span class="special">)</span>
<span class="comment">// Or, if condition has commas `,` not already within parenthesis `(...)`.</span>
<span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">((</span><span class="emphasis"><em>boolean-condition</em></span><span class="special">))</span>
</pre>
<p>
        This library will automatically call <code class="computeroutput">boost::contract::entry_invariant_failure</code>
        or <code class="computeroutput">boost::contract::exit_invariant_failure</code>
        if any of the <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_ASSERT.html" title="Macro BOOST_CONTRACT_ASSERT">BOOST_CONTRACT_ASSERT</a></code>
        macro conditions are <code class="computeroutput"><span class="keyword">false</span></code> and
        also if the <code class="computeroutput"><span class="identifier">static_invariant</span></code>
        function throws an exception (by default, this terminates the program calling
        <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">terminate</span></code>, but see <a class="link" href="advanced_topics.html#boost_contract.advanced_topics.throw_on_failure" title="Throw on Failure">Throw
        on Failure</a> to throw exceptions, exit the program with an error code,
        etc.).
      </p>
<p>
        See __Access__ to avoid making <code class="computeroutput"><span class="identifier">static_invariant</span></code>
        member function <code class="computeroutput"><span class="keyword">public</span></code>. <a href="#ftn.boost_contract.tutorial.class_invariants.f3" class="footnote" name="boost_contract.tutorial.class_invariants.f3"><sup class="footnote">[19]</sup></a> Set the <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_STATIC_INVARIANT.html" title="Macro BOOST_CONTRACT_STATIC_INVARIANT">BOOST_CONTRACT_STATIC_INVARIANT</a></code>
        macro to use a name different from <code class="computeroutput"><span class="identifier">static_invariant</span></code>
        (e.g., because <code class="computeroutput"><span class="identifier">static_invariant</span></code>
        clashes with other names in the user-defined class). <a href="#ftn.boost_contract.tutorial.class_invariants.f4" class="footnote" name="boost_contract.tutorial.class_invariants.f4"><sup class="footnote">[20]</sup></a>
      </p>
<p>
        See __Volatile_Public_Functions__ for programming volatile class invariants.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_contract.tutorial.constructors"></a><a class="link" href="tutorial.html#boost_contract.tutorial.constructors" title="Constructors">Constructors</a>
</h3></div></div></div>
<p>
        Contracts for constructors are programmed using the <code class="computeroutput"><a class="link" href="../boost/contract/constructor.html" title="Function template constructor">boost::contract::constructor</a></code>
        function and the <code class="computeroutput"><a class="link" href="../boost/contract/constructor_precondition.html" title="Class template constructor_precondition">boost::contract::constructor_precondition</a></code>
        base class. For example (see also <a href="../../../example/features/public.cpp" target="_top"><code class="literal">public.cpp</code></a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">unique_identifiers</span>
    <span class="special">:</span> <span class="keyword">private</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">constructor_precondition</span><span class="special">&lt;</span><span class="identifier">unique_identifiers</span><span class="special">&gt;</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">unique_identifiers</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">from</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">to</span><span class="special">)</span> <span class="special">:</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">constructor_precondition</span><span class="special">&lt;</span><span class="identifier">unique_identifiers</span><span class="special">&gt;([&amp;]</span> <span class="special">{</span>
            <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">from</span> <span class="special">&lt;=</span> <span class="identifier">to</span><span class="special">);</span>
        <span class="special">})</span>
    <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">constructor</span><span class="special">(</span><span class="keyword">this</span><span class="special">)</span>
            <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">size</span><span class="special">()</span> <span class="special">==</span> <span class="special">(</span><span class="identifier">to</span> <span class="special">-</span> <span class="identifier">from</span> <span class="special">+</span> <span class="number">1</span><span class="special">));</span>
            <span class="special">})</span>
        <span class="special">;</span>

        <span class="comment">// Constructor body.</span>
        <span class="keyword">for</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">id</span> <span class="special">=</span> <span class="identifier">from</span><span class="special">;</span> <span class="identifier">id</span> <span class="special">&lt;=</span> <span class="identifier">to</span><span class="special">;</span> <span class="special">++</span><span class="identifier">id</span><span class="special">)</span> <span class="identifier">vect_</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">id</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="comment">/* ... */</span>
</pre>
<p>
      </p>
<p>
        It is not possible to specify preconditions using <code class="computeroutput"><span class="special">.</span><span class="identifier">precondition</span><span class="special">(...)</span></code>
        for constructors (the library will generate a compile-time error if <code class="computeroutput"><span class="special">.</span><span class="identifier">precondition</span><span class="special">(...)</span></code> is used on the object returned by <code class="computeroutput"><a class="link" href="../boost/contract/constructor.html" title="Function template constructor">boost::contract::constructor</a></code>).
        Constructor preconditions are specified using the <code class="computeroutput">boost::contract:constructor_precondition</code>
        base class instead (see also <a class="link" href="tutorial.html#boost_contract.tutorial.preconditions" title="Preconditions">Preconditions</a>).
        Programmes should not access the object <code class="computeroutput"><span class="keyword">this</span></code>
        from constructor preconditions (because the object does not exists yet before
        the constructor body is executed, see also <a class="link" href="advanced_topics.html#boost_contract.advanced_topics.no_lambda_functions__no_c__11_" title="No Lambda Functions (No C++11)">No
        Lambda Functions</a>). Constructors without preconditions simply do not
        explicitly initialize the <code class="computeroutput"><a class="link" href="../boost/contract/constructor_precondition.html" title="Class template constructor_precondition">boost::contract::constructor_precondition</a></code>
        base (because <code class="computeroutput"><a class="link" href="../boost/contract/constructor_precondition.html" title="Class template constructor_precondition">boost::contract::constructor_precondition</a></code>
        default constructor checks no contract). When <code class="computeroutput"><a class="link" href="../boost/contract/constructor_precondition.html" title="Class template constructor_precondition">boost::contract::constructor_precondition</a></code>
        is used: <a href="#ftn.boost_contract.tutorial.constructors.f0" class="footnote" name="boost_contract.tutorial.constructors.f0"><sup class="footnote">[21]</sup></a>
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            It should be specified as the <span class="emphasis"><em>first</em></span> class in the
            inheritance list (so constructor preconditions are checked before initializing
            any other base or member).
          </li>
<li class="listitem">
            Its inheritance level should always be <code class="computeroutput"><span class="keyword">private</span></code>
            (so this extra base class does not alter the public inheritance tree
            of the derived class).
          </li>
<li class="listitem">
            It takes the derived class as template parameter (the Curiously Recursive
            Template Pattern (CRTP) is used here to avoid ambiguity errors with multiple
            inheritance). <a href="#ftn.boost_contract.tutorial.constructors.f1" class="footnote" name="boost_contract.tutorial.constructors.f1"><sup class="footnote">[22]</sup></a>
          </li>
</ul></div>
<p>
        It is possible to specify postconditions for constructors (see also <a class="link" href="tutorial.html#boost_contract.tutorial.postconditions" title="Postconditions">Postconditions</a>).
        Programmers should not access the old value of the object <code class="computeroutput"><span class="keyword">this</span></code>
        in constructor postconditions (because the object did not exist yet before
        the constructor body was executed, see also <a class="link" href="advanced_topics.html#boost_contract.advanced_topics.no_lambda_functions__no_c__11_" title="No Lambda Functions (No C++11)">No
        Lambda Functions</a>). The <code class="computeroutput"><a class="link" href="../boost/contract/constructor.html" title="Function template constructor">boost::contract::constructor</a></code>
        function takes <code class="computeroutput"><span class="keyword">this</span></code> as a parameter
        because constructors check class invariants (see also <a class="link" href="tutorial.html#boost_contract.tutorial.class_invariants" title="Class Invariants">Class
        Invariants</a>).
      </p>
<p>
        The <code class="computeroutput"><a class="link" href="../boost/contract/constructor.html" title="Function template constructor">boost::contract::constructor</a></code>
        function returns an RAII object that must always be assigned to a local variable
        of type <code class="computeroutput"><a class="link" href="../boost/contract/guard.html" title="Class guard">boost::contract::guard</a></code>
        otherwise this library will generate a run-time error (note that C++11 <code class="computeroutput"><span class="keyword">auto</span></code> declarations cannot be used here and
        the <code class="computeroutput"><a class="link" href="../boost/contract/guard.html" title="Class guard">boost::contract::guard</a></code>
        type must be explicitly specified). The constructor body is programmed right
        after the declaration of this RAII object. At construction, this RAII object
        does the following:
      </p>
<div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
            Check static class invariants, by calling <span class="emphasis"><em><code class="literal">typeof</code></em></span><code class="computeroutput"><span class="special">(*</span><span class="keyword">this</span><span class="special">)::</span><span class="identifier">static_invariant</span><span class="special">()</span></code> (but not non-static class invariants
            because the object does not exists yet).
          </li></ol></div>
<p>
        At destruction instead:
      </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
            Check static class invariants, by calling <span class="emphasis"><em><code class="literal">typeof</code></em></span><code class="computeroutput"><span class="special">(*</span><span class="keyword">this</span><span class="special">)::</span><span class="identifier">static_invariant</span><span class="special">()</span></code>.
          </li>
<li class="listitem">
            If the constructor body did not throw an exception:
            <div class="orderedlist"><ol class="orderedlist" type="a">
<li class="listitem">
                  Check non-static class invariants, by calling <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">invariant</span><span class="special">()</span></code>.
                </li>
<li class="listitem">
                  Check postconditions, by calling the nullary functor <span class="emphasis"><em><code class="literal">g</code></em></span><code class="computeroutput"><span class="special">()</span></code> passed to <code class="computeroutput"><span class="special">.</span><span class="identifier">postcondition</span><span class="special">(</span></code><span class="emphasis"><em><code class="literal">g</code></em></span><code class="computeroutput"><span class="special">)</span></code>.
                </li>
</ol></div>
          </li>
</ol></div>
<p>
        This together with C++ object construction mechanism of base classes and
        the use of <code class="computeroutput"><a class="link" href="../boost/contract/constructor_precondition.html" title="Class template constructor_precondition">boost::contract::constructor_precondition</a></code>
        ensures that the constructor contracts are correctly checked at run-time
        (see also <a class="link" href="contract_programming_overview.html#boost_contract.contract_programming_overview.constructor_calls" title="Constructor Calls">Constructor
        Calls</a>).
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
<p>
          A constructor can avoid calling <code class="computeroutput"><a class="link" href="../boost/contract/constructor.html" title="Function template constructor">boost::contract::constructor</a></code>
          for efficiency but only when it has no postconditions and its class has
          no invariants. (Even if <code class="computeroutput">boost::contract::constuctor</code>
          is not used by a derived class, contracts of base classes will still be
          correctly checked by C++ object construction mechanism.)
        </p>
<p>
          The default constructor and copy constructor automatically generated by
          C++ will not check contracts. Therefore, unless these constructors are
          not public or they have no preconditions, no postconditions, and the class
          has no invariants, programmers should manually define them using <code class="computeroutput"><a class="link" href="../boost/contract/constructor.html" title="Function template constructor">boost::contract::constructor</a></code>
          and <code class="computeroutput"><a class="link" href="../boost/contract/constructor_precondition.html" title="Class template constructor_precondition">boost::contract::constructor_precondition</a></code>.
          (Same for all other automatically generated operations.)
        </p>
</td></tr>
</table></div>
<p>
        Private and protected constructors can omit <code class="computeroutput"><a class="link" href="../boost/contract/constructor.html" title="Function template constructor">boost::contract::constructor</a></code>
        because they are not part of the public interface of the class so they are
        not required to check class invariants (see also <a class="link" href="contract_programming_overview.html#boost_contract.contract_programming_overview.constructor_calls" title="Constructor Calls">Constructor
        Calls</a>). They could still use <code class="computeroutput"><a class="link" href="../boost/contract/constructor_precondition.html" title="Class template constructor_precondition">boost::contract::constructor_precondition</a></code>
        to check preconditions before member initializations, and use <code class="computeroutput"><a class="link" href="../boost/contract/function.html" title="Function function">boost::contract::function</a></code>
        (but not <code class="computeroutput"><a class="link" href="../boost/contract/constructor.html" title="Function template constructor">boost::contract::constructor</a></code>)
        to only check postconditions without checking class invariants (see also
        <a class="link" href="tutorial.html#boost_contract.tutorial.private_and_protected_functions" title="Private and Protected Functions">Private
        and Protected Functions</a>).
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_contract.tutorial.destructors"></a><a class="link" href="tutorial.html#boost_contract.tutorial.destructors" title="Destructors">Destructors</a>
</h3></div></div></div>
<p>
        Contracts for destructors are programmed using the <code class="computeroutput"><a class="link" href="../boost/contract/destructor.html" title="Function template destructor">boost::contract::destructor</a></code>
        function. For example (see also <a href="../../../example/features/public.cpp" target="_top"><code class="literal">public.cpp</code></a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">virtual</span> <span class="special">~</span><span class="identifier">unique_identifiers</span><span class="special">()</span> <span class="special">{</span>
    <span class="comment">// Following contract checks invariants.</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">destructor</span><span class="special">(</span><span class="keyword">this</span><span class="special">);</span>

    <span class="comment">// Destructor body here... (do nothing in this example).</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        It is not possible to specify preconditions for destructors (the library
        will generate a compile-time error if <code class="computeroutput"><span class="special">.</span><span class="identifier">precondition</span><span class="special">(...)</span></code>
        is used here because destructors can be called at any time after construction
        so they have no precondition). It is possible to specify postconditions for
        destructors (see also <a class="link" href="tutorial.html#boost_contract.tutorial.postconditions" title="Postconditions">Postconditions</a>
        for more information and see __Static_Public_Functions__ for an example).
        Programmers should not access the object <code class="computeroutput"><span class="keyword">this</span></code>
        in destructor postconditions (because the object no longer exists after the
        destructor body has been executed, see also <a class="link" href="advanced_topics.html#boost_contract.advanced_topics.no_lambda_functions__no_c__11_" title="No Lambda Functions (No C++11)">No
        Lambda Functions</a>). The <code class="computeroutput"><a class="link" href="../boost/contract/destructor.html" title="Function template destructor">boost::contract::destructor</a></code>
        function takes <code class="computeroutput"><span class="keyword">this</span></code> as a parameter
        because destructors check class invariants (see also <a class="link" href="tutorial.html#boost_contract.tutorial.class_invariants" title="Class Invariants">Class
        Invariants</a>).
      </p>
<p>
        The <code class="computeroutput"><a class="link" href="../boost/contract/destructor.html" title="Function template destructor">boost::contract::destructor</a></code>
        function returns an RAII object that must always be assigned to a local variable
        of type <code class="computeroutput"><a class="link" href="../boost/contract/guard.html" title="Class guard">boost::contract::guard</a></code>
        otherwise this library will generate a run-time error (note that C++11 <code class="computeroutput"><span class="keyword">auto</span></code> declarations cannot be used here and
        the <code class="computeroutput"><a class="link" href="../boost/contract/guard.html" title="Class guard">boost::contract::guard</a></code>
        type must be explicitly specified). The destructor body is programmed right
        after the declaration of this RAII object. At construction, this RAII object
        does the following:
      </p>
<div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
            Check static and non-static class invariants, by calling <span class="emphasis"><em><code class="literal">typeof</code></em></span><code class="computeroutput"><span class="special">(*</span><span class="keyword">this</span><span class="special">)::</span><span class="identifier">static_invariant</span><span class="special">()</span></code> <a class="link" href="contract_programming_overview.html#and_anchor"><code class="literal"><span class="emphasis"><em>AND</em></span></code></a>
            <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">invariant</span><span class="special">()</span></code>.
          </li></ol></div>
<p>
        At destruction instead:
      </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
            Check static class invariants, by calling <span class="emphasis"><em><code class="literal">typeof</code></em></span><code class="computeroutput"><span class="special">(*</span><span class="keyword">this</span><span class="special">)::</span><span class="identifier">static_invariant</span><span class="special">()</span></code>.
          </li>
<li class="listitem">
            If the destructor body threw an exception:
            <div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
                  Check non-static class invariants, by calling <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">invariant</span><span class="special">()</span></code> (because the object was not successfully
                  destructed).
                </li></ol></div>
          </li>
<li class="listitem">
            Else:
            <div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
                  Check postconditions, by calling the nullay functor <span class="emphasis"><em><code class="literal">g</code></em></span><code class="computeroutput"><span class="special">()</span></code> passed to <code class="computeroutput"><span class="special">.</span><span class="identifier">postcondition</span><span class="special">(</span></code><span class="emphasis"><em><code class="literal">g</code></em></span><code class="computeroutput"><span class="special">)</span></code>.
                </li></ol></div>
          </li>
</ol></div>
<p>
        This together with C++ object destruction mechanism of base classes ensures
        that destructor contracts are correctly checked at run-time (see also <a class="link" href="contract_programming_overview.html#boost_contract.contract_programming_overview.destructor_calls" title="Destructor Calls">Destructor
        Calls</a>).
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
<p>
          A destructor can avoid calling <code class="computeroutput"><a class="link" href="../boost/contract/destructor.html" title="Function template destructor">boost::contract::destructor</a></code>
          for efficiency but only when it has no postconditions and its class has
          no invariants. (Even if <code class="computeroutput"><a class="link" href="../boost/contract/destructor.html" title="Function template destructor">boost::contract::destructor</a></code>
          is not used by a derived class, contracts of base classes will still be
          correctly checked by C++ object destruction mechanism.)
        </p>
<p>
          The default destructor automatically generated by C++ will not check contracts.
          Therefore, unless the destructor is not public or it has no postconditions
          and the class has no invariants, programmers should manually define it
          using <code class="computeroutput"><a class="link" href="../boost/contract/destructor.html" title="Function template destructor">boost::contract::destructor</a></code>.
          (Same for all other automatically generated operations.)
        </p>
</td></tr>
</table></div>
<p>
        Private and protected destructors can omit <code class="computeroutput"><a class="link" href="../boost/contract/destructor.html" title="Function template destructor">boost::contract::destructor</a></code>
        because they are not part of the public interface of the class so they are
        not required to check class invariants (see also <a class="link" href="contract_programming_overview.html#boost_contract.contract_programming_overview.destructor_calls" title="Destructor Calls">Destructor
        Calls</a>). They could use <code class="computeroutput"><a class="link" href="../boost/contract/function.html" title="Function function">boost::contract::function</a></code>
        (but not <code class="computeroutput"><a class="link" href="../boost/contract/destructor.html" title="Function template destructor">boost::contract::destructor</a></code>)
        to only check postconditions without checking class invariants (see also
        <a class="link" href="tutorial.html#boost_contract.tutorial.private_and_protected_functions" title="Private and Protected Functions">Private
        and Protected Functions</a>).
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_contract.tutorial.public_functions"></a><a class="link" href="tutorial.html#boost_contract.tutorial.public_functions" title="Public Functions">Public Functions</a>
</h3></div></div></div>
<p>
        Contracts for public member functions are programmed using the <code class="computeroutput"><a class="link" href="../boost/contract/public_function_id480248.html" title="Function template public_function">boost::contract::public_function</a></code>
        function.
      </p>
<p>
        Let's consider public member functions that are not static, not virtual,
        and do not override any function from base classes. For example, the following
        such a function <code class="computeroutput"><span class="identifier">find</span></code> is declared
        as a member of the <code class="computeroutput"><span class="identifier">unique_identifiers</span></code>
        class (see also <a href="../../../example/features/public.cpp" target="_top"><code class="literal">public.cpp</code></a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">bool</span> <span class="identifier">find</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">id</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span>
    <span class="keyword">bool</span> <span class="identifier">result</span><span class="special">;</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">(</span><span class="keyword">this</span><span class="special">)</span>
        <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
            <span class="keyword">if</span><span class="special">(</span><span class="identifier">size</span><span class="special">()</span> <span class="special">==</span> <span class="number">0</span><span class="special">)</span> <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(!</span><span class="identifier">result</span><span class="special">);</span>
        <span class="special">})</span>
    <span class="special">;</span>

    <span class="comment">// Function body.</span>
    <span class="keyword">return</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">find</span><span class="special">(</span><span class="identifier">vect_</span><span class="special">.</span><span class="identifier">begin</span><span class="special">(),</span> <span class="identifier">vect_</span><span class="special">.</span><span class="identifier">end</span><span class="special">(),</span> <span class="identifier">id</span><span class="special">)</span> <span class="special">!=</span>
            <span class="identifier">vect_</span><span class="special">.</span><span class="identifier">end</span><span class="special">();</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        It is possible to specify both preconditions and postconditions for public
        member functions (see also <a class="link" href="tutorial.html#boost_contract.tutorial.preconditions" title="Preconditions">Preconditions</a>
        and <a class="link" href="tutorial.html#boost_contract.tutorial.postconditions" title="Postconditions">Postconditions</a>).
        The <code class="computeroutput"><a class="link" href="../boost/contract/public_function_id480248.html" title="Function template public_function">boost::contract::public_function</a></code>
        function takes <code class="computeroutput"><span class="keyword">this</span></code> as a parameter
        because public member functions check class invariants (see also <a class="link" href="tutorial.html#boost_contract.tutorial.class_invariants" title="Class Invariants">Class
        Invariants</a>).
      </p>
<p>
        The <code class="computeroutput"><a class="link" href="../boost/contract/public_function_id480248.html" title="Function template public_function">boost::contract::public_function</a></code>
        function returns an RAII object that must always be assigned to a local variable
        of type <code class="computeroutput"><a class="link" href="../boost/contract/guard.html" title="Class guard">boost::contract::guard</a></code>
        otherwise this library will generate a run-time error (note that C++11 <code class="computeroutput"><span class="keyword">auto</span></code> declarations cannot be used here and
        the <code class="computeroutput"><a class="link" href="../boost/contract/guard.html" title="Class guard">boost::contract::guard</a></code>
        type must be explicitly specified). The public member function body is programmed
        right after the declaration of this RAII object. At construction, this RAII
        object does the following:
      </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
            Check static and non-static class invariants, by calling <span class="emphasis"><em><code class="literal">typeof</code></em></span><code class="computeroutput"><span class="special">(*</span><span class="keyword">this</span><span class="special">)::</span><span class="identifier">static_invariant</span><span class="special">()</span></code> <a class="link" href="contract_programming_overview.html#and_anchor"><code class="literal"><span class="emphasis"><em>AND</em></span></code></a>
            <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">invariant</span><span class="special">()</span></code>.
          </li>
<li class="listitem">
            Check preconditions, by calling the nullary functor <span class="emphasis"><em><code class="literal">f</code></em></span><code class="computeroutput"><span class="special">()</span></code> passed to <code class="computeroutput"><span class="special">.</span><span class="identifier">precondition</span><span class="special">(</span></code><span class="emphasis"><em><code class="literal">f</code></em></span><code class="computeroutput"><span class="special">)</span></code>.
          </li>
</ol></div>
<p>
        At destruction instead:
      </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
            Check static and non-static class invariants, by calling <span class="emphasis"><em><code class="literal">typeof</code></em></span><code class="computeroutput"><span class="special">(*</span><span class="keyword">this</span><span class="special">)::</span><span class="identifier">static_invariant</span><span class="special">()</span></code> <a class="link" href="contract_programming_overview.html#and_anchor"><code class="literal"><span class="emphasis"><em>AND</em></span></code></a>
            <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">invariant</span><span class="special">()</span></code>
            (even if the function body threw an exception).
          </li>
<li class="listitem">
            If the function body did not throw an exception:
            <div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
                  Check postconditions, by calling the functor <code class="literal"><span class="emphasis"><em>g</em></span></code><code class="computeroutput"><span class="special">()</span></code> passed to <code class="computeroutput"><span class="special">.</span><span class="identifier">postcondition</span><span class="special">(</span></code><span class="emphasis"><em><code class="literal">g</code></em></span><code class="computeroutput"><span class="special">)</span></code> (or <code class="literal"><span class="emphasis"><em>g</em></span></code><code class="computeroutput"><span class="special">(</span></code><span class="emphasis"><em>result</em></span><code class="computeroutput"><span class="special">)</span></code> for non-void public functions).
                </li></ol></div>
          </li>
</ol></div>
<p>
        This ensures that public member function contracts are correctly checked
        at run-time (see also <a class="link" href="contract_programming_overview.html#boost_contract.contract_programming_overview.public_function_calls" title="Public Function Calls">Public
        Function Calls</a>).
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
<p>
          A public member function can avoid calling <code class="computeroutput"><a class="link" href="../boost/contract/public_function_id480248.html" title="Function template public_function">boost::contract::public_function</a></code>
          for efficiency but only when it has no preconditions and no postconditions,
          it is not virtual, it does not override any virtual function, and its class
          has no invariant.
        </p>
<p>
          The default copy assignment operator automatically generated by C++ will
          not check contracts. Therefore, unless this operator is not public or it
          has no preconditions, no postconditions, and the class has no invariants,
          programmers should manually define it using <code class="computeroutput"><a class="link" href="../boost/contract/public_function_id480248.html" title="Function template public_function">boost::contract::public_function</a></code>.
          (Same for all other automatically generated operations.)
        </p>
</td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_contract.tutorial.virtual_public_functions"></a><a class="link" href="tutorial.html#boost_contract.tutorial.virtual_public_functions" title="Virtual Public Functions">Virtual
      Public Functions</a>
</h3></div></div></div>
<p>
        Let's consider public member functions that are virtual but that still do
        not override any function from base classes. For example, the following such
        a function <code class="computeroutput"><span class="identifier">push_back</span></code> is declared
        as a member of the <code class="computeroutput"><span class="identifier">unique_identifiers</span></code>
        class (see also <a href="../../../example/features/public.cpp" target="_top"><code class="literal">public.cpp</code></a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="comment">// Specified identifier must not already be in container.</span>
<span class="keyword">virtual</span> <span class="keyword">int</span> <span class="identifier">push_back</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">id</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">virtual_</span><span class="special">*</span> <span class="identifier">v</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">int</span> <span class="identifier">result</span><span class="special">;</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">old_ptr</span><span class="special">&lt;</span><span class="keyword">bool</span><span class="special">&gt;</span> <span class="identifier">old_find</span> <span class="special">=</span>
                <span class="identifier">BOOST_CONTRACT_OLDOF</span><span class="special">(</span><span class="identifier">v</span><span class="special">,</span> <span class="identifier">find</span><span class="special">(</span><span class="identifier">id</span><span class="special">));</span> <span class="comment">// Pass `v`.</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">old_ptr</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">old_size</span> <span class="special">=</span>
                <span class="identifier">BOOST_CONTRACT_OLDOF</span><span class="special">(</span><span class="identifier">v</span><span class="special">,</span> <span class="identifier">size</span><span class="special">());</span> <span class="comment">// Pass `v`.</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">(</span>
            <span class="identifier">v</span><span class="special">,</span> <span class="identifier">result</span><span class="special">,</span> <span class="keyword">this</span><span class="special">)</span> <span class="comment">// Pass `v` and `result`.</span>
        <span class="special">.</span><span class="identifier">precondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
            <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(!</span><span class="identifier">find</span><span class="special">(</span><span class="identifier">id</span><span class="special">));</span>
        <span class="special">})</span>
        <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">(</span><span class="keyword">int</span> <span class="keyword">const</span> <span class="identifier">result</span><span class="special">)</span> <span class="special">{</span>
            <span class="keyword">if</span><span class="special">(!*</span><span class="identifier">old_find</span><span class="special">)</span> <span class="special">{</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">find</span><span class="special">(</span><span class="identifier">id</span><span class="special">));</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">size</span><span class="special">()</span> <span class="special">==</span> <span class="special">*</span><span class="identifier">old_size</span> <span class="special">+</span> <span class="number">1</span><span class="special">);</span>
            <span class="special">}</span>
            <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">result</span> <span class="special">==</span> <span class="identifier">id</span><span class="special">);</span>
        <span class="special">})</span>
    <span class="special">;</span>

    <span class="comment">// Function body.</span>
    <span class="identifier">vect_</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">id</span><span class="special">);</span>
    <span class="keyword">return</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">id</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        Public virtual functions must declare an extra trailing parameter of type
        <code class="computeroutput"><a class="link" href="../boost/contract/virtual_.html" title="Class virtual_">boost::contract::virtual_</a></code><code class="computeroutput"><span class="special">*</span></code> with <code class="computeroutput"><span class="number">0</span></code>
        default value (i.e., <code class="computeroutput"><span class="keyword">nullptr</span></code>).
        <a href="#ftn.boost_contract.tutorial.virtual_public_functions.f0" class="footnote" name="boost_contract.tutorial.virtual_public_functions.f0"><sup class="footnote">[23]</sup></a> This extra parameter is the last parameter and it has a default
        argument so it does not really alter the calling interface of the virtual
        function. Callers will rarely have to explicitly deal with this extra parameter
        (a part from when manipulating the virtual function type directly as a function
        pointer, for function pointer type-casts, etc.). Programmers must pass the
        extra virtual parameter as the very first argument to all <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OLDOF.html" title="Macro BOOST_CONTRACT_OLDOF">BOOST_CONTRACT_OLDOF</a></code>
        and <code class="computeroutput"><a class="link" href="../boost/contract/public_function_id480248.html" title="Function template public_function">boost::contract::public_function</a></code>
        calls in the virtual function. <a href="#ftn.boost_contract.tutorial.virtual_public_functions.f1" class="footnote" name="boost_contract.tutorial.virtual_public_functions.f1"><sup class="footnote">[24]</sup></a>
      </p>
<p>
        The <code class="computeroutput"><a class="link" href="../boost/contract/public_function_id480248.html" title="Function template public_function">boost::contract::public_function</a></code>
        function takes <code class="computeroutput"><span class="keyword">this</span></code> as a parameter
        because public virtual functions check class invariants (see also <a class="link" href="tutorial.html#boost_contract.tutorial.class_invariants" title="Class Invariants">Class
        Invariants</a>). As shown in the example above, when the public virtual
        function has a non-void return type programmers must pass a reference to
        the function return value as the second argument to <code class="computeroutput"><a class="link" href="../boost/contract/public_function_id480248.html" title="Function template public_function">boost::contract::public_function</a></code>.
        In this case the functor specified to <code class="computeroutput"><span class="special">.</span><span class="identifier">postcondition</span><span class="special">(...)</span></code>
        takes a single parameter for the return value (possibly as a constant reference
        <code class="computeroutput"><span class="keyword">const</span><span class="special">&amp;</span></code>
        to avoid extra copies of the return value). <a href="#ftn.boost_contract.tutorial.virtual_public_functions.f2" class="footnote" name="boost_contract.tutorial.virtual_public_functions.f2"><sup class="footnote">[25]</sup></a>
      </p>
<div class="important"><table border="0" summary="Important">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="../../../doc/src/images/important.png"></td>
<th align="left">Important</th>
</tr>
<tr><td align="left" valign="top">
<p>
          It is the responsibility of the programmers to pass the extra parameter
          <code class="computeroutput"><span class="identifier">v</span></code> to all <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OLDOF.html" title="Macro BOOST_CONTRACT_OLDOF">BOOST_CONTRACT_OLDOF</a></code>
          and <code class="computeroutput"><a class="link" href="../boost/contract/public_function_id480248.html" title="Function template public_function">boost::contract::public_function</a></code>
          calls within public virtual functions, and also to pass the return value
          reference after <code class="computeroutput"><span class="identifier">v</span></code> to <code class="computeroutput"><a class="link" href="../boost/contract/public_function_id480248.html" title="Function template public_function">boost::contract::public_function</a></code>
          for non-void public virtual functions. This library cannot automatically
          generate compile-time errors if programmers fail to do so (but in general
          contract checking will not correctly work at run-time). <a href="#ftn.boost_contract.tutorial.virtual_public_functions.f3" class="footnote" name="boost_contract.tutorial.virtual_public_functions.f3"><sup class="footnote">[26]</sup></a>
        </p>
<p>
          <span class="emphasis"><em>Remember: always pass "v" as the first argument to
          old-of macros, the contract, etc. for public virtual functions; always
          pass the result variable after "<code class="computeroutput"><span class="identifier">v</span></code>"
          to the contract for non-void virtual functions.</em></span>
        </p>
</td></tr>
</table></div>
<p>
        For the rest, the same considerations made in <a class="link" href="tutorial.html#boost_contract.tutorial.public_functions" title="Public Functions">Public
        Functions</a> apply.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_contract.tutorial.public_function_overrides__subcontracting_"></a><a class="link" href="tutorial.html#boost_contract.tutorial.public_function_overrides__subcontracting_" title="Public Function Overrides (Subcontracting)">Public
      Function Overrides (Subcontracting)</a>
</h3></div></div></div>
<p>
        Let's consider public member functions (virtual or not) that override public
        virtual functions from one or more public base classes. For example, the
        following such a function <code class="computeroutput"><span class="identifier">push_back</span></code>
        is declared as a member of the <code class="computeroutput"><span class="identifier">identifiers</span></code>
        derived class and it overrides <code class="computeroutput"><span class="identifier">push_back</span></code>
        from the <code class="computeroutput"><span class="identifier">unique_identifiers</span></code>
        base class (see also <a href="../../../example/features/public.cpp" target="_top"><code class="literal">public.cpp</code></a>):
        <a href="#ftn.boost_contract.tutorial.public_function_overrides__subcontracting_.f0" class="footnote" name="boost_contract.tutorial.public_function_overrides__subcontracting_.f0"><sup class="footnote">[27]</sup></a>
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">identifiers</span>
    <span class="preprocessor">#define</span> <span class="identifier">BASES</span> <span class="keyword">public</span> <span class="identifier">unique_identifiers</span>
    <span class="special">:</span> <span class="identifier">BASES</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">BOOST_CONTRACT_BASE_TYPES</span><span class="special">(</span><span class="identifier">BASES</span><span class="special">)</span> <span class="identifier">base_types</span><span class="special">;</span> <span class="comment">// Bases typedef.</span>
    <span class="preprocessor">#undef</span> <span class="identifier">BASES</span>

    <span class="keyword">void</span> <span class="identifier">invariant</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span> <span class="comment">// Check in AND with bases.</span>
        <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">empty</span><span class="special">()</span> <span class="special">==</span> <span class="special">(</span><span class="identifier">size</span><span class="special">()</span> <span class="special">==</span> <span class="number">0</span><span class="special">));</span>
    <span class="special">}</span>

    <span class="comment">// Do nothing if specified identifier already in container.</span>
    <span class="keyword">int</span> <span class="identifier">push_back</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">id</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">virtual_</span><span class="special">*</span> <span class="identifier">v</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="comment">/* override */</span> <span class="special">{</span>
        <span class="keyword">int</span> <span class="identifier">result</span><span class="special">;</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">old_ptr</span><span class="special">&lt;</span><span class="keyword">bool</span><span class="special">&gt;</span> <span class="identifier">old_find</span> <span class="special">=</span>
                <span class="identifier">BOOST_CONTRACT_OLDOF</span><span class="special">(</span><span class="identifier">v</span><span class="special">,</span> <span class="identifier">find</span><span class="special">(</span><span class="identifier">id</span><span class="special">));</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">old_ptr</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">old_size</span> <span class="special">=</span>
                <span class="identifier">BOOST_CONTRACT_OLDOF</span><span class="special">(</span><span class="identifier">v</span><span class="special">,</span> <span class="identifier">size</span><span class="special">());</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">&lt;</span>
            <span class="identifier">override_push_back</span> <span class="comment">// Pass override plus below function pointer...</span>
        <span class="special">&gt;(</span><span class="identifier">v</span><span class="special">,</span> <span class="identifier">result</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">identifiers</span><span class="special">::</span><span class="identifier">push_back</span><span class="special">,</span> <span class="keyword">this</span><span class="special">,</span> <span class="identifier">id</span><span class="special">)</span> <span class="comment">// ...and arguments.</span>
            <span class="special">.</span><span class="identifier">precondition</span><span class="special">([&amp;]</span> <span class="special">{</span> <span class="comment">// Check in OR with bases.</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">find</span><span class="special">(</span><span class="identifier">id</span><span class="special">));</span>
            <span class="special">})</span>
            <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">(</span><span class="keyword">int</span> <span class="keyword">const</span> <span class="identifier">result</span><span class="special">)</span> <span class="special">{</span> <span class="comment">// Check in AND with bases.</span>
                <span class="keyword">if</span><span class="special">(*</span><span class="identifier">old_find</span><span class="special">)</span> <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">size</span><span class="special">()</span> <span class="special">==</span> <span class="special">*</span><span class="identifier">old_size</span><span class="special">);</span>
            <span class="special">})</span>
        <span class="special">;</span>

        <span class="comment">// Function body.</span>
        <span class="keyword">if</span><span class="special">(!</span><span class="identifier">find</span><span class="special">(</span><span class="identifier">id</span><span class="special">))</span> <span class="identifier">unique_identifiers</span><span class="special">::</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">id</span><span class="special">);</span> <span class="comment">// Else, do nothing.</span>
        <span class="keyword">return</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">id</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="identifier">BOOST_CONTRACT_OVERRIDE</span><span class="special">(</span><span class="identifier">push_back</span><span class="special">);</span> <span class="comment">// Define `override_push_back`.</span>

    <span class="comment">/* ... */</span>
</pre>
<p>
      </p>
<p>
        The extra <code class="computeroutput"><span class="keyword">typedef</span></code> that uses
        the <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_BASE_TYPES.html" title="Macro BOOST_CONTRACT_BASE_TYPES">BOOST_CONTRACT_BASE_TYPES</a></code>
        macro is required by this library for derived classes and it is internally
        used detect base classes for subcontracting (see <a class="link" href="tutorial.html#boost_contract.tutorial.base_classes__subcontracting_" title="Base Classes (Subcontracting)">Base
        Classes</a>).
      </p>
<p>
        When called from overriding public functions, <code class="computeroutput"><a class="link" href="../boost/contract/public_function_id480248.html" title="Function template public_function">boost::contract::public_function</a></code>
        takes an explicit template argument <code class="computeroutput"><span class="identifier">override_</span></code><code class="literal"><span class="emphasis"><em>function-name</em></span></code>
        that must be defined by:
      </p>
<pre class="programlisting"><span class="identifier">BOOST_CONTRACT_OVERRIDE</span><span class="special">(</span><span class="emphasis"><em>function-name</em></span><span class="special">)</span>
</pre>
<p>
        This can be used at any point in the public section of the enclosing class
        (see __Access__ to use <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OVERRIDE.html" title="Macro BOOST_CONTRACT_OVERRIDE">BOOST_CONTRACT_OVERRIDE</a></code>
        in a non-public section of the class instead). The <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OVERRIDE.html" title="Macro BOOST_CONTRACT_OVERRIDE">BOOST_CONTRACT_OVERRIDE</a></code>
        macro must be used only once in a class for a given function name and overloaded
        functions can reuse the same <code class="literal">override_<span class="emphasis"><em>function-name</em></span></code>
        definition (plus <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_NAMED_OVERRIDE.html" title="Macro BOOST_CONTRACT_NAMED_OVERRIDE">BOOST_CONTRACT_NAMED_OVERRIDE</a></code>
        can be used to generate a name different than <code class="literal">override_<span class="emphasis"><em>function-name</em></span></code>,
        see also __Overloads_and_Named_Overrides__). This library will generate a
        compile-time error if there is no suitable virtual function to override in
        any of the public base classes. <a href="#ftn.boost_contract.tutorial.public_function_overrides__subcontracting_.f1" class="footnote" name="boost_contract.tutorial.public_function_overrides__subcontracting_.f1"><sup class="footnote">[28]</sup></a>
      </p>
<p>
        For convenience <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OVERRIDES.html" title="Macro BOOST_CONTRACT_OVERRIDES">BOOST_CONTRACT_OVERRIDES</a></code>
        can be used with multiple functions names instead of repeating <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OVERRIDE.html" title="Macro BOOST_CONTRACT_OVERRIDE">BOOST_CONTRACT_OVERRIDE</a></code> for each
        function name (on compilers that support variadic macros):
      </p>
<pre class="programlisting"><span class="identifier">BOOST_CONTRACT_OVERRIDES</span><span class="special">(</span><code class="literal"><span class="emphasis"><em>function-name1</em></span></code><span class="special">,</span> <code class="literal"><span class="emphasis"><em>function-name2</em></span></code><span class="special">,</span> <span class="special">...)</span>
</pre>
<p>
        Which is equivalent to:
      </p>
<pre class="programlisting"><span class="identifier">BOOST_CONTRACT_OVERRIDE</span><span class="special">(</span><code class="literal"><span class="emphasis"><em>function-name1</em></span></code><span class="special">)</span>
<span class="identifier">BOOST_CONTRACT_OVERRIDE</span><span class="special">(</span><code class="literal"><span class="emphasis"><em>function-name2</em></span></code><span class="special">)</span>
<span class="special">...</span>
</pre>
<p>
        Overriding public functions must always list the extra trailing parameter
        of type <code class="computeroutput"><a class="link" href="../boost/contract/virtual_.html" title="Class virtual_">boost::contract::virtual_</a></code><code class="computeroutput"><span class="special">*</span></code> with <code class="computeroutput"><span class="number">0</span></code>
        default value (i.e., <code class="computeroutput"><span class="keyword">nullptr</span></code>),
        even when they are not declared <code class="computeroutput"><span class="keyword">virtual</span></code>
        (because this parameter is present in the signature of the virtual function
        being overridden from base classes). Programmers must pass the extra virtual
        parameter as the very first argument to all <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OLDOF.html" title="Macro BOOST_CONTRACT_OLDOF">BOOST_CONTRACT_OLDOF</a></code>
        and <code class="computeroutput"><a class="link" href="../boost/contract/public_function_id480248.html" title="Function template public_function">boost::contract::public_function</a></code>
        calls in the overriding function.
      </p>
<p>
        When called from overriding public functions, <code class="computeroutput"><a class="link" href="../boost/contract/public_function_id480248.html" title="Function template public_function">boost::contract::public_function</a></code>
        also takes a pointer to the enclosing function, the object <code class="computeroutput"><span class="keyword">this</span></code> (because overriding public functions
        check class invariants), and references to each function argument in the
        order they appear in the function declaration. <a href="#ftn.boost_contract.tutorial.public_function_overrides__subcontracting_.f2" class="footnote" name="boost_contract.tutorial.public_function_overrides__subcontracting_.f2"><sup class="footnote">[29]</sup></a> As shown in the example above, when the overriding public function
        has a non-void return type, programmers must pass a reference to the function
        return value as the second argument to <code class="computeroutput"><a class="link" href="../boost/contract/public_function_id480248.html" title="Function template public_function">boost::contract::public_function</a></code>
        (this library will generate a compile-time error otherwise). <a href="#ftn.boost_contract.tutorial.public_function_overrides__subcontracting_.f3" class="footnote" name="boost_contract.tutorial.public_function_overrides__subcontracting_.f3"><sup class="footnote">[30]</sup></a> In this case the functor specified to <code class="computeroutput"><span class="special">.</span><span class="identifier">postcondition</span><span class="special">(...)</span></code>
        takes a single parameter for the return value (possibly as a constant reference
        <code class="computeroutput"><span class="keyword">const</span><span class="special">&amp;</span></code>
        to avoid extra copies of the return value).
      </p>
<div class="important"><table border="0" summary="Important">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="../../../doc/src/images/important.png"></td>
<th align="left">Important</th>
</tr>
<tr><td align="left" valign="top">
<p>
          It is the responsibility of the programmers to pass the extra parameter
          <code class="computeroutput"><span class="identifier">v</span></code> to all <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OLDOF.html" title="Macro BOOST_CONTRACT_OLDOF">BOOST_CONTRACT_OLDOF</a></code>
          and <code class="computeroutput"><a class="link" href="../boost/contract/public_function_id480248.html" title="Function template public_function">boost::contract::public_function</a></code>
          calls within overriding public functions, and also to pass the return value
          reference after <code class="computeroutput"><span class="identifier">v</span></code> to <code class="computeroutput"><a class="link" href="../boost/contract/public_function_id480248.html" title="Function template public_function">boost::contract::public_function</a></code>
          for non-void overriding public functions. This library cannot always generate
          compile-time errors if programmers fail to do so (but in general contract
          checking will not correctly work at run-time).
        </p>
<p>
          <span class="emphasis"><em>Remember: always pass "v" as the first argument to
          old-of macros, the contract, etc. for overriding public functions; always
          pass the result variable after "<code class="computeroutput"><span class="identifier">v</span></code>"
          to the contract for non-void overriding public functions.</em></span>
        </p>
</td></tr>
</table></div>
<p>
        The <code class="computeroutput"><a class="link" href="../boost/contract/public_function_id480248.html" title="Function template public_function">boost::contract::public_function</a></code>
        function returns an RAII object that must always be assigned to a local variable
        of type <code class="computeroutput"><a class="link" href="../boost/contract/guard.html" title="Class guard">boost::contract::guard</a></code>
        otherwise this library will generate a run-time error (note that C++11 <code class="computeroutput"><span class="keyword">auto</span></code> declarations cannot be used here and
        the <code class="computeroutput">boost::const::guard</code>
        type must be explicitly specified). The public member function body is programmed
        right after the declaration of this RAII object. At construction, this RAII
        object doe the following:
      </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
            Check static and non-static class invariants for all overridden bases
            and for the derived class, by calling <code class="literal"><span class="emphasis"><em>typeof</em></span>(<span class="emphasis"><em>overridden-base</em></span>)</code><code class="computeroutput"><span class="special">::</span><span class="identifier">static_invariant</span><span class="special">()</span></code> <a class="link" href="contract_programming_overview.html#and_anchor"><code class="literal"><span class="emphasis"><em>AND</em></span></code></a>
            <code class="literal"><span class="emphasis"><em>overridden-base</em></span></code><code class="computeroutput"><span class="special">.</span><span class="identifier">invariant</span><span class="special">()</span></code> <a class="link" href="contract_programming_overview.html#and_anchor"><code class="literal"><span class="emphasis"><em>AND</em></span></code></a>...
            <code class="literal"><span class="emphasis"><em>typeof</em></span></code><code class="computeroutput"><span class="special">(*</span><span class="keyword">this</span><span class="special">)::</span><span class="identifier">static_invariant</span><span class="special">()</span></code>
            <a class="link" href="contract_programming_overview.html#and_anchor"><code class="literal"><span class="emphasis"><em>AND</em></span></code></a>
            <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">invariant</span><span class="special">()</span></code>.
          </li>
<li class="listitem">
            Check preconditions for all overridden base functions and for the overriding
            derived function in <a class="link" href="contract_programming_overview.html#or_anchor"><code class="literal"><span class="emphasis"><em>OR</em></span></code></a>
            with each other, by calling the nullary functors <code class="literal"><span class="emphasis"><em>f1</em></span></code><code class="computeroutput"><span class="special">()</span></code> <a class="link" href="contract_programming_overview.html#or_anchor"><code class="literal"><span class="emphasis"><em>OR</em></span></code></a>...
            <code class="literal"><span class="emphasis"><em>fn</em></span></code><code class="computeroutput"><span class="special">()</span></code>
            passed to <code class="computeroutput"><span class="special">.</span><span class="identifier">precondition</span><span class="special">(</span></code><code class="literal"><span class="emphasis"><em>f1</em></span></code><code class="computeroutput"><span class="special">)</span></code>, ..., <code class="computeroutput"><span class="special">.</span><span class="identifier">precondition</span><span class="special">(</span></code><code class="literal"><span class="emphasis"><em>fn</em></span></code><code class="computeroutput"><span class="special">)</span></code> for all of the overridden and overriding
            functions respectively.
          </li>
</ol></div>
<p>
        At destruction instead:
      </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
            Check static and non-static class invariants for all overridden bases
            and for the derived class, by calling <code class="literal"><span class="emphasis"><em>typeof</em></span>(<span class="emphasis"><em>overridden-base</em></span>)</code><code class="computeroutput"><span class="special">::</span><span class="identifier">static_invariant</span><span class="special">()</span></code> <a class="link" href="contract_programming_overview.html#and_anchor"><code class="literal"><span class="emphasis"><em>AND</em></span></code></a>
            <code class="literal"><span class="emphasis"><em>overridden-base</em></span></code><code class="computeroutput"><span class="special">.</span><span class="identifier">invariant</span><span class="special">()</span></code> <a class="link" href="contract_programming_overview.html#and_anchor"><code class="literal"><span class="emphasis"><em>AND</em></span></code></a>...
            <code class="literal"><span class="emphasis"><em>typeof</em></span></code><code class="computeroutput"><span class="special">(*</span><span class="keyword">this</span><span class="special">)::</span><span class="identifier">static_invariant</span><span class="special">()</span></code>
            <a class="link" href="contract_programming_overview.html#and_anchor"><code class="literal"><span class="emphasis"><em>AND</em></span></code></a>
            <code class="computeroutput"><span class="keyword">this</span><span class="special">-&gt;</span><span class="identifier">invariant</span><span class="special">()</span></code>
            (even if the function body threw an exception).
          </li>
<li class="listitem">
            If the function body did not throw an exception:
            <div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
                  Check postconditions for all overridden base functions and for
                  the overriding derived function in <a class="link" href="contract_programming_overview.html#and_anchor"><code class="literal"><span class="emphasis"><em>AND</em></span></code></a>
                  with each other, by calling the functors <code class="literal"><span class="emphasis"><em>g1</em></span></code><code class="computeroutput"><span class="special">()</span></code> <a class="link" href="contract_programming_overview.html#and_anchor"><code class="literal"><span class="emphasis"><em>AND</em></span></code></a>...
                  <code class="literal"><span class="emphasis"><em>gn</em></span></code><code class="computeroutput"><span class="special">()</span></code>
                  passed to <code class="computeroutput"><span class="special">.</span><span class="identifier">postcondition</span><span class="special">(</span></code><code class="literal"><span class="emphasis"><em>g1</em></span></code><code class="computeroutput"><span class="special">)</span></code>, ..., <code class="computeroutput"><span class="special">.</span><span class="identifier">postcondition</span><span class="special">(</span></code><code class="literal"><span class="emphasis"><em>gn</em></span></code><code class="computeroutput"><span class="special">)</span></code> for all of the overridden and
                  overriding functions respectively (or <code class="literal"><span class="emphasis"><em>g1</em></span></code><code class="computeroutput"><span class="special">(</span></code><code class="literal"><span class="emphasis"><em>result</em></span></code><code class="computeroutput"><span class="special">)</span></code> <a class="link" href="contract_programming_overview.html#and_anchor"><code class="literal"><span class="emphasis"><em>AND</em></span></code></a>...
                  <code class="literal"><span class="emphasis"><em>gn</em></span></code><code class="computeroutput"><span class="special">(</span></code><code class="literal"><span class="emphasis"><em>result</em></span></code><code class="computeroutput"><span class="special">)</span></code> for non-void public function overrides).
                </li></ol></div>
          </li>
</ol></div>
<p>
        This ensures that overriding public function subcontracts are checked correctly
        at run-time (see also <a class="link" href="contract_programming_overview.html#boost_contract.contract_programming_overview.public_function_calls" title="Public Function Calls">Public
        Function Calls</a>).
      </p>
<p>
        For the rest, the same considerations made in __Public_Virtual_Functions__
        apply.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_contract.tutorial.base_classes__subcontracting_"></a><a class="link" href="tutorial.html#boost_contract.tutorial.base_classes__subcontracting_" title="Base Classes (Subcontracting)">Base
      Classes (Subcontracting)</a>
</h3></div></div></div>
<p>
        In order for this library to support subcontracting, programmers must specify
        the bases of a class declaring a public member type named <code class="computeroutput"><span class="identifier">base_types</span></code>
        via a <code class="computeroutput"><span class="keyword">typedef</span></code> using <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_BASE_TYPES.html" title="Macro BOOST_CONTRACT_BASE_TYPES">BOOST_CONTRACT_BASE_TYPES</a></code>. For
        example (see also <a href="../../../example/features/base_types.cpp" target="_top"><code class="literal">base_types.cpp</code></a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">chars</span>
    <span class="preprocessor">#define</span> <span class="identifier">BASES</span> <span class="comment">/* local macro (for convenience) */</span> <span class="special">\</span>
        <span class="keyword">private</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">constructor_precondition</span><span class="special">&lt;</span><span class="identifier">chars</span><span class="special">&gt;,</span> <span class="special">\</span>
        <span class="keyword">public</span> <span class="identifier">unique_chars</span><span class="special">,</span> <span class="special">\</span>
        <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="identifier">pushable</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;,</span> <span class="special">\</span>
        <span class="keyword">virtual</span> <span class="keyword">protected</span> <span class="identifier">has_size</span><span class="special">,</span> <span class="special">\</span>
        <span class="keyword">private</span> <span class="identifier">has_empty</span>
    <span class="special">:</span> <span class="identifier">BASES</span> <span class="comment">// Bases of this class.</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">BOOST_CONTRACT_BASE_TYPES</span><span class="special">(</span><span class="identifier">BASES</span><span class="special">)</span> <span class="identifier">base_types</span><span class="special">;</span> <span class="comment">// Bases typedef.</span>
    <span class="preprocessor">#undef</span> <span class="identifier">BASES</span> <span class="comment">// Undefine local macro.</span>

    <span class="comment">/* ... */</span>
</pre>
<p>
      </p>
<p>
        For convenience, a <span class="emphasis"><em>local macro</em></span> named <code class="computeroutput"><span class="identifier">BASES</span></code>
        can be used to avoid repeating the base list twice (first when inheriting
        <code class="literal">: <span class="emphasis"><em>base-list</em></span></code> and then when invoking
        <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_BASE_TYPES.html" title="Macro BOOST_CONTRACT_BASE_TYPES">BOOST_CONTRACT_BASE_TYPES</a></code><code class="literal">(<span class="emphasis"><em>base-list</em></span>)</code>).
        Being a local macro, <code class="computeroutput"><span class="identifier">BASES</span></code>
        must be undefined using <code class="computeroutput"><span class="preprocessor">#undef</span>
        <span class="identifier">BASES</span></code> after it has been used to
        declare <code class="computeroutput"><span class="identifier">base_types</span></code> (to avoid
        macro redefinition errors). <a href="#ftn.boost_contract.tutorial.base_classes__subcontracting_.f0" class="footnote" name="boost_contract.tutorial.base_classes__subcontracting_.f0"><sup class="footnote">[31]</sup></a>
      </p>
<p>
        <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_BASE_TYPES.html" title="Macro BOOST_CONTRACT_BASE_TYPES">BOOST_CONTRACT_BASE_TYPES</a></code>
        is a variadic macro and accepts a list of bases separated by commas (see
        <a class="link" href="advanced_topics.html#boost_contract.advanced_topics.no_macros__no_c__11_" title="No Macros (No C++11)">No Macros</a>
        to program <code class="computeroutput"><span class="identifier">base_types</span></code> without
        using macros). When the extra base <code class="computeroutput"><a class="link" href="../boost/contract/constructor_precondition.html" title="Class template constructor_precondition">boost::contract::constructor_precondition</a></code>
        is used to program constructor preconditions, it must always be private and
        appear as the very first base (see also <a class="link" href="tutorial.html#boost_contract.tutorial.constructors" title="Constructors">Constructors</a>).
      </p>
<div class="important"><table border="0" summary="Important">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="../../../doc/src/images/important.png"></td>
<th align="left">Important</th>
</tr>
<tr><td align="left" valign="top">
<p>
          Each base passed to <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_BASE_TYPES.html" title="Macro BOOST_CONTRACT_BASE_TYPES">BOOST_CONTRACT_BASE_TYPES</a></code>
          must <span class="emphasis"><em>explicitly</em></span> specify its inheritance access level
          <code class="computeroutput"><span class="keyword">public</span></code>, <code class="computeroutput"><span class="keyword">protected</span></code>,
          or <code class="computeroutput"><span class="keyword">private</span></code> (<code class="computeroutput"><span class="keyword">virtual</span></code> is optional and can be specified
          either before or after the access level as usual in C++). <a href="#ftn.boost_contract.tutorial.base_classes__subcontracting_.f1" class="footnote" name="boost_contract.tutorial.base_classes__subcontracting_.f1"><sup class="footnote">[32]</sup></a> This library will generate a compiler-error if the first base
          is missing its inheritance access level, but this library will not be able
          to error if the access level is missing from bases after the first one.
        </p>
<p>
          It is the responsibility of the programmers to make sure that all bases
          passed to <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_BASE_TYPES.html" title="Macro BOOST_CONTRACT_BASE_TYPES">BOOST_CONTRACT_BASE_TYPES</a></code>
          explicitly specify their inheritance access level (inheritance access levels
          are instead optional in C++ because <code class="computeroutput"><span class="keyword">private</span></code>
          is implicitly assumed for <code class="computeroutput"><span class="keyword">class</span></code>
          types and <code class="computeroutput"><span class="keyword">public</span></code> for <code class="computeroutput"><span class="keyword">struct</span></code> types).
        </p>
</td></tr>
</table></div>
<p>
        See __Access__ to avoid making <code class="computeroutput"><span class="identifier">base_types</span></code>
        member type <code class="computeroutput"><span class="keyword">public</span></code> (e.g., in
        cases when all public members of a class including <code class="computeroutput"><span class="keyword">typedef</span></code>s
        must be controlled exactly). Set the <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_BASE_TYPEDEF.html" title="Macro BOOST_CONTRACT_BASE_TYPEDEF">BOOST_CONTRACT_BASE_TYPEDEF</a></code>
        configuration macro to use a name different from <code class="computeroutput"><span class="identifier">base_types</span></code>
        (e.g., because <code class="computeroutput"><span class="identifier">base_types</span></code>
        clashes with other names in the user-defined class).
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_contract.tutorial.static_public_functions"></a><a class="link" href="tutorial.html#boost_contract.tutorial.static_public_functions" title="Static Public Functions">Static
      Public Functions</a>
</h3></div></div></div>
<p>
        Let's consider static public member functions. For example, the following
        such a function <code class="computeroutput"><span class="identifier">instances</span></code>
        is declared as a member of the <code class="computeroutput"><span class="identifier">make</span></code>
        class template (see also <a href="../../../example/features/static_public.cpp" target="_top"><code class="literal">static_public.cpp</code></a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">class</span> <span class="identifier">C</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">make</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">static</span> <span class="keyword">void</span> <span class="identifier">static_invariant</span><span class="special">()</span> <span class="special">{</span> <span class="comment">// Static class invariants.</span>
        <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">instances</span><span class="special">()</span> <span class="special">&gt;=</span> <span class="number">0</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="keyword">static</span> <span class="keyword">int</span> <span class="identifier">instances</span><span class="special">()</span> <span class="special">{</span>
        <span class="comment">// Explicit template parameter `make` (to check static invariants).</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">&lt;</span><span class="identifier">make</span><span class="special">&gt;();</span>

        <span class="keyword">return</span> <span class="identifier">instances_</span><span class="special">;</span> <span class="comment">// Function body.</span>
    <span class="special">}</span>

    <span class="comment">/* ... */</span>
</pre>
<p>
      </p>
<p>
        When called from static public functions, <code class="computeroutput"><a class="link" href="../boost/contract/public_function_id480248.html" title="Function template public_function">boost::contract::public_function</a></code>
        cannot take the object <code class="computeroutput"><span class="keyword">this</span></code>
        as a parameter (because there is no object <code class="computeroutput"><span class="keyword">this</span></code>
        in static member functions) so the enclosing class type (necessary to check
        static class invariants, see also <a class="link" href="tutorial.html#boost_contract.tutorial.class_invariants.static_class_invariants">Static
        Class Invariants</a>) is specified as an explicit template parameter.
        Even if they are not present in the example above, it is possible to specify
        preconditions and postconditions for static public member functions using
        <code class="computeroutput"><span class="special">.</span><span class="identifier">precondition</span><span class="special">(...)</span></code> and <code class="computeroutput"><span class="special">.</span><span class="identifier">postcondition</span><span class="special">(...)</span></code>
        as usual (see also <a class="link" href="tutorial.html#boost_contract.tutorial.preconditions" title="Preconditions">Preconditions</a>
        and <a class="link" href="tutorial.html#boost_contract.tutorial.postconditions" title="Postconditions">Postconditions</a>).
      </p>
<p>
        The <code class="computeroutput"><a class="link" href="../boost/contract/public_function_id480248.html" title="Function template public_function">boost::contract::public_function</a></code>
        function returns an RAII object that must be assigned to a local variable
        of type <code class="computeroutput"><a class="link" href="../boost/contract/guard.html" title="Class guard">boost::contract::guard</a></code>
        otherwise this library will generate a run-time error (note that C++11 <code class="computeroutput"><span class="keyword">auto</span></code> declarations cannot be used here and
        the <code class="computeroutput"><a class="link" href="../boost/contract/guard.html" title="Class guard">boost::contract::guard</a></code>
        type must be explicitly specified). The static public member functions body
        is programmed right after the declaration of this RAII object. At construction,
        this RAII object does the following:
      </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
            Check static class invariants, by calling <code class="literal"><span class="emphasis"><em>class-type</em></span></code><code class="computeroutput"><span class="special">::</span><span class="identifier">static_invariant</span><span class="special">()</span></code> (but never non-static class invariants).
          </li>
<li class="listitem">
            Check preconditions, by calling the nullary functor <code class="literal"><span class="emphasis"><em>f</em></span></code><code class="computeroutput"><span class="special">()</span></code> passed to <code class="computeroutput"><span class="special">.</span><span class="identifier">precondition</span><span class="special">(</span></code><code class="literal"><span class="emphasis"><em>f</em></span></code><code class="computeroutput"><span class="special">)</span></code>.
          </li>
</ol></div>
<p>
        At destruction instead:
      </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
            Check static class invariants, by calling <code class="literal"><span class="emphasis"><em>class-type</em></span></code><code class="computeroutput"><span class="special">::</span><span class="identifier">static_invariant</span><span class="special">()</span></code> (even if the function body threw and
            exception, but never non-static class invariants).
          </li>
<li class="listitem">
            If the function body did not throw an exception:
            <div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
                  Check postconditions, by calling the nullary functor <code class="literal"><span class="emphasis"><em>g</em></span></code><code class="computeroutput"><span class="special">()</span></code> passed to <code class="computeroutput"><span class="special">.</span><span class="identifier">postcondition</span><span class="special">(</span></code><code class="literal"><span class="emphasis"><em>g</em></span></code><code class="computeroutput"><span class="special">)</span></code>.
                </li></ol></div>
          </li>
</ol></div>
<p>
        This ensures that static public member function contracts are correctly checked
        at run-time (note that static public member functions do not subcontract,
        see also <a class="link" href="contract_programming_overview.html#boost_contract.contract_programming_overview.public_function_calls" title="Public Function Calls">Public
        Function Calls</a>).
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          A static public member function can avoid calling <code class="computeroutput"><a class="link" href="../boost/contract/public_function_id480248.html" title="Function template public_function">boost::contract::public_function</a></code>
          for efficiency but only when it has no preconditions, no postconditions,
          and its class has no static invariants (the class can still have non-static
          invariants or base classes instead).
        </p></td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_contract.tutorial.private_and_protected_functions"></a><a class="link" href="tutorial.html#boost_contract.tutorial.private_and_protected_functions" title="Private and Protected Functions">Private
      and Protected Functions</a>
</h3></div></div></div>
<p>
        Private and protected member functions do not check class invariants (because
        they are not part of the public class interface) and they do not subcontract
        (because they are not accessible at the calling site where the <a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle" target="_top">substitution
        principle</a> applies, see also <a class="link" href="contract_programming_overview.html#boost_contract.contract_programming_overview.function_calls" title="Function Calls">Function
        Calls</a>). However, programmers can still choose to specify preconditions
        and postconditions for private and protected member functions if they want
        to check correctness of implementations and usage of base member functions
        in derived classes. Therefore, when programmers decide to specify contracts
        for private and protected member functions, they can use <code class="computeroutput"><a class="link" href="../boost/contract/function.html" title="Function function">boost::contract::function</a></code>
        (like for non-member functions). For example (see also <a href="../../../example/features/private_protected.cpp" target="_top"><code class="literal">private_protected.cpp</code></a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">counter</span> <span class="special">{</span>
<span class="keyword">protected</span><span class="special">:</span>
    <span class="keyword">int</span> <span class="identifier">get</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span> <span class="comment">// Protected function (like non-member functions).</span>
        <span class="keyword">int</span> <span class="identifier">result</span><span class="special">;</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">function</span><span class="special">()</span>
            <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">result</span> <span class="special">==</span> <span class="identifier">n_</span><span class="special">);</span>
            <span class="special">})</span>
        <span class="special">;</span>

        <span class="keyword">return</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">n_</span><span class="special">;</span> <span class="comment">// Function body.</span>
    <span class="special">}</span>

<span class="keyword">private</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">dec</span><span class="special">()</span> <span class="special">{</span> <span class="comment">// Private function (like non-member functions).</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">old_ptr</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">old_n</span> <span class="special">=</span> <span class="identifier">BOOST_CONTRACT_OLDOF</span><span class="special">(</span><span class="identifier">n_</span><span class="special">);</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">function</span><span class="special">()</span>
            <span class="special">.</span><span class="identifier">precondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">n_</span> <span class="special">&gt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">numeric_limits</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;::</span><span class="identifier">min</span><span class="special">());</span>
            <span class="special">})</span>
            <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">n_</span> <span class="special">==</span> <span class="special">*</span><span class="identifier">old_n</span> <span class="special">-</span> <span class="number">1</span><span class="special">);</span>
            <span class="special">})</span>
        <span class="special">;</span>

        <span class="special">--</span><span class="identifier">n_</span><span class="special">;</span> <span class="comment">// Function body.</span>
    <span class="special">}</span>

    <span class="keyword">int</span> <span class="identifier">n_</span><span class="special">;</span>

    <span class="comment">/* ... */</span>
</pre>
<p>
      </p>
<p>
        The same considerations made in <a class="link" href="tutorial.html#boost_contract.tutorial.non_member_functions" title="Non-Member Functions">Non-Member
        Functions</a> apply.
      </p>
<p>
        See <a class="link" href="tutorial.html#boost_contract.tutorial.constructors" title="Constructors">Constructors</a>
        and <a class="link" href="tutorial.html#boost_contract.tutorial.destructors" title="Destructors">Destructors</a>
        for notes on how to program contracts for private and protected constructors
        and destructors respectively.
      </p>
</div>
<div class="footnotes">
<br><hr style="width:100; text-align:left;margin-left: 0">
<div id="ftn.boost_contract.tutorial.non_member_functions.f0" class="footnote"><p><a href="#boost_contract.tutorial.non_member_functions.f0" class="para"><sup class="para">[12] </sup></a>
          The name of this local variable is arbitrary, but <code class="computeroutput"><span class="identifier">c</span></code>
          is often used in this documentation.
        </p></div>
<div id="ftn.boost_contract.tutorial.preconditions.f0" class="footnote"><p><a href="#boost_contract.tutorial.preconditions.f0" class="para"><sup class="para">[13] </sup></a>
          Lambda functions with no parameters can be programmed in C++11 as <code class="computeroutput"><span class="special">[...]</span> <span class="special">()</span> <span class="special">{</span> <span class="special">...</span> <span class="special">}</span></code>
          but also equivalently as <code class="computeroutput"><span class="special">[...]</span> <span class="special">{</span> <span class="special">...</span> <span class="special">}</span></code>.
          This second from is often used in this documentation omitting the empty
          parameter list <code class="computeroutput"><span class="special">()</span></code> for brevity.
        </p></div>
<div id="ftn.boost_contract.tutorial.return_value.f0" class="footnote"><p><a href="#boost_contract.tutorial.return_value.f0" class="para"><sup class="para">[14] </sup></a>
          The name of the local variable that holds the return value is arbitrary,
          but <code class="computeroutput"><span class="identifier">result</span></code> is often used
          in this documentation.
        </p></div>
<div id="ftn.boost_contract.tutorial.old_values.f0" class="footnote"><p><a href="#boost_contract.tutorial.old_values.f0" class="para"><sup class="para">[15] </sup></a>
          The name of the local variable that holds an old value is arbitrary, but
          <code class="literal">old_<span class="emphasis"><em>name</em></span></code> is often used in this
          documentation.
        </p></div>
<div id="ftn.boost_contract.tutorial.class_invariants.f0" class="footnote"><p><a href="#boost_contract.tutorial.class_invariants.f0" class="para"><sup class="para">[16] </sup></a>
          This library uses template meta-programming (SFINAE-based introspection
          techniques) to check invariants only for classes that declare a member
          function named <code class="computeroutput"><span class="identifier">invariant</span></code>.
        </p></div>
<div id="ftn.boost_contract.tutorial.class_invariants.f1" class="footnote"><p><a href="#boost_contract.tutorial.class_invariants.f1" class="para"><sup class="para">[17] </sup></a>
          In this documentation the <code class="computeroutput"><span class="identifier">invariant</span></code>
          member function is often declared <code class="computeroutput"><span class="keyword">public</span></code>
          for simplicity. However, in most production code it might not be acceptable
          to augment the public members of a class adding <code class="computeroutput"><span class="identifier">invariant</span></code>
          and <code class="computeroutput"><a class="link" href="../boost/contract/access.html" title="Class access">boost::contract::access</a></code>
          can be used to avoid that as explained in __Access__.
        </p></div>
<div id="ftn.boost_contract.tutorial.class_invariants.f2" class="footnote"><p><a href="#boost_contract.tutorial.class_invariants.f2" class="para"><sup class="para">[18] </sup></a>
          This library uses template meta-programming (SFINAE-based introspection
          techniques) to check static invariants only for classes that declare a
          member function named <code class="computeroutput"><span class="identifier">static_invariant</span></code>.
        </p></div>
<div id="ftn.boost_contract.tutorial.class_invariants.f3" class="footnote"><p><a href="#boost_contract.tutorial.class_invariants.f3" class="para"><sup class="para">[19] </sup></a>
          In this documentation the <code class="computeroutput"><span class="identifier">static_invariant</span></code>
          member function is often declared <code class="computeroutput"><span class="keyword">public</span></code>
          for simplicity. However, in most production code it might not be acceptable
          to augment the public members of a class adding <code class="computeroutput"><span class="identifier">static_invariant</span></code>
          and <code class="computeroutput"><a class="link" href="../boost/contract/access.html" title="Class access">boost::contract::access</a></code>
          can be used to avoid that as explained in __Access__.
        </p></div>
<div id="ftn.boost_contract.tutorial.class_invariants.f4" class="footnote"><p><a href="#boost_contract.tutorial.class_invariants.f4" class="para"><sup class="para">[20] </sup></a>
          <span class="bold"><strong>Rationale:</strong></span> In C++, it is not possible
          to overload a member function based on the <code class="computeroutput"><span class="keyword">static</span></code>
          classifier. Therefore, different function names have to be used for member
          functions checking static and non-static class invariants, namely <code class="computeroutput"><span class="identifier">invariant</span></code> and <code class="computeroutput"><span class="identifier">static_invariant</span></code>.
        </p></div>
<div id="ftn.boost_contract.tutorial.constructors.f0" class="footnote"><p><a href="#boost_contract.tutorial.constructors.f0" class="para"><sup class="para">[21] </sup></a>
          There is a MSVC bug that was fixed in MSVC 2013 for which lambdas cannot
          be used in constructor member initialization lists for templates. On MSVC
          compilers with that bug, an external (static member) function can be used
          (together with <code class="computeroutput"><span class="identifier">bind</span></code> and
          <code class="computeroutput"><span class="identifier">cref</span></code> as needed) to program
          constructor preconditions instead of using lambdas.
        </p></div>
<div id="ftn.boost_contract.tutorial.constructors.f1" class="footnote"><p><a href="#boost_contract.tutorial.constructors.f1" class="para"><sup class="para">[22] </sup></a>
              <span class="bold"><strong>Rationale:</strong></span> The <code class="computeroutput"><a class="link" href="../boost/contract/constructor_precondition.html" title="Class template constructor_precondition">boost::contract::constructor_precondition</a></code>
              takes the derived class as its template parameter so the instantiated
              template type is unique for each derived class always avoiding base
              class ambiguities even in case of multiple inheritance. Virtual inheritance
              cannot be used resolve such ambiguities because virtual bases are initialized
              only once by the out-most derived class, and that would not allow to
              properly check preconditions of all base classes.
            </p></div>
<div id="ftn.boost_contract.tutorial.virtual_public_functions.f0" class="footnote"><p><a href="#boost_contract.tutorial.virtual_public_functions.f0" class="para"><sup class="para">[23] </sup></a>
          The name of this extra parameter is arbitrary, but <code class="computeroutput"><span class="identifier">v</span></code>
          is often used in this documentation.
        </p></div>
<div id="ftn.boost_contract.tutorial.virtual_public_functions.f1" class="footnote"><p><a href="#boost_contract.tutorial.virtual_public_functions.f1" class="para"><sup class="para">[24] </sup></a>
          <span class="bold"><strong>Rationale:</strong></span> The <code class="computeroutput"><a class="link" href="../boost/contract/virtual_.html" title="Class virtual_">boost::contract::virtual_</a></code><code class="computeroutput"><span class="special">*</span></code> optional parameter is used by this library
          to determine that a function is virtual (in C++ it is not possible to introspect
          if a function has been declared <code class="computeroutput"><span class="keyword">virtual</span></code>).
          Furthermore, this parameter is internally used by this library to pass
          result and old values that are evaluated by the overriding function to
          overridden virtual functions, and also to check preconditions and postconditions
          of overridden virtual functions when subcontracting (but without executing
          overridden function bodies).
        </p></div>
<div id="ftn.boost_contract.tutorial.virtual_public_functions.f2" class="footnote"><p><a href="#boost_contract.tutorial.virtual_public_functions.f2" class="para"><sup class="para">[25] </sup></a>
          <span class="bold"><strong>Rationale:</strong></span> The functor passed to <code class="computeroutput"><span class="special">.</span><span class="identifier">postcondition</span><span class="special">(...)</span></code> takes the extra return value parameter
          because that is used by this library to pass the return value evaluated
          by the overriding function to all its overridden virtual functions when
          subcontracting.
        </p></div>
<div id="ftn.boost_contract.tutorial.virtual_public_functions.f3" class="footnote"><p><a href="#boost_contract.tutorial.virtual_public_functions.f3" class="para"><sup class="para">[26] </sup></a>
            <span class="bold"><strong>Rationale:</strong></span> This library does not require
            the function type when using <code class="computeroutput"><a class="link" href="../boost/contract/public_function_id480248.html" title="Function template public_function">boost::contract::public_function</a></code>
            for non-overriding virtual functions. Therefore, this library does not
            know if the enclosing function has a non-void return type so it cannot
            check if the return value reference is passed as required for non-overriding
            virtual functions. Instead this library requires the function type for
            overriding virtual functions thus it gives a compile-time error if the
            return value reference is missing in those cases.
          </p></div>
<div id="ftn.boost_contract.tutorial.public_function_overrides__subcontracting_.f0" class="footnote"><p><a href="#boost_contract.tutorial.public_function_overrides__subcontracting_.f0" class="para"><sup class="para">[27] </sup></a>
          In this document, overriding functions are often marked with the comment
          <code class="computeroutput"><span class="comment">/* override */</span></code>. On compilers
          that support C++11 virtual specifiers, the <code class="computeroutput"><span class="identifier">override</span></code>
          identifier can be used instead (<code class="computeroutput"><span class="identifier">override</span></code>
          is not used in the documentation only because virtual specifiers are not
          widely supported yet, even by compilers that support C++11 lambda functions,
          etc.).
        </p></div>
<div id="ftn.boost_contract.tutorial.public_function_overrides__subcontracting_.f1" class="footnote"><p><a href="#boost_contract.tutorial.public_function_overrides__subcontracting_.f1" class="para"><sup class="para">[28] </sup></a>
          This error is similar in principle to the error generated by C++11 <code class="computeroutput"><span class="identifier">override</span></code> specifier, but it is limited
          to functions with the extra <code class="computeroutput"><a class="link" href="../boost/contract/virtual_.html" title="Class virtual_">boost::contract::virtual_</a></code><code class="computeroutput"><span class="special">*</span></code> parameter and searched recursively only
          in <code class="computeroutput"><span class="keyword">public</span></code> base classes passed
          to <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_BASE_TYPES.html" title="Macro BOOST_CONTRACT_BASE_TYPES">BOOST_CONTRACT_BASE_TYPES</a></code>
          because only those are valid functions to override for subcontracting.
        </p></div>
<div id="ftn.boost_contract.tutorial.public_function_overrides__subcontracting_.f2" class="footnote"><p><a href="#boost_contract.tutorial.public_function_overrides__subcontracting_.f2" class="para"><sup class="para">[29] </sup></a>
          <span class="bold"><strong>Rationale:</strong></span> The object <code class="computeroutput"><span class="keyword">this</span></code>
          is passed after the function pointer to follow <code class="computeroutput"><span class="identifier">bind</span></code>'s
          syntax. The function pointer and references to all function arguments are
          needed for overriding virtual public functions because this library has
          to call overridden virtual public functions to check their contracts for
          subcontracting (even if this library will not actually execute the bodies
          of the overridden functions).
        </p></div>
<div id="ftn.boost_contract.tutorial.public_function_overrides__subcontracting_.f3" class="footnote"><p><a href="#boost_contract.tutorial.public_function_overrides__subcontracting_.f3" class="para"><sup class="para">[30] </sup></a>
          <span class="bold"><strong>Rationale:</strong></span> As for non-overriding public
          virtual functions, also overriding functions use the extra return value
          parameter to pass it to the overridden functions when subcontracting. In
          the case of overriding functions this library also has the function pointer
          so it will generate a compile-time error if the function is non-void and
          programmers forget to specify the extra return value parameter (this extra
          error checking is not possible instead for non-overriding public virtual
          functions because their contracts do not have to specify the function pointer,
          see also <a class="link" href="tutorial.html#boost_contract.tutorial.virtual_public_functions" title="Virtual Public Functions">Virtual
          Public Functions</a>).
        </p></div>
<div id="ftn.boost_contract.tutorial.base_classes__subcontracting_.f0" class="footnote"><p><a href="#boost_contract.tutorial.base_classes__subcontracting_.f0" class="para"><sup class="para">[31] </sup></a>
          In this documentation, the local macro to declare base classes is often
          named <code class="computeroutput"><span class="identifier">BASES</span></code> but any other
          name can be used.
        </p></div>
<div id="ftn.boost_contract.tutorial.base_classes__subcontracting_.f1" class="footnote"><p><a href="#boost_contract.tutorial.base_classes__subcontracting_.f1" class="para"><sup class="para">[32] </sup></a>
            <span class="bold"><strong>Rationale:</strong></span> This library explicitly requires
            the inheritance access level because derived classes must subcontract
            only from public bases, but not from protected or private bases (see
            <a class="link" href="contract_programming_overview.html#boost_contract.contract_programming_overview.public_function_calls" title="Public Function Calls">Public
            Function Calls</a>). Therefore, <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_BASE_TYPES.html" title="Macro BOOST_CONTRACT_BASE_TYPES">BOOST_CONTRACT_BASE_TYPES</a></code>
            inspect each inheritance access level (using preprocessor meta-programming)
            and removes non-public bases from the list bases <code class="computeroutput"><span class="identifier">base_types</span></code>
            to consider for subcontracting.
          </p></div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2008-2016 Lorenzo
      Caminiti<p>
        Distributed under the Boost Software License, Version 1.0 (see accompanying
        file LICENSE_1_0.txt or a copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="contract_programming_overview.html"><img src="../../..//doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../..//doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../..//doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="advanced_topics.html"><img src="../../..//doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>

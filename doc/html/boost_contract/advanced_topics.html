<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Advanced Topics</title>
<link rel="stylesheet" href="../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;Boost.Contract 1.0">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;Boost.Contract 1.0">
<link rel="prev" href="tutorial.html" title="Tutorial">
<link rel="next" href="../reference.html" title="Reference">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../..//boost.png"></td>
<td align="center"><a href="../../..//index.html">Home</a></td>
<td align="center"><a href="../../..//libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../..//more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="tutorial.html"><img src="../../..//doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../..//doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../..//doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="../reference.html"><img src="../../..//doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="boost_contract.advanced_topics"></a><a class="link" href="advanced_topics.html" title="Advanced Topics">Advanced Topics</a>
</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="advanced_topics.html#boost_contract.advanced_topics.old_values_at_body">Old
      Values at Body</a></span></dt>
<dt><span class="section"><a href="advanced_topics.html#boost_contract.advanced_topics.optional_return_value">Optional
      Return Value</a></span></dt>
<dt><span class="section"><a href="advanced_topics.html#boost_contract.advanced_topics.pure_virtual_public_functions">Pure
      Virtual Public Functions</a></span></dt>
<dt><span class="section"><a href="advanced_topics.html#boost_contract.advanced_topics.overloaded_functions">Overloaded
      Functions</a></span></dt>
<dt><span class="section"><a href="advanced_topics.html#boost_contract.advanced_topics.named_overrides">Named
      Overrides</a></span></dt>
<dt><span class="section"><a href="advanced_topics.html#boost_contract.advanced_topics.move_operations">Move
      Operations</a></span></dt>
<dt><span class="section"><a href="advanced_topics.html#boost_contract.advanced_topics.unions">Unions</a></span></dt>
<dt><span class="section"><a href="advanced_topics.html#boost_contract.advanced_topics.volatile_class_invariants">Volatile
      Class Invariants</a></span></dt>
<dt><span class="section"><a href="advanced_topics.html#boost_contract.advanced_topics.old_value_requirements">Old
      Value Requirements</a></span></dt>
<dt><span class="section"><a href="advanced_topics.html#boost_contract.advanced_topics.assertion_requirements__static_if_">Assertion
      Requirements (Static-If)</a></span></dt>
<dt><span class="section"><a href="advanced_topics.html#boost_contract.advanced_topics.access_specifiers">Access
      Specifiers</a></span></dt>
<dt><span class="section"><a href="advanced_topics.html#boost_contract.advanced_topics.separate_body_implementation">Separate
      Body Implementation</a></span></dt>
<dt><span class="section"><a href="advanced_topics.html#boost_contract.advanced_topics.throw_on_failure">Throw
      on Failure</a></span></dt>
<dt><span class="section"><a href="advanced_topics.html#boost_contract.advanced_topics.disable_contract_checking">Disable
      Contract Checking</a></span></dt>
<dt><span class="section"><a href="advanced_topics.html#boost_contract.advanced_topics.disable_contract_compilation">Disable
      Contract Compilation</a></span></dt>
<dt><span class="section"><a href="advanced_topics.html#boost_contract.advanced_topics.no_macros__no_c__11_">No
      Macros (No C++11)</a></span></dt>
<dt><span class="section"><a href="advanced_topics.html#boost_contract.advanced_topics.no_lambda_functions__no_c__11_">No
      Lambda Functions (No C++11)</a></span></dt>
</dl></div>
<p>
      This section illustrates more advanced uses of this library.
    </p>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_contract.advanced_topics.old_values_at_body"></a><a class="link" href="advanced_topics.html#boost_contract.advanced_topics.old_values_at_body" title="Old Values at Body">Old
      Values at Body</a>
</h3></div></div></div>
<p>
        In the examples seen so far old value variables of type <code class="computeroutput"><a class="link" href="../boost/contract/old_ptr.html" title="Class template old_ptr">boost::contract::old_ptr</a></code>
        are initialized to a copy of the expression passed to <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OLDOF.html" title="Macro BOOST_CONTRACT_OLDOF">BOOST_CONTRACT_OLDOF</a></code>
        at the point of their declaration. This correctly is before the function
        body is executed but also before the contract is executed, therefore even
        before class invariants at function entry and preconditions are checked.
      </p>
<p>
        This is convenient and might be sufficient in most cases. However, in general
        old values should be copied before executing the function body but after
        checking entry class invariants and preconditions (see <a class="link" href="contract_programming_overview.html#boost_contract.contract_programming_overview.assertions" title="Assertions">Assertions</a>).
        There can be cases in which the expression passed to <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OLDOF.html" title="Macro BOOST_CONTRACT_OLDOF">BOOST_CONTRACT_OLDOF</a></code>
        should be evaluated only if the assertions in class invariants and preconditions
        are checked to be true.
      </p>
<p>
        This library allows to construct <code class="computeroutput"><a class="link" href="../boost/contract/old_ptr.html" title="Class template old_ptr">boost::contract::old_ptr</a></code>
        variables using their default constructor (equivalent to a null pointer)
        and then assign them later to a copy of the expression passed to <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OLDOF.html" title="Macro BOOST_CONTRACT_OLDOF">BOOST_CONTRACT_OLDOF</a></code> in a functor
        with no parameter <code class="literal"><span class="emphasis"><em>h</em></span></code><code class="computeroutput"><span class="special">()</span></code> passed to <code class="computeroutput"><span class="special">.</span><span class="identifier">old</span><span class="special">(</span></code><code class="literal"><span class="emphasis"><em>h</em></span></code><code class="computeroutput"><span class="special">)</span></code>. The nullary functor <code class="literal"><span class="emphasis"><em>h</em></span></code><code class="computeroutput"><span class="special">()</span></code> is called by this library before the function
        body is executed but only after class invariants and preconditions are checked:
        <a href="#ftn.boost_contract.advanced_topics.old_values_at_body.f0" class="footnote" name="boost_contract.advanced_topics.old_values_at_body.f0"><sup class="footnote">[33]</sup></a>
      </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">old_ptr</span><span class="special">&lt;...&gt;</span> <span class="identifier">old_</span><code class="literal"><span class="emphasis"><em>name</em></span></code><span class="special">;</span>                 <span class="comment">// Use default constructor.</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">function</span><span class="special">()</span>  <span class="comment">// Same for all other contracts.</span>
    <span class="special">...</span>
    <span class="special">.</span><span class="identifier">old</span><span class="special">([&amp;]</span> <span class="special">{</span>                                          <span class="comment">// Capture by reference...</span>
        <span class="identifier">old_</span><code class="literal"><span class="emphasis"><em>name</em></span></code> <span class="special">=</span> <span class="identifier">BOOST_CONTRACT_OLDOF</span><span class="special">(</span><code class="literal"><span class="emphasis"><em>expression</em></span></code><span class="special">);</span>    <span class="comment">// ...but modify only old values.</span>
    <span class="special">})</span>
    <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
        <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(*</span><span class="identifier">old_</span><code class="literal"><span class="emphasis"><em>name</em></span></code> <span class="special">...);</span>
        <span class="special">...</span>
    <span class="special">})</span>
<span class="special">;</span>
</pre>
<p>
        For example, the following old value expression <code class="computeroutput"><span class="identifier">s</span><span class="special">[</span><span class="identifier">index</span><span class="special">]</span></code> passed to <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OLDOF.html" title="Macro BOOST_CONTRACT_OLDOF">BOOST_CONTRACT_OLDOF</a></code>
        is valid only after the precondition has checked that <code class="computeroutput"><span class="identifier">index</span></code>
        is within range <code class="computeroutput"><span class="identifier">index</span> <span class="special">&lt;</span>
        <span class="identifier">s</span><span class="special">.</span><span class="identifier">size</span><span class="special">()</span></code>.
        Therefore, <code class="computeroutput"><span class="identifier">old_y</span></code> is first
        declared using its default constructor (i.e., initialized to a null pointer)
        and later assigned to a copy of <code class="computeroutput"><span class="identifier">s</span><span class="special">[</span><span class="identifier">index</span><span class="special">]</span></code> in <code class="computeroutput"><span class="special">.</span><span class="identifier">old</span><span class="special">(...)</span></code>
        after the precondition has checked that <code class="computeroutput"><span class="identifier">index</span></code>
        is in range (see also <a href="../../../example/features/old.cpp" target="_top"><code class="literal">old.cpp</code></a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">char</span> <span class="identifier">replace</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&amp;</span> <span class="identifier">s</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">index</span><span class="special">,</span> <span class="keyword">char</span> <span class="identifier">x</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">char</span> <span class="identifier">result</span><span class="special">;</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">old_ptr</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span> <span class="identifier">old_y</span><span class="special">;</span> <span class="comment">// But old value copied later...</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">function</span><span class="special">()</span>
        <span class="special">.</span><span class="identifier">precondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
            <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">index</span> <span class="special">&lt;</span> <span class="identifier">s</span><span class="special">.</span><span class="identifier">size</span><span class="special">());</span>
        <span class="special">})</span>
        <span class="special">.</span><span class="identifier">old</span><span class="special">([&amp;]</span> <span class="special">{</span> <span class="comment">// ...after preconditions (and invariants) checked.</span>
            <span class="identifier">old_y</span> <span class="special">=</span> <span class="identifier">BOOST_CONTRACT_OLDOF</span><span class="special">(</span><span class="identifier">s</span><span class="special">[</span><span class="identifier">index</span><span class="special">]);</span>
        <span class="special">})</span>
        <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
            <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">s</span><span class="special">[</span><span class="identifier">index</span><span class="special">]</span> <span class="special">==</span> <span class="identifier">x</span><span class="special">);</span>
            <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">result</span> <span class="special">==</span> <span class="special">*</span><span class="identifier">old_y</span><span class="special">);</span>
        <span class="special">})</span>
    <span class="special">;</span>

    <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">s</span><span class="special">[</span><span class="identifier">index</span><span class="special">];</span>
    <span class="identifier">s</span><span class="special">[</span><span class="identifier">index</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">x</span><span class="special">;</span>
    <span class="keyword">return</span> <span class="identifier">result</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        The functor passed to <code class="computeroutput"><span class="special">.</span><span class="identifier">old</span><span class="special">(...)</span></code> should capture all variables it needs
        to evaluate and copy old value expressions. In general, these variables should
        be captured by reference and not by value (because old values need to copy
        values the variables will have just before executing the function body, and
        not the value these variables had when the functor passed to <code class="computeroutput"><span class="special">.</span><span class="identifier">old</span><span class="special">(...)</span></code>
        was first declared). In any case, this functor should modify only old values
        and not the value of other captured variables (see also <a class="link" href="contract_programming_overview.html#boost_contract.contract_programming_overview.constant_correctness" title="Constant-Correctness">Constant-Correctness</a>).
      </p>
<p>
        This library will automatically call <code class="computeroutput">boost::contract::postcondition_failure</code>
        if calling the functor specified via <code class="computeroutput"><span class="special">.</span><span class="identifier">old</span><span class="special">(...)</span></code>
        throws an exception (by default, this terminates the program calling <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">terminate</span></code>,
        but see <a class="link" href="advanced_topics.html#boost_contract.advanced_topics.throw_on_failure" title="Throw on Failure">Throw
        on Failure</a> to throw exceptions, exit the program with an error code,
        etc.). <a href="#ftn.boost_contract.advanced_topics.old_values_at_body.f1" class="footnote" name="boost_contract.advanced_topics.old_values_at_body.f1"><sup class="footnote">[34]</sup></a> copy constructor, <code class="computeroutput"><a class="link" href="../boost/contract/make_old_id478623.html" title="Function make_old">boost::contract::make_old</a></code>,
        etc.) in try-catch statements so this library will call <code class="computeroutput">boost::contract::postcondition_failure</code>
        also when old values are copied when they are constructed outside <code class="computeroutput"><span class="special">.</span><span class="identifier">old</span><span class="special">(...)</span></code>,
        that will prevent this library from knowing the <code class="computeroutput">boost::contract::from</code>
        parameter which is not acceptable (specifically because destructors can have
        postconditions). ]
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_contract.advanced_topics.optional_return_value"></a><a class="link" href="advanced_topics.html#boost_contract.advanced_topics.optional_return_value" title="Optional Return Value">Optional
      Return Value</a>
</h3></div></div></div>
<p>
        It is possible to use <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">optional</span></code>
        to handle the return value when programmers cannot construct the result variable
        at its point of declaration before the contract (e.g., because an appropriate
        constructor for the return type is not available at that point, or just because
        it would be too expensive to execute an extra initialization of the result
        value at run-time). <a href="#ftn.boost_contract.advanced_topics.optional_return_value.f0" class="footnote" name="boost_contract.advanced_topics.optional_return_value.f0"><sup class="footnote">[35]</sup></a> For example (see also <a href="../../../example/features/optional_result.cpp" target="_top"><code class="literal">optional_result.cpp</code></a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">surface</span> <span class="special">{</span>
    <span class="keyword">int</span> <span class="identifier">area</span><span class="special">;</span>
    <span class="keyword">int</span> <span class="identifier">perimeter</span><span class="special">;</span>

    <span class="comment">// No default constructor.</span>
    <span class="identifier">surface</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">area</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">perimeter</span><span class="special">)</span> <span class="special">:</span> <span class="identifier">area</span><span class="special">(</span><span class="identifier">area</span><span class="special">),</span> <span class="identifier">perimeter</span><span class="special">(</span><span class="identifier">perimeter</span><span class="special">)</span> <span class="special">{}</span>
<span class="special">};</span>

<span class="identifier">surface</span> <span class="identifier">square_surface</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">edge</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">optional</span><span class="special">&lt;</span><span class="identifier">surface</span><span class="special">&gt;</span> <span class="identifier">result</span><span class="special">;</span> <span class="comment">// No default constructor so use optional.</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">function</span><span class="special">()</span>
        <span class="special">.</span><span class="identifier">precondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
            <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">edge</span> <span class="special">&gt;</span> <span class="number">0</span><span class="special">);</span>
        <span class="special">})</span>
        <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
            <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">result</span><span class="special">-&gt;</span><span class="identifier">area</span> <span class="special">==</span> <span class="identifier">edge</span> <span class="special">*</span> <span class="identifier">edge</span><span class="special">);</span>
            <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">result</span><span class="special">-&gt;</span><span class="identifier">perimeter</span> <span class="special">==</span> <span class="identifier">edge</span> <span class="special">*</span> <span class="number">4</span><span class="special">);</span>
        <span class="special">})</span>
    <span class="special">;</span>

    <span class="keyword">return</span> <span class="special">*(</span><span class="identifier">result</span> <span class="special">=</span> <span class="identifier">surface</span><span class="special">(</span><span class="identifier">edge</span> <span class="special">*</span> <span class="identifier">edge</span><span class="special">,</span> <span class="identifier">edge</span> <span class="special">*</span> <span class="number">4</span><span class="special">));</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        In this example the return type <code class="computeroutput"><span class="identifier">surface</span></code>
        does not have a default constructor that can be used to initialize <code class="computeroutput"><span class="identifier">result</span></code> when it is first declared. The
        <code class="computeroutput"><span class="identifier">surface</span></code> non-default constructor
        should not be used to initialize <code class="computeroutput"><span class="identifier">result</span></code>
        by passing it <code class="computeroutput"><span class="identifier">edge</span> <span class="special">*</span>
        <span class="identifier">edge</span></code> and <code class="computeroutput"><span class="identifier">edge</span>
        <span class="special">*</span> <span class="number">4</span></code>
        because such operations are logically the responsibility of the function
        body (in fact, it makes logical sense to do such multiplications only after
        <code class="computeroutput"><span class="identifier">edge</span></code> has been checked to
        be positive by the preconditions). Therefore, instead of initializing <code class="computeroutput"><span class="identifier">result</span></code> with some arbitrary <code class="computeroutput"><span class="identifier">area</span></code> and <code class="computeroutput"><span class="identifier">perimeter</span></code>
        values (e.g., <code class="computeroutput"><span class="number">0</span></code> and <code class="computeroutput"><span class="number">0</span></code>, or <code class="computeroutput"><span class="special">-</span><span class="number">1</span></code> and <code class="computeroutput"><span class="special">-</span><span class="number">1</span></code>), <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">optional</span></code>
        is used in this example to not initialize <code class="computeroutput"><span class="identifier">result</span></code>
        with a return value when it is first declared before the contract. <code class="computeroutput"><span class="identifier">result</span></code> is initialized later in the function
        body when the function is about to return and directly using the correct
        return value <code class="computeroutput"><span class="identifier">result</span> <span class="special">=</span>
        <span class="identifier">surface</span><span class="special">(</span><span class="identifier">edge</span> <span class="special">*</span> <span class="identifier">edge</span><span class="special">,</span> <span class="identifier">edge</span> <span class="special">*</span> <span class="number">4</span><span class="special">)</span></code>.
      </p>
<p>
        When this technique is used, programmers have to make sure that each return
        statement in the function is of the form:
      </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">optional</span><span class="special">&lt;...&gt;</span> <span class="identifier">result</span><span class="special">;</span>
<span class="special">...</span>
<span class="keyword">return</span> <span class="special">*(</span><span class="identifier">result</span> <span class="special">=</span> <span class="special">...);</span>
</pre>
<p>
        This also ensures that <code class="computeroutput"><span class="identifier">result</span></code>
        is always set to the return value before the postconditions are checked.
        Therefore, programmers can always dereference <code class="computeroutput"><span class="identifier">result</span></code>
        in postconditions to access the return value (using <code class="computeroutput"><span class="keyword">operator</span><span class="special">*</span></code> and <code class="computeroutput"><span class="keyword">operator</span><span class="special">-&gt;</span></code> as usual with <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">optional</span></code>,
        and without having to explicitly check if <code class="computeroutput"><span class="identifier">result</span></code>
        is an empty <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">optional</span></code> object).
      </p>
<h5>
<a name="boost_contract.advanced_topics.optional_return_value.h0"></a>
        <span class="phrase"><a name="boost_contract.advanced_topics.optional_return_value.virtual_and_overriding_public_functions"></a></span><a class="link" href="advanced_topics.html#boost_contract.advanced_topics.optional_return_value.virtual_and_overriding_public_functions">Virtual
        and Overriding Public Functions</a>
      </h5>
<p>
        Similarly, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">optional</span></code> can be used for return values
        of virtual and overriding public functions. As usual with non-void virtual
        and overriding public functions the return value <code class="computeroutput"><span class="identifier">result</span></code>
        must be passed as a parameter to <code class="computeroutput"><a class="link" href="../boost/contract/public_function_id480248.html" title="Function template public_function">boost::contract::public_function</a></code>
        right after <code class="computeroutput"><span class="identifier">v</span></code> (see also
        <a class="link" href="tutorial.html#boost_contract.tutorial.virtual_public_functions" title="Virtual Public Functions">Virtual
        Public Functions</a>). This this case the functor passed to <code class="computeroutput"><span class="special">.</span><span class="identifier">postcondition</span><span class="special">(...)</span></code> takes a parameter of type <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">optional</span><span class="special">&lt;</span></code><code class="literal"><span class="emphasis"><em>result-type</em></span></code><code class="computeroutput">
        <span class="keyword">const</span><span class="special">&amp;&gt;</span>
        <span class="keyword">const</span><span class="special">&amp;</span></code>
        (see <a class="link" href="advanced_topics.html#boost_contract.advanced_topics.pure_virtual_public_functions" title="Pure Virtual Public Functions">Pure
        Virtual Public Functions</a> for an example):
      </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">optional</span><span class="special">&lt;</span><code class="literal"><span class="emphasis"><em>return-type</em></span></code><span class="special">&gt;</span> <span class="identifier">result</span><span class="special">;</span>
<span class="special">...</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">(</span><span class="identifier">v</span><span class="special">,</span> <span class="identifier">result</span><span class="special">,</span> <span class="special">...)</span>
    <span class="special">...</span>
    <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">optional</span><span class="special">&lt;</span><code class="literal"><span class="emphasis"><em>return-type</em></span></code> <span class="keyword">const</span><span class="special">&amp;&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">result</span><span class="special">)</span> <span class="special">{</span>
        <span class="special">...</span>
    <span class="special">}</span>
<span class="special">;</span>
<span class="special">...</span>
<span class="keyword">return</span> <span class="special">*(</span><span class="identifier">result</span> <span class="special">=</span> <span class="special">...);</span>
</pre>
<p>
        The inner <code class="computeroutput"><span class="keyword">const</span><span class="special">&amp;</span></code>
        in the postcondition functor parameter type <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">optional</span><span class="special">&lt;...</span> <span class="keyword">const</span><span class="special">&amp;&gt;</span></code> is mandatory (the outer <code class="computeroutput"><span class="keyword">const</span><span class="special">&amp;</span></code>
        in the postcondition functor parameter type <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">optional</span><span class="special">&lt;...</span> <span class="keyword">const</span><span class="special">&amp;&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span></code> is not). <a href="#ftn.boost_contract.advanced_topics.optional_return_value.f1" class="footnote" name="boost_contract.advanced_topics.optional_return_value.f1"><sup class="footnote">[36]</sup></a>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_contract.advanced_topics.pure_virtual_public_functions"></a><a class="link" href="advanced_topics.html#boost_contract.advanced_topics.pure_virtual_public_functions" title="Pure Virtual Public Functions">Pure
      Virtual Public Functions</a>
</h3></div></div></div>
<p>
        In C++, pure virtual functions are allowed to have a <span class="emphasis"><em>default implementation</em></span>
        as long as such implementation is programmed out-of-line so defined outside
        the class declaring the pure virtual function as <code class="computeroutput"><span class="keyword">virtual</span>
        <span class="special">...</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span></code>. Contracts
        for pure virtual public functions are programmed using the <code class="computeroutput"><a class="link" href="../boost/contract/public_function_id480248.html" title="Function template public_function">boost::contract::public_function</a></code>
        function like for (non-pure) virtual public functions, so all consideration
        made in <a class="link" href="tutorial.html#boost_contract.tutorial.virtual_public_functions" title="Virtual Public Functions">Virtual
        Public Functions</a> apply. However, in this case contracts are always
        programmed out-of-line, in the default implementation of the pure virtual
        function.
      </p>
<p>
        For example, note how the following <code class="computeroutput"><span class="identifier">shape</span><span class="special">::</span><span class="identifier">get_surface</span></code>
        default implementation (which is used to program the pure virtual function
        contract) must be defined out-of-line and therefore outside the <code class="computeroutput"><span class="identifier">shape</span></code> class declaration (see also <a href="../../../example/features/pure_virtual_public.cpp" target="_top"><code class="literal">pure_virtual_public.cpp</code></a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">surface</span> <span class="special">{</span>
    <span class="keyword">int</span> <span class="identifier">area</span><span class="special">;</span>
    <span class="keyword">int</span> <span class="identifier">perimeter</span><span class="special">;</span>

    <span class="comment">// No default constructor.</span>
    <span class="identifier">surface</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">area</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">perimeter</span><span class="special">)</span> <span class="special">:</span> <span class="identifier">area</span><span class="special">(</span><span class="identifier">area</span><span class="special">),</span> <span class="identifier">perimeter</span><span class="special">(</span><span class="identifier">perimeter</span><span class="special">)</span> <span class="special">{}</span>
<span class="special">};</span>

<span class="keyword">class</span> <span class="identifier">shape</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">virtual</span> <span class="identifier">surface</span> <span class="identifier">get_surface</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">virtual_</span><span class="special">*</span> <span class="identifier">v</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
<span class="special">};</span>

<span class="comment">// Pure-virtual function definition (and contract) out-of-line (usual in C++).</span>
<span class="identifier">surface</span> <span class="identifier">shape</span><span class="special">::</span><span class="identifier">get_surface</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">virtual_</span><span class="special">*</span> <span class="identifier">v</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">optional</span><span class="special">&lt;</span><span class="identifier">surface</span><span class="special">&gt;</span> <span class="identifier">result</span><span class="special">;</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">(</span><span class="identifier">v</span><span class="special">,</span> <span class="identifier">result</span><span class="special">,</span> <span class="keyword">this</span><span class="special">)</span>
        <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">optional</span><span class="special">&lt;</span><span class="identifier">surface</span> <span class="keyword">const</span><span class="special">&amp;&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">result</span><span class="special">)</span> <span class="special">{</span>
            <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">result</span><span class="special">-&gt;</span><span class="identifier">area</span> <span class="special">&gt;</span> <span class="number">0</span><span class="special">);</span>
            <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">result</span><span class="special">-&gt;</span><span class="identifier">perimeter</span> <span class="special">&gt;</span> <span class="number">0</span><span class="special">);</span>
        <span class="special">})</span>
    <span class="special">;</span>

    <span class="identifier">assert</span><span class="special">(</span><span class="keyword">false</span><span class="special">);</span> <span class="comment">// Pure function body (never executed by this library).</span>
    <span class="keyword">return</span> <span class="special">*</span><span class="identifier">result</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">class</span> <span class="identifier">square</span>
    <span class="preprocessor">#define</span> <span class="identifier">BASES</span> <span class="keyword">private</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">constructor_precondition</span><span class="special">&lt;</span><span class="identifier">square</span><span class="special">&gt;,</span> <span class="special">\</span>
            <span class="keyword">public</span> <span class="identifier">shape</span>
    <span class="special">:</span> <span class="identifier">BASES</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">BOOST_CONTRACT_BASE_TYPES</span><span class="special">(</span><span class="identifier">BASES</span><span class="special">)</span> <span class="identifier">base_types</span><span class="special">;</span>
    <span class="preprocessor">#undef</span> <span class="identifier">BASES</span>

    <span class="identifier">surface</span> <span class="identifier">get_surface</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">virtual_</span><span class="special">*</span> <span class="identifier">v</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span> <span class="comment">/* override */</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">optional</span><span class="special">&lt;</span><span class="identifier">surface</span><span class="special">&gt;</span> <span class="identifier">result</span><span class="special">;</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">&lt;</span>
                <span class="identifier">override_get_surface</span><span class="special">&gt;(</span><span class="identifier">v</span><span class="special">,</span> <span class="identifier">result</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">square</span><span class="special">::</span><span class="identifier">get_surface</span><span class="special">,</span> <span class="keyword">this</span><span class="special">)</span>
            <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">optional</span><span class="special">&lt;</span><span class="identifier">surface</span> <span class="keyword">const</span><span class="special">&amp;&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">result</span><span class="special">)</span> <span class="special">{</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">result</span><span class="special">-&gt;</span><span class="identifier">area</span> <span class="special">==</span> <span class="identifier">edge</span><span class="special">()</span> <span class="special">*</span> <span class="identifier">edge</span><span class="special">());</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">result</span><span class="special">-&gt;</span><span class="identifier">perimeter</span> <span class="special">==</span> <span class="identifier">edge</span><span class="special">()</span> <span class="special">*</span> <span class="number">4</span><span class="special">);</span>
            <span class="special">})</span>
        <span class="special">;</span>

        <span class="keyword">return</span> <span class="special">*(</span><span class="identifier">result</span> <span class="special">=</span> <span class="identifier">surface</span><span class="special">(</span><span class="identifier">edge</span><span class="special">()</span> <span class="special">*</span> <span class="identifier">edge</span><span class="special">(),</span> <span class="identifier">edge</span><span class="special">()</span> <span class="special">*</span> <span class="number">4</span><span class="special">));</span>
    <span class="special">}</span>
    <span class="identifier">BOOST_CONTRACT_OVERRIDE</span><span class="special">(</span><span class="identifier">get_surface</span><span class="special">)</span>

    <span class="comment">/* ... */</span>
</pre>
<p>
      </p>
<p>
        This library will never actually execute the pure virtual function body while
        it is calling the pure virtual function default implementation to check its
        contract for subcontracting. Therefore, programmers can safely <code class="computeroutput"><span class="identifier">assert</span><span class="special">(</span><span class="keyword">false</span><span class="special">)</span></code> at
        the beginning of the body if they intend for that body to never be executed
        (or they can program a working body in case they need to use C++ pure virtual
        function default implementation outside of what strictly required by this
        library).
      </p>
<p>
        Note that because of subcontracting, preconditions of derived class functions
        are checked in <a class="link" href="contract_programming_overview.html#or_anchor"><code class="literal"><span class="emphasis"><em>OR</em></span></code></a>
        with preconditions of base class functions (see <a class="link" href="tutorial.html#boost_contract.tutorial.public_function_overrides__subcontracting_" title="Public Function Overrides (Subcontracting)">Public
        Function Overrides</a>). If base class member functions specify no precondition
        then preconditions specified by overriding functions in derived classes will
        have no effect (because when checked in <a class="link" href="contract_programming_overview.html#or_anchor"><code class="literal"><span class="emphasis"><em>OR</em></span></code></a>
        with the base class function that has no precondition they will always pass).
        This correctly reflects the fact that the base class member function can
        be called in any context (because it has no precondition) and so must all
        its overriding function in derived classes in order for the derived class
        to act like the base class in virtue of inheritance. However, it is sometimes
        acceptable for a base class to declare a pure virtual function with a precondition
        <code class="computeroutput"><span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="keyword">false</span><span class="special">)</span></code> indicating
        that the pure virtual function must be redefined by derived classes (as always
        with pure virtual functions) and also that derived classes will be responsible
        to specify preconditions (this technique makes sense only for preconditions
        of pure virtual functions otherwise it will prevent a concrete base function
        from being ever called successfully). For example (see also <a href="../../../example/features/named_override.cpp" target="_top"><code class="literal">named_override.cpp</code></a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">generic_unary_pack</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="identifier">_1</span><span class="special">(</span><span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">value</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">virtual_</span><span class="special">*</span> <span class="identifier">v</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
    <span class="keyword">virtual</span> <span class="identifier">T</span> <span class="identifier">_1</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">virtual_</span><span class="special">*</span> <span class="identifier">v</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">generic_unary_pack</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">_1</span><span class="special">(</span><span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">value</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">virtual_</span><span class="special">*</span> <span class="identifier">v</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">(</span><span class="identifier">v</span><span class="special">,</span> <span class="keyword">this</span><span class="special">)</span>
        <span class="special">.</span><span class="identifier">precondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
            <span class="comment">// Derived concrete classes will enforce preconditions.</span>
            <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="keyword">false</span><span class="special">);</span>
        <span class="special">})</span>
    <span class="special">;</span>
    <span class="identifier">assert</span><span class="special">(</span><span class="keyword">false</span><span class="special">);</span>
<span class="special">}</span>

<span class="comment">/* ... */</span>
</pre>
<p>
      </p>
<p>
        As already discussed in <a class="link" href="tutorial.html#boost_contract.tutorial.private_and_protected_functions" title="Private and Protected Functions">Private
        and Protected Functions</a>, private and protected member functions do
        not check class invariants and do not subcontract (not even when they are
        virtual or pure virtual). Therefore, no contract is ever programmed for a
        private or protected pure virtual function (because that contract would never
        be checked during subcontracting anyway).
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_contract.advanced_topics.overloaded_functions"></a><a class="link" href="advanced_topics.html#boost_contract.advanced_topics.overloaded_functions" title="Overloaded Functions">Overloaded
      Functions</a>
</h3></div></div></div>
<p>
        As seen in <a class="link" href="tutorial.html#boost_contract.tutorial.public_function_overrides__subcontracting_" title="Public Function Overrides (Subcontracting)">Public
        Function Overrides</a>, <code class="computeroutput"><a class="link" href="../boost/contract/public_function_id480248.html" title="Function template public_function">boost::contract::public_function</a></code>
        takes a pointer to the enclosing function as a parameter when used in overriding
        public functions. When an overriding public function is overloaded, the function
        pointer cannot be automatically deduced by the compiler so programmers have
        to use <code class="computeroutput"><span class="keyword">static_cast</span></code> to resolve
        ambiguities (as usual with pointers to overloaded functions in C++). <a href="#ftn.boost_contract.advanced_topics.overloaded_functions.f0" class="footnote" name="boost_contract.advanced_topics.overloaded_functions.f0"><sup class="footnote">[37]</sup></a> For example, note how <code class="computeroutput"><span class="keyword">static_cast</span></code>
        is used in the following calls to <code class="computeroutput"><a class="link" href="../boost/contract/public_function_id480248.html" title="Function template public_function">boost::contract::public_function</a></code>
        (see also <a href="../../../example/features/overload.cpp" target="_top"><code class="literal">overload.cpp</code></a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">string_lines</span>
    <span class="preprocessor">#define</span> <span class="identifier">BASES</span> <span class="keyword">public</span> <span class="identifier">lines</span>
    <span class="special">:</span> <span class="identifier">BASES</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">BOOST_CONTRACT_BASE_TYPES</span><span class="special">(</span><span class="identifier">BASES</span><span class="special">)</span> <span class="identifier">base_types</span><span class="special">;</span>
    <span class="preprocessor">#undef</span> <span class="identifier">BASES</span>

    <span class="identifier">BOOST_CONTRACT_OVERRIDES</span><span class="special">(</span><span class="identifier">str</span><span class="special">)</span> <span class="comment">// Used only once for all `str` overloads.</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">virtual_</span><span class="special">*</span> <span class="identifier">v</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">const</span> <span class="comment">/* override */</span> <span class="special">{</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">result</span><span class="special">;</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">&lt;</span>
            <span class="identifier">override_str</span>
        <span class="comment">// Note the use of `static_cast` (and same in other overloads below).</span>
        <span class="special">&gt;(</span><span class="identifier">v</span><span class="special">,</span> <span class="identifier">result</span><span class="special">,</span> <span class="keyword">static_cast</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="special">(</span><span class="identifier">string_lines</span><span class="special">::*)(</span>
                <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">virtual_</span><span class="special">*)</span> <span class="keyword">const</span><span class="special">&gt;(&amp;</span><span class="identifier">string_lines</span><span class="special">::</span><span class="identifier">str</span><span class="special">),</span> <span class="keyword">this</span><span class="special">);</span>

        <span class="keyword">return</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">str_</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="comment">// Overload on (absence of) `const` qualifier.</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&amp;</span> <span class="identifier">str</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">virtual_</span><span class="special">*</span> <span class="identifier">v</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="comment">/* override */</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">&lt;</span>
            <span class="identifier">override_str</span>
        <span class="special">&gt;(</span><span class="identifier">v</span><span class="special">,</span> <span class="identifier">str_</span><span class="special">,</span> <span class="keyword">static_cast</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&amp;</span> <span class="special">(</span><span class="identifier">string_lines</span><span class="special">::*)(</span>
                <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">virtual_</span><span class="special">*)&gt;(&amp;</span><span class="identifier">string_lines</span><span class="special">::</span><span class="identifier">str</span><span class="special">),</span> <span class="keyword">this</span><span class="special">);</span>

        <span class="keyword">return</span> <span class="identifier">str_</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="identifier">BOOST_CONTRACT_OVERRIDES</span><span class="special">(</span><span class="identifier">put</span><span class="special">)</span> <span class="comment">// Used only once for all `put` overloads.</span>

    <span class="keyword">void</span> <span class="identifier">put</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">,</span>
            <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">virtual_</span><span class="special">*</span> <span class="identifier">v</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="comment">/* override */</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">old_ptr</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="identifier">old_str</span> <span class="special">=</span>
                <span class="identifier">BOOST_CONTRACT_OLDOF</span><span class="special">(</span><span class="identifier">v</span><span class="special">,</span> <span class="identifier">str</span><span class="special">());</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">&lt;</span>
            <span class="identifier">override_put</span>
        <span class="special">&gt;(</span><span class="identifier">v</span><span class="special">,</span> <span class="keyword">static_cast</span><span class="special">&lt;</span><span class="keyword">void</span> <span class="special">(</span><span class="identifier">string_lines</span><span class="special">::*)(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span><span class="special">&amp;,</span>
                <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">virtual_</span><span class="special">*)&gt;(&amp;</span><span class="identifier">string_lines</span><span class="special">::</span><span class="identifier">put</span><span class="special">),</span> <span class="keyword">this</span><span class="special">,</span> <span class="identifier">x</span><span class="special">)</span>
            <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">str</span><span class="special">()</span> <span class="special">==</span> <span class="special">*</span><span class="identifier">old_str</span> <span class="special">+</span> <span class="identifier">x</span> <span class="special">+</span> <span class="char">'\n'</span><span class="special">);</span>
            <span class="special">})</span>
        <span class="special">;</span>

        <span class="identifier">str_</span> <span class="special">=</span> <span class="identifier">str_</span> <span class="special">+</span> <span class="identifier">x</span> <span class="special">+</span> <span class="char">'\n'</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="comment">// Overload on argument type.</span>
    <span class="keyword">void</span> <span class="identifier">put</span><span class="special">(</span><span class="keyword">char</span> <span class="identifier">x</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">virtual_</span><span class="special">*</span> <span class="identifier">v</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="comment">/* override */</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">old_ptr</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="identifier">old_str</span> <span class="special">=</span>
                <span class="identifier">BOOST_CONTRACT_OLDOF</span><span class="special">(</span><span class="identifier">v</span><span class="special">,</span> <span class="identifier">str</span><span class="special">());</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">&lt;</span>
            <span class="identifier">override_put</span>
        <span class="special">&gt;(</span><span class="identifier">v</span><span class="special">,</span> <span class="keyword">static_cast</span><span class="special">&lt;</span><span class="keyword">void</span> <span class="special">(</span><span class="identifier">string_lines</span><span class="special">::*)(</span><span class="keyword">char</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span>
                <span class="identifier">virtual_</span><span class="special">*)&gt;(&amp;</span><span class="identifier">string_lines</span><span class="special">::</span><span class="identifier">put</span><span class="special">),</span> <span class="keyword">this</span><span class="special">,</span> <span class="identifier">x</span><span class="special">)</span>
            <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">str</span><span class="special">()</span> <span class="special">==</span> <span class="special">*</span><span class="identifier">old_str</span> <span class="special">+</span> <span class="identifier">x</span> <span class="special">+</span> <span class="char">'\n'</span><span class="special">);</span>
            <span class="special">})</span>
        <span class="special">;</span>

        <span class="identifier">str_</span> <span class="special">=</span> <span class="identifier">str_</span> <span class="special">+</span> <span class="identifier">x</span> <span class="special">+</span> <span class="char">'\n'</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="comment">// Overload on argument type and arity (also with default parameter).</span>
    <span class="keyword">void</span> <span class="identifier">put</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">x</span><span class="special">,</span> <span class="keyword">bool</span> <span class="identifier">tab</span> <span class="special">=</span> <span class="keyword">false</span><span class="special">,</span>
            <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">virtual_</span><span class="special">*</span> <span class="identifier">v</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="comment">/* override */</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">old_ptr</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">&gt;</span> <span class="identifier">old_str</span> <span class="special">=</span>
                <span class="identifier">BOOST_CONTRACT_OLDOF</span><span class="special">(</span><span class="identifier">v</span><span class="special">,</span> <span class="identifier">str</span><span class="special">());</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">&lt;</span>
            <span class="identifier">override_put</span>
        <span class="special">&gt;(</span><span class="identifier">v</span><span class="special">,</span> <span class="keyword">static_cast</span><span class="special">&lt;</span><span class="keyword">void</span> <span class="special">(</span><span class="identifier">string_lines</span><span class="special">::*)(</span><span class="keyword">int</span><span class="special">,</span> <span class="keyword">bool</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span>
                <span class="identifier">virtual_</span><span class="special">*)&gt;(&amp;</span><span class="identifier">string_lines</span><span class="special">::</span><span class="identifier">put</span><span class="special">),</span> <span class="keyword">this</span><span class="special">,</span> <span class="identifier">x</span><span class="special">,</span> <span class="identifier">tab</span><span class="special">)</span>
            <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
                <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostringstream</span> <span class="identifier">s</span><span class="special">;</span>
                <span class="identifier">s</span> <span class="special">&lt;&lt;</span> <span class="identifier">x</span><span class="special">;</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span>
                        <span class="identifier">str</span><span class="special">()</span> <span class="special">==</span> <span class="special">*</span><span class="identifier">old_str</span> <span class="special">+</span> <span class="special">(</span><span class="identifier">tab</span> <span class="special">?</span> <span class="string">"\t"</span> <span class="special">:</span> <span class="string">""</span><span class="special">)</span> <span class="special">+</span> <span class="identifier">s</span><span class="special">.</span><span class="identifier">str</span><span class="special">()</span> <span class="special">+</span> <span class="char">'\n'</span><span class="special">);</span>
            <span class="special">})</span>
        <span class="special">;</span>

        <span class="identifier">std</span><span class="special">::</span><span class="identifier">ostringstream</span> <span class="identifier">s</span><span class="special">;</span>
        <span class="identifier">s</span> <span class="special">&lt;&lt;</span> <span class="identifier">str_</span> <span class="special">&lt;&lt;</span> <span class="special">(</span><span class="identifier">tab</span> <span class="special">?</span> <span class="string">"\t"</span> <span class="special">:</span> <span class="string">""</span><span class="special">)</span> <span class="special">&lt;&lt;</span> <span class="identifier">x</span> <span class="special">&lt;&lt;</span> <span class="char">'\n'</span><span class="special">;</span>
        <span class="identifier">str_</span> <span class="special">=</span> <span class="identifier">s</span><span class="special">.</span><span class="identifier">str</span><span class="special">();</span>
    <span class="special">}</span>

<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span> <span class="identifier">str_</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
      </p>
<p>
        Overloaded functions have the same function name so the same <code class="literal">override_<span class="emphasis"><em>function-name</em></span></code>
        type can be used as template parameter of <code class="computeroutput"><a class="link" href="../boost/contract/public_function_id480248.html" title="Function template public_function">boost::contract::public_function</a></code>.
        Therefore, <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OVERRIDE.html" title="Macro BOOST_CONTRACT_OVERRIDE">BOOST_CONTRACT_OVERRIDE</a></code>
        only needs to be invoked once for any given function name even when the function
        name is overloaded (as shown in the example above).
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_contract.advanced_topics.named_overrides"></a><a class="link" href="advanced_topics.html#boost_contract.advanced_topics.named_overrides" title="Named Overrides">Named
      Overrides</a>
</h3></div></div></div>
<p>
        The function name passed to <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OVERRIDE.html" title="Macro BOOST_CONTRACT_OVERRIDE">BOOST_CONTRACT_OVERRIDE</a></code>
        should never start with an underscore to avoid generating names containing
        double underscores <code class="computeroutput"><span class="identifier">override__</span><span class="special">...</span></code> that are reserved by the C++ standard.
        There is a separate macro <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_NAMED_OVERRIDE.html" title="Macro BOOST_CONTRACT_NAMED_OVERRIDE">BOOST_CONTRACT_NAMED_OVERRIDE</a></code>
        that can be used to explicitly specify the name of the type that will be
        passed to <code class="computeroutput"><a class="link" href="../boost/contract/public_function_id480248.html" title="Function template public_function">boost::contract::public_function</a></code>
        as a template argument: <a href="#ftn.boost_contract.advanced_topics.named_overrides.f0" class="footnote" name="boost_contract.advanced_topics.named_overrides.f0"><sup class="footnote">[38]</sup></a>
      </p>
<pre class="programlisting"><span class="identifier">BOOST_CONTRACT_OVERRIDE</span><span class="special">(</span><code class="literal"><span class="emphasis"><em>function-name</em></span></code><span class="special">)</span>                  <span class="comment">// Generate `override_...`.</span>
<span class="identifier">BOOST_CONTRACT_NAMED_OVERRIDE</span><span class="special">(</span><code class="literal"><span class="emphasis"><em>type-name</em></span></code><span class="special">,</span> <code class="literal"><span class="emphasis"><em>function-name</em></span></code><span class="special">)</span> <span class="comment">// Generate `type-name`.</span>
</pre>
<p>
        For example, the following overriding member function is named <code class="computeroutput"><span class="identifier">_1</span></code> so <code class="computeroutput"><span class="identifier">BOOST_CONTRACT_OVERRIDE</span><span class="special">(</span><span class="identifier">_1</span><span class="special">)</span></code>
        would generate a type named <code class="computeroutput"><span class="identifier">override__1</span></code>
        (which is reserved in C++ because it contains double underscores <code class="computeroutput"><span class="identifier">__</span></code>), <code class="computeroutput"><span class="identifier">BOOST_CONTRACT_NAMED_OVERRIDE</span><span class="special">(</span><span class="identifier">override1</span><span class="special">,</span> <span class="identifier">_1</span><span class="special">)</span></code>
        is used to name the type <code class="computeroutput"><span class="identifier">override1</span></code>
        instead (see also <a href="../../../example/features/named_override.cpp" target="_top"><code class="literal">named_override.cpp</code></a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">positive_unary_pack</span>
    <span class="preprocessor">#define</span> <span class="identifier">BASES</span> <span class="keyword">public</span> <span class="identifier">generic_unary_pack</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span>
    <span class="special">:</span> <span class="identifier">BASES</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">BOOST_CONTRACT_BASE_TYPES</span><span class="special">(</span><span class="identifier">BASES</span><span class="special">)</span> <span class="identifier">base_types</span><span class="special">;</span>
    <span class="preprocessor">#undef</span> <span class="identifier">BASES</span>

    <span class="comment">// BOOST_CONTRACT_OVERRIDE(_1) would generate reserved symbol `override__1`.</span>
    <span class="identifier">BOOST_CONTRACT_NAMED_OVERRIDE</span><span class="special">(</span><span class="identifier">override1</span><span class="special">,</span> <span class="identifier">_1</span><span class="special">)</span>

    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="identifier">_1</span><span class="special">(</span><span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">value</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">virtual_</span><span class="special">*</span> <span class="identifier">v</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span>
            <span class="comment">/* override */</span> <span class="special">{</span>
        <span class="comment">// Use `override1` type generated by NAMED_OVERRIDE macro above.</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">&lt;</span><span class="identifier">override1</span><span class="special">&gt;(</span>
            <span class="identifier">v</span><span class="special">,</span>
            <span class="keyword">static_cast</span><span class="special">&lt;</span><span class="keyword">void</span> <span class="special">(</span><span class="identifier">positive_unary_pack</span><span class="special">::*)(</span><span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;,</span>
                    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">virtual_</span><span class="special">*)&gt;(&amp;</span><span class="identifier">positive_unary_pack</span><span class="special">::</span><span class="identifier">_1</span><span class="special">),</span>
            <span class="keyword">this</span><span class="special">,</span>
            <span class="identifier">value</span>
        <span class="special">)</span>
            <span class="special">.</span><span class="identifier">precondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">value</span> <span class="special">&gt;</span> <span class="number">0</span><span class="special">);</span>
            <span class="special">})</span>
        <span class="special">;</span>
        <span class="identifier">value1_</span> <span class="special">=</span> <span class="identifier">value</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="comment">/* ... */</span>
</pre>
<p>
      </p>
<p>
        The <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_NAMED_OVERRIDE.html" title="Macro BOOST_CONTRACT_NAMED_OVERRIDE">BOOST_CONTRACT_NAMED_OVERRIDE</a></code>
        macro can be used for function names that start with an underscore <code class="computeroutput"><span class="identifier">_</span><span class="special">...</span></code>, when
        the name <code class="computeroutput"><span class="identifier">override_</span></code><code class="literal"><span class="emphasis"><em>function-name</em></span></code>
        generated by <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OVERRIDE.html" title="Macro BOOST_CONTRACT_OVERRIDE">BOOST_CONTRACT_OVERRIDE</a></code>
        would clash with other names in the user code, to generate names in CamelCase
        or any other style, in any other case when programmers need or want to generate
        names different than <code class="computeroutput"><span class="identifier">override_</span><span class="special">...</span></code>.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_contract.advanced_topics.move_operations"></a><a class="link" href="advanced_topics.html#boost_contract.advanced_topics.move_operations" title="Move Operations">Move
      Operations</a>
</h3></div></div></div>
<p>
        As with all public operations of a class, also move operations should maintain
        class invariants (see also <a class="link" href="bibliography.html#Stroustrup13_anchor">[Stroustrup13]</a>,
        p. 520). Specifically, C++ requires the following:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            The moved-from object can be copy assigned.
          </li>
<li class="listitem">
            The moved-from object can be move assigned.
          </li>
<li class="listitem">
            The moved-from object can be destroyed. <a href="#ftn.boost_contract.advanced_topics.move_operations.f0" class="footnote" name="boost_contract.advanced_topics.move_operations.f0"><sup class="footnote">[39]</sup></a>
          </li>
</ul></div>
<p>
        Thus both the move constructor and the move assignment operator need to maintain
        the class invariants of the moved-from object and their contracts can be
        programmed using <code class="computeroutput"><a class="link" href="../boost/contract/constructor.html" title="Function template constructor">boost::contract::constructor</a></code>
        and <code class="computeroutput"><a class="link" href="../boost/contract/public_function_id480248.html" title="Function template public_function">boost::contract::public_function</a></code>
        as always for constructors and public member functions, for example (see
        also <a href="../../../example/features/move.cpp" target="_top"><code class="literal">move.cpp</code></a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">circular_buffer</span> <span class="special">:</span>
        <span class="keyword">private</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">constructor_precondition</span><span class="special">&lt;</span><span class="identifier">circular_buffer</span><span class="special">&gt;</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">invariant</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span>
        <span class="keyword">if</span><span class="special">(!</span><span class="identifier">moved</span><span class="special">())</span> <span class="special">{</span> <span class="comment">// Do not check (some) invariants for moved-from objects.</span>
            <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">index</span><span class="special">()</span> <span class="special">&lt;</span> <span class="identifier">size</span><span class="special">());</span>
        <span class="special">}</span>
    <span class="special">}</span>

    <span class="keyword">explicit</span> <span class="identifier">circular_buffer</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">data</span><span class="special">,</span>
            <span class="keyword">unsigned</span> <span class="identifier">start</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="special">:</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">constructor_precondition</span><span class="special">&lt;</span><span class="identifier">circular_buffer</span><span class="special">&gt;([&amp;]</span> <span class="special">{</span>
            <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">start</span> <span class="special">&lt;</span> <span class="identifier">data</span><span class="special">.</span><span class="identifier">size</span><span class="special">());</span>
        <span class="special">}),</span>
        <span class="identifier">data_</span><span class="special">(</span><span class="identifier">data</span><span class="special">),</span>
        <span class="identifier">index_</span><span class="special">(</span><span class="identifier">start</span><span class="special">),</span>
        <span class="identifier">moved_</span><span class="special">(</span><span class="keyword">false</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">constructor</span><span class="special">(</span><span class="keyword">this</span><span class="special">)</span>
            <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(!</span><span class="identifier">moved</span><span class="special">());</span>
            <span class="special">})</span>
        <span class="special">;</span>
    <span class="special">}</span>

    <span class="special">~</span><span class="identifier">circular_buffer</span><span class="special">()</span> <span class="special">{</span>
        <span class="comment">// Moved-from can always be destroyed (so no pre `!moved()` here).</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">destructor</span><span class="special">(</span><span class="keyword">this</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="comment">// Copy constructor.</span>
    <span class="comment">/* implicit */</span> <span class="identifier">circular_buffer</span><span class="special">(</span><span class="identifier">circular_buffer</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="special">:</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">constructor_precondition</span><span class="special">&lt;</span><span class="identifier">circular_buffer</span><span class="special">&gt;([&amp;]</span> <span class="special">{</span>
            <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(!</span><span class="identifier">other</span><span class="special">.</span><span class="identifier">moved</span><span class="special">());</span>
        <span class="special">})</span>
    <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">constructor</span><span class="special">(</span><span class="keyword">this</span><span class="special">)</span>
            <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(!</span><span class="identifier">moved</span><span class="special">());</span>
            <span class="special">})</span>
        <span class="special">;</span>

        <span class="identifier">copy</span><span class="special">(</span><span class="identifier">other</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="comment">// Copy assignment.</span>
    <span class="identifier">circular_buffer</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">circular_buffer</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="special">{</span>
        <span class="comment">// Moved-from can be (copy) assigned (so no pre `!moved()` here).</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">(</span><span class="keyword">this</span><span class="special">)</span>
            <span class="special">.</span><span class="identifier">precondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(!</span><span class="identifier">other</span><span class="special">.</span><span class="identifier">moved</span><span class="special">());</span>
            <span class="special">})</span>
            <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(!</span><span class="identifier">moved</span><span class="special">());</span>
            <span class="special">})</span>
        <span class="special">;</span>

        <span class="keyword">return</span> <span class="identifier">copy</span><span class="special">(</span><span class="identifier">other</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="comment">// Move constructor.</span>
    <span class="comment">/* implicit */</span> <span class="identifier">circular_buffer</span><span class="special">(</span><span class="identifier">circular_buffer</span><span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="special">:</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">constructor_precondition</span><span class="special">&lt;</span><span class="identifier">circular_buffer</span><span class="special">&gt;([&amp;]</span> <span class="special">{</span>
            <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(!</span><span class="identifier">other</span><span class="special">.</span><span class="identifier">moved</span><span class="special">());</span>
        <span class="special">})</span>
    <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">constructor</span><span class="special">(</span><span class="keyword">this</span><span class="special">)</span>
            <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(!</span><span class="identifier">moved</span><span class="special">());</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">other</span><span class="special">.</span><span class="identifier">moved</span><span class="special">());</span>
            <span class="special">})</span>
        <span class="special">;</span>

        <span class="identifier">move</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">circular_buffer</span><span class="special">&gt;(</span><span class="identifier">other</span><span class="special">));</span>
    <span class="special">}</span>

    <span class="comment">// Move assignment.</span>
    <span class="identifier">circular_buffer</span><span class="special">&amp;</span> <span class="keyword">operator</span><span class="special">=(</span><span class="identifier">circular_buffer</span><span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="special">{</span>
        <span class="comment">// Moved-from can be (move) assigned (so no pre `!moved()` here).</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">(</span><span class="keyword">this</span><span class="special">)</span>
            <span class="special">.</span><span class="identifier">precondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(!</span><span class="identifier">other</span><span class="special">.</span><span class="identifier">moved</span><span class="special">());</span>
            <span class="special">})</span>
            <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(!</span><span class="identifier">moved</span><span class="special">());</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">other</span><span class="special">.</span><span class="identifier">moved</span><span class="special">());</span>
            <span class="special">})</span>
        <span class="special">;</span>

        <span class="keyword">return</span> <span class="identifier">move</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">forward</span><span class="special">&lt;</span><span class="identifier">circular_buffer</span><span class="special">&gt;(</span><span class="identifier">other</span><span class="special">));</span>
    <span class="special">}</span>

    <span class="keyword">char</span> <span class="identifier">read</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">(</span><span class="keyword">this</span><span class="special">)</span>
            <span class="special">.</span><span class="identifier">precondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(!</span><span class="identifier">moved</span><span class="special">());</span>
            <span class="special">})</span>
        <span class="special">;</span>

        <span class="keyword">unsigned</span> <span class="identifier">i</span> <span class="special">=</span> <span class="identifier">index_</span><span class="special">++;</span>
        <span class="keyword">if</span><span class="special">(</span><span class="identifier">index_</span> <span class="special">==</span> <span class="identifier">data_</span><span class="special">.</span><span class="identifier">size</span><span class="special">())</span> <span class="identifier">index_</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="comment">// Circular.</span>
        <span class="keyword">return</span> <span class="identifier">data_</span><span class="special">.</span><span class="identifier">at</span><span class="special">(</span><span class="identifier">i</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="keyword">bool</span> <span class="identifier">moved</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">(</span><span class="keyword">this</span><span class="special">);</span>
        <span class="keyword">return</span> <span class="identifier">moved_</span><span class="special">;</span>
    <span class="special">}</span>

<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">circular_buffer</span><span class="special">&amp;</span> <span class="identifier">copy</span><span class="special">(</span><span class="identifier">circular_buffer</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">data_</span> <span class="special">=</span> <span class="identifier">other</span><span class="special">.</span><span class="identifier">data_</span><span class="special">;</span>
        <span class="identifier">index_</span> <span class="special">=</span> <span class="identifier">other</span><span class="special">.</span><span class="identifier">index_</span><span class="special">;</span>
        <span class="identifier">moved_</span> <span class="special">=</span> <span class="keyword">false</span><span class="special">;</span>
        <span class="keyword">return</span> <span class="special">*</span><span class="keyword">this</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="identifier">circular_buffer</span><span class="special">&amp;</span> <span class="identifier">move</span><span class="special">(</span><span class="identifier">circular_buffer</span><span class="special">&amp;&amp;</span> <span class="identifier">other</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">data_</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">other</span><span class="special">.</span><span class="identifier">data_</span><span class="special">);</span>
        <span class="identifier">index_</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">other</span><span class="special">.</span><span class="identifier">index_</span><span class="special">);</span>
        <span class="identifier">moved_</span> <span class="special">=</span> <span class="keyword">false</span><span class="special">;</span>
        <span class="identifier">other</span><span class="special">.</span><span class="identifier">moved_</span> <span class="special">=</span> <span class="keyword">true</span><span class="special">;</span> <span class="comment">// Mark moved-from object.</span>
        <span class="keyword">return</span> <span class="special">*</span><span class="keyword">this</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span> <span class="identifier">data_</span><span class="special">;</span>
    <span class="keyword">unsigned</span> <span class="identifier">index_</span><span class="special">;</span>
    <span class="keyword">bool</span> <span class="identifier">moved_</span><span class="special">;</span>

    <span class="comment">/* ... */</span>
</pre>
<p>
      </p>
<p>
        This example assumes that it is possible to call the public member function
        <code class="computeroutput"><span class="identifier">move</span><span class="special">()</span></code>
        on the moved-from object. This allows to make explicit the precondition that
        except for destructor, copy and move assignments all other public member
        functions cannot be called on a moved-from object. This precondition is usually
        implicit in C++ (i.e., documented by the standard but not checked by the
        language at run-time). If it is is not possible (e.g., due to some optimized
        implementation of the move operations) to have such a public <code class="computeroutput"><span class="identifier">move</span><span class="special">()</span></code>
        member function, the private <code class="computeroutput"><span class="identifier">moved_</span></code>
        member (or similar) can be used to program class invariants and preconditions
        (and that will just relay on the usual implicit C++ assumption on moved-from
        object because users will not be able to fully check preconditions and class
        invariants before calling functions of a moved-from object).
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          The default move constructor and move assignment operator automatically
          generated by C++ will not check contracts. Therefore, unless these operations
          are not public or they have no preconditions, no postconditions, and the
          class has no invariants, programmers should manually define them using
          <code class="computeroutput"><a class="link" href="../boost/contract/constructor.html" title="Function template constructor">boost::contract::constructor</a></code>,
          <code class="computeroutput"><a class="link" href="../boost/contract/constructor_precondition.html" title="Class template constructor_precondition">boost::contract::constructor_precondition</a></code>,
          and <code class="computeroutput"><a class="link" href="../boost/contract/public_function_id480248.html" title="Function template public_function">boost::contract::public_function</a></code>.
          (Same for all other automatically generated operations.)
        </p></td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_contract.advanced_topics.unions"></a><a class="link" href="advanced_topics.html#boost_contract.advanced_topics.unions" title="Unions">Unions</a>
</h3></div></div></div>
<p>
        In C++, a <code class="computeroutput"><span class="keyword">union</span></code> cannot have
        virtual member functions, bases classes, and cannot be used as a base class
        thus subcontracting (<code class="computeroutput"><a class="link" href="../boost/contract/virtual_.html" title="Class virtual_">boost::contract::virtual_</a></code>,
        <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OVERRIDE.html" title="Macro BOOST_CONTRACT_OVERRIDE">BOOST_CONTRACT_OVERRIDE</a></code>,
        etc.) do not apply to unions. Also a <code class="computeroutput"><span class="keyword">union</span></code>
        cannot inherit from <code class="computeroutput"><a class="link" href="../boost/contract/constructor_precondition.html" title="Class template constructor_precondition">boost::contract::constructor_precondition</a></code>
        (because it cannot have base classes) so such a class is used to declare
        a local object that checks constructor preconditions (see <code class="computeroutput"><span class="identifier">pre</span></code>
        in the example below). A part from that, this library is used as usual to
        program contracts for unions, for example (see also <a href="../../../example/features/union.cpp" target="_top"><code class="literal">union.cpp</code></a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">union</span> <span class="identifier">positive</span> <span class="special">{</span>
    <span class="keyword">static</span> <span class="keyword">void</span> <span class="identifier">static_invariant</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">instances</span><span class="special">()</span> <span class="special">&gt;=</span> <span class="number">0</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="keyword">void</span> <span class="identifier">invariant</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span>
        <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">i_</span> <span class="special">&gt;</span> <span class="number">0</span><span class="special">);</span>
        <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">d_</span> <span class="special">&gt;</span> <span class="number">0</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="keyword">explicit</span> <span class="identifier">positive</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">x</span><span class="special">)</span> <span class="special">{</span>
        <span class="comment">// Unions cannot have bases so ctor preconditions here.</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">constructor_precondition</span><span class="special">&lt;</span><span class="identifier">positive</span><span class="special">&gt;</span> <span class="identifier">pre</span><span class="special">([&amp;]</span> <span class="special">{</span>
            <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">x</span> <span class="special">&gt;</span> <span class="number">0</span><span class="special">);</span>
        <span class="special">});</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">old_ptr</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">old_instances</span> <span class="special">=</span>
                <span class="identifier">BOOST_CONTRACT_OLDOF</span><span class="special">(</span><span class="identifier">instances</span><span class="special">());</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">constructor</span><span class="special">(</span><span class="keyword">this</span><span class="special">)</span>
            <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">instances</span><span class="special">()</span> <span class="special">==</span> <span class="special">*</span><span class="identifier">old_instances</span> <span class="special">+</span> <span class="number">1</span><span class="special">);</span>
            <span class="special">})</span>
        <span class="special">;</span>

        <span class="identifier">i_</span> <span class="special">=</span> <span class="identifier">x</span><span class="special">;</span>
        <span class="special">++</span><span class="identifier">instances_</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="keyword">explicit</span> <span class="identifier">positive</span><span class="special">(</span><span class="keyword">double</span> <span class="identifier">x</span><span class="special">)</span> <span class="special">{</span>
        <span class="comment">// Unions cannot have bases so ctor preconditions here.</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">constructor_precondition</span><span class="special">&lt;</span><span class="identifier">positive</span><span class="special">&gt;</span> <span class="identifier">pre</span><span class="special">([&amp;]</span> <span class="special">{</span>
            <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">x</span> <span class="special">&gt;</span> <span class="number">0</span><span class="special">);</span>
        <span class="special">});</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">old_ptr</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">old_instances</span> <span class="special">=</span>
                <span class="identifier">BOOST_CONTRACT_OLDOF</span><span class="special">(</span><span class="identifier">instances</span><span class="special">());</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">constructor</span><span class="special">(</span><span class="keyword">this</span><span class="special">)</span>
            <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">instances</span><span class="special">()</span> <span class="special">==</span> <span class="special">*</span><span class="identifier">old_instances</span> <span class="special">+</span> <span class="number">1</span><span class="special">);</span>
            <span class="special">})</span>
        <span class="special">;</span>

        <span class="identifier">d_</span> <span class="special">=</span> <span class="identifier">x</span><span class="special">;</span>
        <span class="special">++</span><span class="identifier">instances_</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="special">~</span><span class="identifier">positive</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">old_ptr</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">old_instances</span> <span class="special">=</span>
                <span class="identifier">BOOST_CONTRACT_OLDOF</span><span class="special">(</span><span class="identifier">instances</span><span class="special">());</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">destructor</span><span class="special">(</span><span class="keyword">this</span><span class="special">)</span>
            <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">instances</span><span class="special">()</span> <span class="special">==</span> <span class="special">*</span><span class="identifier">old_instances</span> <span class="special">-</span> <span class="number">1</span><span class="special">);</span>
            <span class="special">})</span>
        <span class="special">;</span>

        <span class="special">--</span><span class="identifier">instances_</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="keyword">void</span> <span class="identifier">get</span><span class="special">(</span><span class="keyword">int</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">(</span><span class="keyword">this</span><span class="special">)</span>
            <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">x</span> <span class="special">&gt;</span> <span class="number">0</span><span class="special">);</span>
            <span class="special">});</span>
        <span class="special">;</span>

        <span class="identifier">x</span> <span class="special">=</span> <span class="identifier">i_</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="keyword">void</span> <span class="identifier">get</span><span class="special">(</span><span class="keyword">double</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">(</span><span class="keyword">this</span><span class="special">)</span>
            <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">x</span> <span class="special">&gt;</span> <span class="number">0</span><span class="special">);</span>
            <span class="special">});</span>
        <span class="special">;</span>

        <span class="identifier">x</span> <span class="special">=</span> <span class="identifier">d_</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="keyword">static</span> <span class="keyword">int</span> <span class="identifier">instances</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">&lt;</span><span class="identifier">positive</span><span class="special">&gt;();</span>
        <span class="keyword">return</span> <span class="identifier">instances_</span><span class="special">;</span>
    <span class="special">}</span>

<span class="keyword">private</span><span class="special">:</span>
    <span class="keyword">int</span> <span class="identifier">i_</span><span class="special">;</span>
    <span class="keyword">double</span> <span class="identifier">d_</span><span class="special">;</span>

    <span class="comment">/* ... */</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_contract.advanced_topics.volatile_class_invariants"></a><a class="link" href="advanced_topics.html#boost_contract.advanced_topics.volatile_class_invariants" title="Volatile Class Invariants">Volatile
      Class Invariants</a>
</h3></div></div></div>
<p>
        This library allows to specify a different set of class invariants to be
        checked for public volatile member functions. These <span class="emphasis"><em>volatile class
        invariants</em></span> are programmed in a public member function <code class="computeroutput"><span class="keyword">const</span> <span class="keyword">volatile</span></code>
        qualified and named <code class="computeroutput"><span class="identifier">invariant</span></code>
        (see <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_INVARIANT.html" title="Macro BOOST_CONTRACT_INVARIANT">BOOST_CONTRACT_INVARIANT</a></code>
        to name the invariant function differently from <code class="computeroutput"><span class="identifier">invariant</span></code>
        and __Access__ to not have to declare it public).
      </p>
<p>
        In general, <code class="computeroutput"><span class="keyword">const</span> <span class="keyword">volatile</span></code>
        qualified invariants work the same as <code class="computeroutput"><span class="keyword">const</span></code>
        qualified invariant (see <a class="link" href="tutorial.html#boost_contract.tutorial.class_invariants" title="Class Invariants">Class
        Invariants</a>) with the only difference that <code class="computeroutput"><span class="keyword">volatile</span></code>
        and <code class="computeroutput"><span class="keyword">const</span> <span class="keyword">volatile</span></code>
        member functions check <code class="computeroutput"><span class="keyword">const</span> <span class="keyword">volatile</span></code> invariants while mutable (i.e., neither
        <code class="computeroutput"><span class="keyword">const</span></code> nor <code class="computeroutput"><span class="keyword">volatile</span></code>
        qualified) and <code class="computeroutput"><span class="keyword">const</span></code> member
        functions check <code class="computeroutput"><span class="keyword">const</span></code> invariants.
        A given class can specify both <code class="computeroutput"><span class="keyword">const</span>
        <span class="keyword">volatile</span></code> and <code class="computeroutput"><span class="keyword">const</span></code>
        qualified invariant member functions: <a href="#ftn.boost_contract.advanced_topics.volatile_class_invariants.f0" class="footnote" name="boost_contract.advanced_topics.volatile_class_invariants.f0"><sup class="footnote">[40]</sup></a>
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            Constructors check both <code class="computeroutput"><span class="keyword">const</span>
            <span class="keyword">volatile</span></code> and <code class="computeroutput"><span class="keyword">const</span></code>
            qualified invariants in that order (at exit if no exception is thrown).
          </li>
<li class="listitem">
            Destructors check both <code class="computeroutput"><span class="keyword">const</span> <span class="keyword">volatile</span></code> and <code class="computeroutput"><span class="keyword">const</span></code>
            qualified invariants (at entry).
          </li>
<li class="listitem">
            Both mutable and <code class="computeroutput"><span class="keyword">const</span></code> public
            member functions check <code class="computeroutput"><span class="keyword">const</span></code>
            qualified invariants (at entry and at exit if no exception is thrown).
          </li>
<li class="listitem">
            Both <code class="computeroutput"><span class="keyword">volatile</span></code> and <code class="computeroutput"><span class="keyword">const</span> <span class="keyword">volatile</span></code>
            public member functions check <code class="computeroutput"><span class="keyword">const</span>
            <span class="keyword">volatile</span></code> qualified invariants
            (at entry and at exit if no exception is thrown).
          </li>
</ul></div>
<p>
        This ensures that volatile class invariants are correctly checked (see also
        <a class="link" href="contract_programming_overview.html#boost_contract.contract_programming_overview.constructor_calls" title="Constructor Calls">Constructor
        Calls</a>, <a class="link" href="contract_programming_overview.html#boost_contract.contract_programming_overview.destructor_calls" title="Destructor Calls">Destructor
        Calls</a>, and <a class="link" href="contract_programming_overview.html#boost_contract.contract_programming_overview.public_function_calls" title="Public Function Calls">Public
        Function Calls</a>). For example (see also <a href="../../../example/features/volatile.cpp" target="_top"><code class="literal">volatile.cpp</code></a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">a</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">invariant</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">volatile</span><span class="special">;</span>    <span class="comment">// Invariants cv qualified.</span>
    <span class="keyword">void</span> <span class="identifier">invariant</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>             <span class="comment">// Invariants const qualified.</span>

    <span class="identifier">a</span><span class="special">()</span> <span class="special">{</span> <span class="comment">// Check both cv and const invariant (at exit if no throw).</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span><span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">constructor</span><span class="special">(</span><span class="keyword">this</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="special">~</span><span class="identifier">a</span><span class="special">()</span> <span class="special">{</span> <span class="comment">// Check both cv and const invariant (at entry).</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">destructor</span><span class="special">(</span><span class="keyword">this</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="keyword">void</span> <span class="identifier">m</span><span class="special">()</span> <span class="special">{</span> <span class="comment">// Check const invariant (at entry and exit if no throw).</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">(</span><span class="keyword">this</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="keyword">void</span> <span class="identifier">c</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span> <span class="comment">// Check const invariant (at entry and exit if no throw).</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">(</span><span class="keyword">this</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="keyword">void</span> <span class="identifier">v</span><span class="special">()</span> <span class="keyword">volatile</span> <span class="special">{</span> <span class="comment">// Check cv invariant (at entry and exit if no throw).</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">(</span><span class="keyword">this</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="keyword">void</span> <span class="identifier">cv</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">volatile</span> <span class="special">{</span> <span class="comment">// Check cv inv. (at entry and exit if no throw).</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">(</span><span class="keyword">this</span><span class="special">);</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
      </p>
<p>
        While this library does not automatically check <code class="computeroutput"><span class="keyword">const</span>
        <span class="keyword">volatile</span></code> invariants for non-volatile
        functions, programmers can explicitly call the <code class="computeroutput"><span class="keyword">const</span>
        <span class="keyword">volatile</span></code> invariant function from the
        <code class="computeroutput"><span class="keyword">const</span></code> invariant function if
        that makes sense for the contracts being specified (that way all public member
        functions <code class="computeroutput"><span class="keyword">volatile</span></code> and not will
        check <code class="computeroutput"><span class="keyword">const</span> <span class="keyword">volatile</span></code>
        invariants): <a href="#ftn.boost_contract.advanced_topics.volatile_class_invariants.f1" class="footnote" name="boost_contract.advanced_topics.volatile_class_invariants.f1"><sup class="footnote">[41]</sup></a>
      </p>
<pre class="programlisting"><span class="keyword">class</span> <code class="literal"><span class="emphasis"><em>class-type</em></span></code> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">invariant</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span>
        <code class="literal"><span class="emphasis"><em>class-type</em></span></code> <span class="keyword">const</span> <span class="keyword">volatile</span><span class="special">&amp;</span> <span class="identifier">cv</span> <span class="special">=</span> <span class="special">*</span><span class="keyword">this</span><span class="special">;</span>
        <span class="identifier">cv</span><span class="special">.</span><span class="identifier">invariant</span><span class="special">();</span> <span class="comment">// Call `void invariant() const volatile` below.</span>
        <span class="special">...</span>
    <span class="special">}</span>

    <span class="keyword">void</span> <span class="identifier">invariant</span><span class="special">()</span> <span class="keyword">const</span> <span class="keyword">volatile</span> <span class="special">{</span>
        <span class="special">...</span>
    <span class="special">}</span>

    <span class="special">...</span>
<span class="special">};</span>
</pre>
<p>
        As usual, static class invariants can also be specified (see <a class="link" href="tutorial.html#boost_contract.tutorial.class_invariants.static_class_invariants">Static
        Class Invariants</a>) and private and protected member functions do not
        check any invariant (see <a class="link" href="tutorial.html#boost_contract.tutorial.private_and_protected_functions" title="Private and Protected Functions">Private
        and Protected Functions</a>).
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_contract.advanced_topics.old_value_requirements"></a><a class="link" href="advanced_topics.html#boost_contract.advanced_topics.old_value_requirements" title="Old Value Requirements">Old
      Value Requirements</a>
</h3></div></div></div>
<p>
        Old values require copying the expression passed to <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OLDOF.html" title="Macro BOOST_CONTRACT_OLDOF">BOOST_CONTRACT_OLDOF</a></code>
        so the type of that expression must be copy constructible. More precisely,
        dereferencing an old value pointer of type <code class="computeroutput"><a class="link" href="../boost/contract/old_ptr.html" title="Class template old_ptr">boost::contract::old_ptr</a></code><code class="computeroutput"><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>
        requires <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">is_copy_constructible</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">value</span></code> to be <code class="computeroutput"><span class="keyword">true</span></code>
        (otherwise this library will generate a compile-time error).
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            In some cases it might be acceptable, or even desirable, to cause a compile-time
            error when a program uses old value types that are not copy constructible
            (because it is not possible to fully check the correctness of the program
            as stated by the contract assertions that use these old values). In these
            cases, programmers can declare old values using <code class="computeroutput"><a class="link" href="../boost/contract/old_ptr.html" title="Class template old_ptr">boost::contract::old_ptr</a></code>
            as seen so far (or equivalently using C++11 <code class="computeroutput"><span class="keyword">auto</span></code>
            declarations <code class="computeroutput"><span class="keyword">auto</span> <span class="special">...</span>
            <span class="special">=</span> <span class="identifier">BOOST_CONTRACT_OLDOF</span><span class="special">(...)</span></code>). <a href="#ftn.boost_contract.advanced_topics.old_value_requirements.f0" class="footnote" name="boost_contract.advanced_topics.old_value_requirements.f0"><sup class="footnote">[42]</sup></a>
          </li>
<li class="listitem">
            However, in other cases it might be desirable to simply not check assertions
            that use some old values when the related old value types are not copy
            constructible. Programmers can do this by using <code class="computeroutput"><a class="link" href="../boost/contract/old_ptr_noncopyable.html" title="Class template old_ptr_noncopyable">boost::contract::old_ptr_noncopyable</a></code>
            instead of <code class="computeroutput"><a class="link" href="../boost/contract/old_ptr.html" title="Class template old_ptr">boost::contract::old_ptr</a></code>
            to program these old values (and by checking if the old value pointer
            is not null before dereferencing it in postconditions).
          </li>
</ul></div>
<p>
        For example, consider the following <code class="computeroutput"><span class="identifier">accumulate</span></code>
        function template that could in general be instantiated for types <code class="computeroutput"><span class="identifier">T</span></code> that are not copy constructible, that
        is when <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">is_copy_constructible</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">value</span></code> is <code class="computeroutput"><span class="keyword">false</span></code>
        (see also <a href="../../../example/features/old_noncopyable.cpp" target="_top"><code class="literal">noncopyable.cpp</code></a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">accumulate</span><span class="special">(</span><span class="identifier">T</span><span class="special">&amp;</span> <span class="identifier">total</span><span class="special">,</span> <span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span> <span class="special">{</span>
    <span class="comment">// No compiler error if T has no copy constructor...</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">old_ptr_noncopyable</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="identifier">old_total</span> <span class="special">=</span>
            <span class="identifier">BOOST_CONTRACT_OLDOF</span><span class="special">(</span><span class="identifier">total</span><span class="special">);</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">function</span><span class="special">()</span>
        <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
            <span class="comment">// ...but old value null if T has no copy constructor.</span>
            <span class="keyword">if</span><span class="special">(</span><span class="identifier">old_total</span><span class="special">)</span> <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">total</span> <span class="special">==</span> <span class="special">*</span><span class="identifier">old_total</span> <span class="special">+</span> <span class="identifier">x</span><span class="special">);</span>
        <span class="special">})</span>
    <span class="special">;</span>

    <span class="identifier">total</span> <span class="special">+=</span> <span class="identifier">x</span><span class="special">;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        The old value pointer <code class="computeroutput"><span class="identifier">old_total</span></code>
        is programmed using <code class="computeroutput"><a class="link" href="../boost/contract/old_ptr_noncopyable.html" title="Class template old_ptr_noncopyable">boost::contract::old_ptr_noncopyable</a></code>
        so if <code class="computeroutput"><span class="identifier">T</span></code> is not copy constructible
        then <code class="computeroutput"><span class="identifier">total</span></code> will simply not
        be copied and <code class="computeroutput"><span class="identifier">old_total</span></code> will
        be left as a null pointer (in these cases <code class="computeroutput"><span class="identifier">old_total</span></code>
        must be checked to be not null <code class="computeroutput"><span class="keyword">if</span><span class="special">(</span><span class="identifier">old_total</span><span class="special">)</span> <span class="special">...</span></code> before
        it can be dereferenced in the postconditions). If the above example used
        <code class="computeroutput"><a class="link" href="../boost/contract/old_ptr.html" title="Class template old_ptr">boost::contract::old_ptr</a></code>
        instead then the library would have generated a compile-time error if <code class="computeroutput"><span class="identifier">accumulate</span></code> is instantiated for types <code class="computeroutput"><span class="identifier">T</span></code> that are not copy constructible (but
        only if <code class="computeroutput"><span class="identifier">old_total</span></code> is actually
        dereferenced in the contract assertions somewhere <code class="computeroutput"><span class="special">*</span><span class="identifier">old_total</span> <span class="special">...</span></code>).
      </p>
<p>
        The <code class="computeroutput"><span class="special">...</span><span class="identifier">_noncopyable</span></code>
        postfix in the type name <code class="computeroutput"><a class="link" href="../boost/contract/old_ptr_noncopyable.html" title="Class template old_ptr_noncopyable">boost::contract::old_ptr_noncopyable</a></code><code class="computeroutput"><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>
        refers to the pointed type <code class="computeroutput"><span class="identifier">T</span></code>
        that may or not be copy constructible without causing a compile-time error
        in this case (the old value pointer itself is always copyable, or at least
        copy assignable).
      </p>
<h5>
<a name="boost_contract.advanced_topics.old_value_requirements.h0"></a>
        <span class="phrase"><a name="boost_contract.advanced_topics.old_value_requirements.no_c__11"></a></span><a class="link" href="advanced_topics.html#boost_contract.advanced_topics.old_value_requirements.no_c__11">No
        C++11</a>
      </h5>
<p>
        In general, the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">is_copy_constructible</span></code> type trait requires
        C++11 for full support. On non-C++11 compilers, it is possible to inherit
        the old value type from <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">noncopyable</span></code>,
        or use <code class="computeroutput"><span class="identifier">BOOST_MOVABLE_BUT_NOT_COPYABLE</span></code>,
        or explicitly specialize the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">is_copy_constructible</span></code>
        template (see <a href="http://www.boost.org/doc/libs/release/libs/type_traits/doc/html/boost_typetraits/reference/is_copy_constructible.html" target="_top">boost::is_copy_constrictible</a>
        for more information):
      </p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">type_traits</span><span class="special">/</span><span class="identifier">is_copy_constructible</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">namespace</span> <span class="identifier">boost</span> <span class="special">{</span>
    <span class="keyword">template</span><span class="special">&lt;&gt;</span>
    <span class="keyword">struct</span> <span class="identifier">is_copy_constructible</span><span class="special">&lt;</span><code class="literal"><span class="emphasis"><em>old-value-type</em></span></code><span class="special">&gt;</span> <span class="special">:</span> <span class="identifier">false_type</span> <span class="special">{};</span>
<span class="special">}</span>
</pre>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_contract.advanced_topics.assertion_requirements__static_if_"></a><a class="link" href="advanced_topics.html#boost_contract.advanced_topics.assertion_requirements__static_if_" title="Assertion Requirements (Static-If)">Assertion
      Requirements (Static-If)</a>
</h3></div></div></div>
<p>
        In general, assertions can introduce a new set of requirements on the types
        used by the program. Some of these type requirements might be necessary only
        to check the assertions and they would not be required by the program otherwise.
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            In some cases it might be acceptable, or even desirable, to cause a compile-time
            error when a program uses types that do not provide all the operations
            needed to check contract assertions (because it is not possible to fully
            check the correctness of the program as stated by the contracts). In
            these cases, programmers can specify contract assertions as we have seen
            so far, compilation will fail if user types do not provide all operations
            necessary to check the contracts.
          </li>
<li class="listitem">
            However, in other cases it might be desirable that adding contracts to
            a program does not alter its type requirements and that assertions are
            simply not checked when user types do not provide all the operations
            necessary to check them. Programmers can do this by using <code class="computeroutput"><a class="link" href="../boost/contract/check_if.html" title="Function template check_if">boost::contract::check_if</a></code>
            (and <code class="computeroutput"><a class="link" href="../boost/contract/check_if_c.html" title="Function template check_if_c">boost::contract::check_if_c</a></code>)
            within the contract assertions.
          </li>
</ul></div>
<p>
        For example, let's consider the following <code class="computeroutput"><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span></code>
        class template. This class template does not usually require that <code class="computeroutput"><span class="identifier">T</span></code> has an equality operator <code class="computeroutput"><span class="special">==</span></code> (it only requires <code class="computeroutput"><span class="identifier">T</span></code>
        to be copy constructible, see <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code>
        documentation). However, the contracts of the <code class="computeroutput"><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;::</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">value</span><span class="special">)</span></code>
        member function include a postcondition <code class="computeroutput"><span class="identifier">back</span><span class="special">()</span> <span class="special">==</span> <span class="identifier">value</span></code>
        which introduces the new requirement that <code class="computeroutput"><span class="identifier">T</span></code>
        must also have an equality operator <code class="computeroutput"><span class="special">==</span></code>.
        Programmers can specify this postcondition as usual <code class="computeroutput"><span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">back</span><span class="special">()</span>
        <span class="special">==</span> <span class="identifier">value</span><span class="special">)</span></code> an let the program fail to compile when
        users instantiate this template with a type <code class="computeroutput"><span class="identifier">T</span></code>
        that does not provide an equality operator <code class="computeroutput"><span class="special">==</span></code>.
        Otherwise, programmers can specify this postcondition using <code class="computeroutput"><a class="link" href="../boost/contract/check_if.html" title="Function template check_if">boost::contract::check_if</a></code>
        to check the assertion only for types <code class="computeroutput"><span class="identifier">T</span></code>
        that have an equality operator <code class="computeroutput"><span class="special">==</span></code>
        and trivially check <code class="computeroutput"><span class="keyword">true</span></code> otherwise,
        for example (see also <a href="../../../example/features/check_if.cpp" target="_top"><code class="literal">check_if.cpp</code></a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">vector</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">push_back</span><span class="special">(</span><span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">value</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">(</span><span class="keyword">this</span><span class="special">)</span>
            <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
                <span class="comment">// Instead of `ASSERT(back() == value)` to handle T no `==`.</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span>
                    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">check_if</span><span class="special">&lt;</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">has_equal_to</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span> <span class="special">&gt;(</span>
                        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">equal_to</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;(),</span>
                            <span class="identifier">boost</span><span class="special">::</span><span class="identifier">cref</span><span class="special">(</span><span class="identifier">back</span><span class="special">()),</span>
                            <span class="identifier">boost</span><span class="special">::</span><span class="identifier">cref</span><span class="special">(</span><span class="identifier">value</span><span class="special">)</span>
                        <span class="special">)</span>
                    <span class="special">)</span>
                <span class="special">);</span>
            <span class="special">})</span>
        <span class="special">;</span>

        <span class="identifier">vect_</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">value</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="comment">/* ... */</span>
</pre>
<p>
      </p>
<p>
        The <code class="computeroutput"><a class="link" href="../boost/contract/check_if.html" title="Function template check_if">boost::contract::check_if</a></code>
        function template is a special case of the more general facility <code class="computeroutput"><a class="link" href="../boost/contract/call_if.html" title="Function template call_if">boost::contract::call_if</a></code>: Specifically,
        <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">check_if</span><span class="special">&lt;</span></code><code class="literal"><span class="emphasis"><em>condition</em></span></code><code class="computeroutput"><span class="special">&gt;(</span></code><code class="literal"><span class="emphasis"><em>check</em></span></code><code class="computeroutput"><span class="special">)</span></code> is equivalent to:
      </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">call_if</span><span class="special">&lt;</span><code class="literal"><span class="emphasis"><em>condition</em></span></code><span class="special">&gt;(</span>
    <code class="literal"><span class="emphasis"><em>check</em></span></code>
<span class="special">).</span><span class="identifier">else_</span><span class="special">(</span>
    <span class="special">[]</span> <span class="special">{</span> <span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span> <span class="special">}</span>
<span class="special">)</span>
</pre>
<p>
        Where <code class="literal"><span class="emphasis"><em>condition</em></span></code> is a nullary boolean
        meta-function and <code class="literal"><span class="emphasis"><em>check</em></span></code> is a nullary
        boolean functor. If <code class="literal"><span class="emphasis"><em>condition</em></span></code><code class="computeroutput"><span class="special">::</span><span class="identifier">value</span></code>
        is statically evaluated to be <code class="computeroutput"><span class="keyword">true</span></code>
        at compile-time then <code class="literal"><span class="emphasis"><em>check</em></span></code><code class="computeroutput"><span class="special">()</span></code> is called at run-time and its boolean result
        is returned by the enclosing <code class="computeroutput"><span class="identifier">call_if</span></code>.
        Otherwise, if <code class="literal"><span class="emphasis"><em>condition</em></span></code><code class="computeroutput"><span class="special">::</span><span class="identifier">value</span></code>
        is statically evaluated to be <code class="computeroutput"><span class="keyword">false</span></code>
        at compile-time then <code class="computeroutput"><span class="special">[]</span> <span class="special">{</span>
        <span class="keyword">return</span> <span class="keyword">true</span><span class="special">;</span> <span class="special">}()</span></code> is called
        at run-time and <code class="computeroutput"><span class="keyword">true</span></code> is trivially
        returned by the enclosing <code class="computeroutput"><span class="identifier">call_if</span></code>.
        Note that <code class="literal"><span class="emphasis"><em>check</em></span></code> must be a functor
        template (and not just a functor) so its code that contains the assertion
        operations with the extra type requirements (e.g., the operator <code class="computeroutput"><span class="special">==</span></code>) will not be instantiated and compiled
        for specific types unless the compiler determines it will be actually called
        at run-time (C++14 generic lambdas and functor templates like <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">equal_to</span></code>
        can be used to program <code class="literal"><span class="emphasis"><em>check</em></span></code>, but
        C++11 lambdas cannot).
      </p>
<p>
        More in general, <code class="computeroutput"><a class="link" href="../boost/contract/call_if.html" title="Function template call_if">boost::contract::call_if</a></code>
        accepts a number of optional else-if and one optional else statement:
      </p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">call_if</span><span class="special">&lt;</span><code class="literal"><span class="emphasis"><em>condition1</em></span></code><span class="special">&gt;(</span>
    <code class="literal"><span class="emphasis"><em>then1</em></span></code>
<span class="special">).</span><span class="keyword">template</span> <span class="identifier">else_if</span><span class="special">&lt;</span><code class="literal"><span class="emphasis"><em>condition2</em></span></code><span class="special">&gt;(</span>       <span class="comment">// Optional.</span>
    <code class="literal"><span class="emphasis"><em>then2</em></span></code>
<span class="special">)</span>
<span class="special">...</span>                                   <span class="comment">// Optionally, other `else_if`.</span>
<span class="special">.</span><span class="identifier">else_</span><span class="special">(</span>                               <span class="comment">// Optional for `void` functors, otherwise required.</span>
    <code class="literal"><span class="emphasis"><em>else</em></span></code>
<span class="special">)</span>
</pre>
<p>
        Where <code class="literal"><span class="emphasis"><em>condition1</em></span></code>, <code class="literal"><span class="emphasis"><em>condition2</em></span></code>,
        ... are nullary boolean meta-functions and <code class="literal"><span class="emphasis"><em>then1</em></span></code>,
        <code class="literal"><span class="emphasis"><em>then2</em></span></code>, ..., <code class="literal"><span class="emphasis"><em>else</em></span></code>
        are nullary functors. The return types of the functor calls <code class="literal"><span class="emphasis"><em>then1</em></span></code><code class="computeroutput"><span class="special">()</span></code>, <code class="literal"><span class="emphasis"><em>then2</em></span></code><code class="computeroutput"><span class="special">()</span></code>, ..., <code class="literal"><span class="emphasis"><em>esle</em></span></code><code class="computeroutput"><span class="special">()</span></code> must either all be the same (possibly all
        <code class="computeroutput"><span class="keyword">void</span></code>) or be of types implicitly
        convertible into one another. At run-time <code class="computeroutput"><a class="link" href="../boost/contract/call_if.html" title="Function template call_if">boost::contract::call_if</a></code>
        will call the functor <code class="literal"><span class="emphasis"><em>then1</em></span></code><code class="computeroutput"><span class="special">()</span></code>, or <code class="literal"><span class="emphasis"><em>then2</em></span></code><code class="computeroutput"><span class="special">()</span></code>, ..., or <code class="literal"><span class="emphasis"><em>else</em></span></code><code class="computeroutput"><span class="special">()</span></code> depending on which meta-function <code class="literal"><span class="emphasis"><em>condition1</em></span></code><code class="computeroutput"><span class="special">::</span><span class="identifier">value</span></code>,
        <code class="literal"><span class="emphasis"><em>condition2</em></span></code><code class="computeroutput"><span class="special">::</span><span class="identifier">value</span></code>, ... is evaluated to be <code class="computeroutput"><span class="keyword">true</span></code> or <code class="computeroutput"><span class="keyword">false</span></code>
        at compile-time, at it will return the value returned by the functor being
        called If <code class="literal"><span class="emphasis"><em>then1</em></span></code>, <code class="literal"><span class="emphasis"><em>then2</em></span></code>,
        ..., <code class="literal"><span class="emphasis"><em>else</em></span></code> are nullary functor templates
        (not just nullary functors) then their code will only be compiled if the
        compiler determines they need to be actually called at run-time (so only
        if the related <code class="literal"><span class="emphasis"><em>condition1</em></span></code><code class="computeroutput"><span class="special">::</span><span class="identifier">value</span></code>,
        <code class="literal"><span class="emphasis"><em>condition2</em></span></code><code class="computeroutput"><span class="special">::</span><span class="identifier">value</span></code>, ... are evaluated to be <code class="computeroutput"><span class="keyword">true</span></code> or <code class="computeroutput"><span class="keyword">false</span></code>
        at compile-time). All the <code class="computeroutput"><span class="identifier">esle_if</span><span class="special">&lt;...&gt;(...)</span></code> statements are optional,
        the <code class="computeroutput"><span class="identifier">else_</span><span class="special">(...)</span></code>
        statement is optional if the functor calls return <code class="computeroutput"><span class="keyword">void</span></code>
        but it is required otherwise.
      </p>
<p>
        In general, <code class="computeroutput"><a class="link" href="../boost/contract/call_if.html" title="Function template call_if">boost::contract::call_if</a></code>
        can be used to program contract assertions that compile and check different
        functor templates depending on related conditions being evaluated to be
        <code class="computeroutput"><span class="keyword">true</span></code> at compile-time (but in
        most cases <code class="computeroutput"><a class="link" href="../boost/contract/check_if.html" title="Function template check_if">boost::contract::check_if</a></code>
        should be sufficient, simpler and less verbose to use).
      </p>
<p>
        The <code class="computeroutput"><a class="link" href="../boost/contract/check_if_c.html" title="Function template check_if_c">boost::contract::check_if_c</a></code>,
        <code class="computeroutput"><a class="link" href="../boost/contract/call_if_c.html" title="Function template call_if_c">boost::contract::call_if_c</a></code>,
        and <code class="computeroutput"><span class="special">.</span><span class="identifier">else_if_c</span></code>
        function templates work similarly to their counterparts without the <code class="computeroutput"><span class="special">...</span><span class="identifier">_c</span></code> postfix
        above, but they take their condition template parameters as static boolean
        values instead of nullary boolean meta-functions.
      </p>
<h5>
<a name="boost_contract.advanced_topics.assertion_requirements__static_if_.h0"></a>
        <span class="phrase"><a name="boost_contract.advanced_topics.assertion_requirements__static_if_.static_if__c__14_"></a></span><a class="link" href="advanced_topics.html#boost_contract.advanced_topics.assertion_requirements__static_if_.static_if__c__14_">Static-If
        (C++14)</a>
      </h5>
<p>
        The <code class="computeroutput"><a class="link" href="../boost/contract/call_if.html" title="Function template call_if">boost::contract::call_if</a></code>
        function template is a general facility and its use is not limited to programming
        contracts. In fact, <code class="computeroutput"><a class="link" href="../boost/contract/call_if.html" title="Function template call_if">boost::contract::call_if</a></code>
        can be used together with C++14 generic lambdas to program statements similar
        to the <code class="computeroutput"><span class="keyword">static</span> <span class="keyword">if</span></code>
        proposal (at least at function scope, see also <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3613.pdf" target="_top">N3613</a>).
        For example, consider the following implementation of <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">advance</span></code>
        that uses <code class="computeroutput"><span class="keyword">static</span> <span class="keyword">if</span></code>-like
        statements programmed via <code class="computeroutput"><a class="link" href="../boost/contract/call_if.html" title="Function template call_if">boost::contract::call_if</a></code>
        (see also <a href="../../../test/call_if/advance_cxx14.cpp" target="_top"><code class="literal">advance_cxx14.cpp</code></a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Iter</span><span class="special">,</span> <span class="keyword">typename</span> <span class="identifier">Dist</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">myadvance</span><span class="special">(</span><span class="identifier">Iter</span><span class="special">&amp;</span> <span class="identifier">i</span><span class="special">,</span> <span class="identifier">Dist</span> <span class="identifier">n</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">Iter</span> <span class="special">*</span><span class="identifier">p</span> <span class="special">=</span> <span class="special">&amp;</span><span class="identifier">i</span><span class="special">;</span> <span class="comment">// So captures change actual pointed iterator value.</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">call_if</span><span class="special">&lt;</span><span class="identifier">is_random_access_iterator</span><span class="special">&lt;</span><span class="identifier">Iter</span><span class="special">&gt;</span> <span class="special">&gt;(</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">bind</span><span class="special">([]</span> <span class="special">(</span><span class="keyword">auto</span> <span class="identifier">p</span><span class="special">,</span> <span class="keyword">auto</span> <span class="identifier">n</span><span class="special">)</span> <span class="special">{</span> <span class="comment">// C++14 generic lambda.</span>
            <span class="identifier">out</span> <span class="special">&lt;&lt;</span> <span class="string">"random iterator"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
            <span class="special">*</span><span class="identifier">p</span> <span class="special">+=</span> <span class="identifier">n</span><span class="special">;</span>
        <span class="special">},</span> <span class="identifier">p</span><span class="special">,</span> <span class="identifier">n</span><span class="special">)</span>
    <span class="special">).</span><span class="keyword">template</span> <span class="identifier">else_if</span><span class="special">&lt;</span><span class="identifier">is_bidirectional_iterator</span><span class="special">&lt;</span><span class="identifier">Iter</span><span class="special">&gt;</span> <span class="special">&gt;(</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">bind</span><span class="special">([]</span> <span class="special">(</span><span class="keyword">auto</span> <span class="identifier">p</span><span class="special">,</span> <span class="keyword">auto</span> <span class="identifier">n</span><span class="special">)</span> <span class="special">{</span>
            <span class="identifier">out</span> <span class="special">&lt;&lt;</span> <span class="string">"bidirectional iterator"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
            <span class="keyword">if</span><span class="special">(</span><span class="identifier">n</span> <span class="special">&gt;=</span> <span class="number">0</span><span class="special">)</span> <span class="keyword">while</span><span class="special">(</span><span class="identifier">n</span><span class="special">--)</span> <span class="special">++*</span><span class="identifier">p</span><span class="special">;</span>
            <span class="keyword">else</span> <span class="keyword">while</span><span class="special">(</span><span class="identifier">n</span><span class="special">++)</span> <span class="special">--*</span><span class="identifier">p</span><span class="special">;</span>
        <span class="special">},</span> <span class="identifier">p</span><span class="special">,</span> <span class="identifier">n</span><span class="special">)</span>
    <span class="special">).</span><span class="keyword">template</span> <span class="identifier">else_if</span><span class="special">&lt;</span><span class="identifier">is_input_iterator</span><span class="special">&lt;</span><span class="identifier">Iter</span><span class="special">&gt;</span> <span class="special">&gt;(</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">bind</span><span class="special">([]</span> <span class="special">(</span><span class="keyword">auto</span> <span class="identifier">p</span><span class="special">,</span> <span class="keyword">auto</span> <span class="identifier">n</span><span class="special">)</span> <span class="special">{</span>
            <span class="identifier">out</span> <span class="special">&lt;&lt;</span> <span class="string">"input iterator"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
            <span class="keyword">while</span><span class="special">(</span><span class="identifier">n</span><span class="special">--)</span> <span class="special">++*</span><span class="identifier">p</span><span class="special">;</span>
        <span class="special">},</span> <span class="identifier">p</span><span class="special">,</span> <span class="identifier">n</span><span class="special">)</span>
    <span class="special">).</span><span class="identifier">else_</span><span class="special">(</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">bind</span><span class="special">([]</span> <span class="special">(</span><span class="keyword">auto</span> <span class="identifier">false_</span><span class="special">)</span> <span class="special">{</span>
            <span class="keyword">static_assert</span><span class="special">(</span><span class="identifier">false_</span><span class="special">,</span> <span class="string">"requires input iter"</span><span class="special">);</span>
        <span class="special">},</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">false_type</span><span class="special">())</span> <span class="comment">// Use constexpr value.</span>
    <span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        This implementation is much more concise, easy to read and maintain than
        the usual implementation of <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">advance</span></code>
        that uses tag dispatching. <a href="#ftn.boost_contract.advanced_topics.assertion_requirements__static_if_.f0" class="footnote" name="boost_contract.advanced_topics.assertion_requirements__static_if_.f0"><sup class="footnote">[43]</sup></a>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_contract.advanced_topics.access_specifiers"></a><a class="link" href="advanced_topics.html#boost_contract.advanced_topics.access_specifiers" title="Access Specifiers">Access
      Specifiers</a>
</h3></div></div></div>
<p>
        As seen so far, programmers are required to decorate their classes declaring
        extra members that are internally used by this library to check contracts:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            The <code class="computeroutput"><span class="identifier">invariant</span></code> and <code class="computeroutput"><span class="identifier">static_invariant</span></code> member functions (used
            to check class invariants, see also <a class="link" href="tutorial.html#boost_contract.tutorial.class_invariants" title="Class Invariants">Class
            Invariants</a>).
          </li>
<li class="listitem">
            The <code class="computeroutput"><span class="identifier">base_types</span></code> member
            type declared via <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_BASE_TYPES.html" title="Macro BOOST_CONTRACT_BASE_TYPES">BOOST_CONTRACT_BASE_TYPES</a></code>
            (used to implement subcontracting, see also <a class="link" href="tutorial.html#boost_contract.tutorial.public_function_overrides__subcontracting_" title="Public Function Overrides (Subcontracting)">Public
            Function Overrides</a>).
          </li>
<li class="listitem">
            The <code class="computeroutput"><span class="identifier">override_</span><span class="special">...</span></code>
            member types declared via <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OVERRIDE.html" title="Macro BOOST_CONTRACT_OVERRIDE">BOOST_CONTRACT_OVERRIDE</a></code>,
            <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_NAMED_OVERRIDE.html" title="Macro BOOST_CONTRACT_NAMED_OVERRIDE">BOOST_CONTRACT_NAMED_OVERRIDE</a></code>,
            and <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OVERRIDES.html" title="Macro BOOST_CONTRACT_OVERRIDES">BOOST_CONTRACT_OVERRIDES</a></code>
            (used to implement subcontracting for overriding functions, see also
            <a class="link" href="tutorial.html#boost_contract.tutorial.public_function_overrides__subcontracting_" title="Public Function Overrides (Subcontracting)">Public
            Function Overrides</a>). <a href="#ftn.boost_contract.advanced_topics.access_specifiers.f0" class="footnote" name="boost_contract.advanced_topics.access_specifiers.f0"><sup class="footnote">[44]</sup></a>
          </li>
</ul></div>
<p>
        In general, these members must be declared <code class="computeroutput"><span class="keyword">public</span></code>
        in the user class in order for this library to access them. <a href="#ftn.boost_contract.advanced_topics.access_specifiers.f1" class="footnote" name="boost_contract.advanced_topics.access_specifiers.f1"><sup class="footnote">[45]</sup></a> However, programmers might need to more precisely control the
        public members of their classes to prevent incorrect access of encapsulated
        members. All these members can be declared <code class="computeroutput"><span class="keyword">private</span></code>
        as long as the <code class="computeroutput"><a class="link" href="../boost/contract/access.html" title="Class access">boost::contract::access</a></code>
        class is declared as <code class="computeroutput"><span class="keyword">friend</span></code>,
        for example (see also <a href="../../../example/features/access.cpp" target="_top"><code class="literal">access.cpp</code></a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">vector</span>
    <span class="preprocessor">#define</span> <span class="identifier">BASES</span> <span class="keyword">public</span> <span class="identifier">pushable</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">&gt;</span>
    <span class="special">:</span> <span class="identifier">BASES</span>
<span class="special">{</span>
<span class="keyword">private</span><span class="special">:</span>
    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">access</span><span class="special">;</span> <span class="comment">// Friend `access` class so...</span>

    <span class="keyword">typedef</span> <span class="identifier">BOOST_CONTRACT_BASE_TYPES</span><span class="special">(</span><span class="identifier">BASES</span><span class="special">)</span> <span class="identifier">base_types</span><span class="special">;</span> <span class="comment">// ...private bases.</span>
    <span class="preprocessor">#undef</span> <span class="identifier">BASES</span>

    <span class="identifier">BOOST_CONTRACT_OVERRIDE</span><span class="special">(</span><span class="identifier">push_back</span><span class="special">)</span> <span class="comment">// ..private overrides.</span>

    <span class="keyword">void</span> <span class="identifier">invariant</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span> <span class="comment">// ...private invariants.</span>
        <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">size</span><span class="special">()</span> <span class="special">&lt;=</span> <span class="identifier">capacity</span><span class="special">());</span>
    <span class="special">}</span>

<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">push_back</span><span class="special">(</span><span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">value</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">virtual_</span><span class="special">*</span> <span class="identifier">v</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span>
            <span class="comment">/* override */</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">old_ptr</span><span class="special">&lt;</span><span class="keyword">unsigned</span><span class="special">&gt;</span> <span class="identifier">old_size</span> <span class="special">=</span>
                <span class="identifier">BOOST_CONTRACT_OLDOF</span><span class="special">(</span><span class="identifier">v</span><span class="special">,</span> <span class="identifier">size</span><span class="special">());</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">&lt;</span>
                <span class="identifier">override_push_back</span><span class="special">&gt;(</span><span class="identifier">v</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">vector</span><span class="special">::</span><span class="identifier">push_back</span><span class="special">,</span> <span class="keyword">this</span><span class="special">,</span> <span class="identifier">value</span><span class="special">)</span>
            <span class="special">.</span><span class="identifier">precondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">size</span><span class="special">()</span> <span class="special">&lt;</span> <span class="identifier">max_size</span><span class="special">());</span>
            <span class="special">})</span>
            <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">size</span><span class="special">()</span> <span class="special">==</span> <span class="special">*</span><span class="identifier">old_size</span> <span class="special">+</span> <span class="number">1</span><span class="special">);</span>
            <span class="special">})</span>
        <span class="special">;</span>

        <span class="identifier">vect_</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">value</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="comment">/* ... */</span>
</pre>
<p>
      </p>
<p>
        This technique is not used in most examples of this documentation only for
        brevity, but programmers are encouraged to use it in real code.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_contract.advanced_topics.separate_body_implementation"></a><a class="link" href="advanced_topics.html#boost_contract.advanced_topics.separate_body_implementation" title="Separate Body Implementation">Separate
      Body Implementation</a>
</h3></div></div></div>
<p>
        Contracts are part of the program specification and not of its implementation
        (see also <a class="link" href="contract_programming_overview.html#boost_contract.contract_programming_overview.specification_and_implementation" title="Specification and Implementation">Specification
        and Implementation</a>). However, this library uses function definitions
        to program the contracts so contract code appears together with the function
        implementation code. This is not ideal, but contract code programmed with
        this library must always appear at the very top of the function definition
        so programmers will easily be able to distinguish it from the rest of function
        implementation code (so this might not be real problem in practise).
      </p>
<p>
        In some cases, it might be desirable to completely separate the contract
        code (function specification) from the function body code (function implementation).
        For example, this could be necessary for software that ships only header
        files and pre-compiled source code to its users (notably, that cannot be
        done for template code in C++). If the contracts are programmed in the function
        definitions that are pre-compiled with the source code, users will not be
        able to inspect the contract code to understand semantics and usage of the
        functions (again, this might not be a real problem in practice for example
        if contract code is already somehow extracted from the source code and presented
        as part of the documentation of the shipped software).
      </p>
<p>
        In such cases, the function implementation can be programmed in an extra
        <span class="emphasis"><em>body function</em></span> (e.g., named <code class="computeroutput"><span class="special">...</span><span class="identifier">_body</span></code>) that is defined in the source code.
        The original function definition remains in the header files instead, it
        programs the contract and simply calls the extra body function. At the cost
        of programmers writing an extra function declaration for the body function,
        this technique allows to keep the contract code in header files while separating
        the body implementation code to source files (with the limitation that constructor
        member initialization lists must still be programmed in the header files
        because that is where the constructors are actually defined).
      </p>
<p>
        For example, the following header file only contains function declarations
        and contract code (function specifications) and constructor member initializations
        (see also <a href="../../../example/features/separate_body.hpp" target="_top"><code class="literal">separate_body.hpp</code></a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="identifier">MaxSize</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">array</span> <span class="special">:</span>
        <span class="keyword">private</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">constructor_precondition</span><span class="special">&lt;</span><span class="identifier">array</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">MaxSize</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">invariant</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span>
        <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">size</span><span class="special">()</span> <span class="special">&lt;=</span> <span class="identifier">MaxSize</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="keyword">explicit</span> <span class="identifier">array</span><span class="special">(</span><span class="keyword">unsigned</span> <span class="identifier">count</span><span class="special">)</span> <span class="special">:</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">constructor_precondition</span><span class="special">&lt;</span><span class="identifier">array</span><span class="special">&gt;([&amp;]</span> <span class="special">{</span>
            <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">count</span> <span class="special">&lt;=</span> <span class="identifier">MaxSize</span><span class="special">);</span>
        <span class="special">}),</span>
        <span class="identifier">values_</span><span class="special">(</span><span class="keyword">new</span> <span class="identifier">T</span><span class="special">[</span><span class="identifier">MaxSize</span><span class="special">])</span> <span class="comment">// Still, member initializations must be here.</span>
    <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">constructor</span><span class="special">(</span><span class="keyword">this</span><span class="special">)</span>
            <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">size</span><span class="special">()</span> <span class="special">==</span> <span class="identifier">count</span><span class="special">);</span>
            <span class="special">})</span>
        <span class="special">;</span>
        <span class="identifier">constructor_body</span><span class="special">(</span><span class="identifier">count</span><span class="special">);</span> <span class="comment">// Separate constructor body implementation.</span>
    <span class="special">}</span>

    <span class="keyword">virtual</span> <span class="special">~</span><span class="identifier">array</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">destructor</span><span class="special">(</span><span class="keyword">this</span><span class="special">);</span> <span class="comment">// Inv.</span>
        <span class="identifier">destructor_body</span><span class="special">();</span> <span class="comment">// Separate destructor body implementation.</span>
    <span class="special">}</span>

    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="identifier">push_back</span><span class="special">(</span><span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">value</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">virtual_</span><span class="special">*</span> <span class="identifier">v</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">old_ptr</span><span class="special">&lt;</span><span class="keyword">unsigned</span><span class="special">&gt;</span> <span class="identifier">old_size</span> <span class="special">=</span>
                <span class="identifier">BOOST_CONTRACT_OLDOF</span><span class="special">(</span><span class="identifier">v</span><span class="special">,</span> <span class="identifier">size</span><span class="special">());</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">(</span><span class="identifier">v</span><span class="special">,</span> <span class="keyword">this</span><span class="special">)</span>
            <span class="special">.</span><span class="identifier">precondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">size</span><span class="special">()</span> <span class="special">&lt;</span> <span class="identifier">MaxSize</span><span class="special">);</span>
            <span class="special">})</span>
            <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">size</span><span class="special">()</span> <span class="special">==</span> <span class="special">*</span><span class="identifier">old_size</span> <span class="special">+</span> <span class="number">1</span><span class="special">);</span>
            <span class="special">})</span>
        <span class="special">;</span>
        <span class="identifier">push_back_body</span><span class="special">(</span><span class="identifier">value</span><span class="special">);</span>
    <span class="special">}</span>

<span class="keyword">private</span><span class="special">:</span>
    <span class="comment">// Contracts in class declaration (above), but body implementations are not.</span>
    <span class="keyword">void</span> <span class="identifier">constructor_body</span><span class="special">(</span><span class="keyword">unsigned</span> <span class="identifier">count</span><span class="special">);</span>
    <span class="keyword">void</span> <span class="identifier">destructor_body</span><span class="special">();</span>
    <span class="keyword">void</span> <span class="identifier">push_back_body</span><span class="special">(</span><span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">value</span><span class="special">);</span>

    <span class="comment">/* ... */</span>
</pre>
<p>
      </p>
<p>
        Instead, the function bodies (function implementations) is programmed in
        a separate source file (see also <a href="../../../example/features/separate_body.cpp" target="_top"><code class="literal">separate_body.cpp</code></a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="identifier">MaxSize</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">array</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">MaxSize</span><span class="special">&gt;::</span><span class="identifier">constructor_body</span><span class="special">(</span><span class="keyword">unsigned</span> <span class="identifier">count</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">for</span><span class="special">(</span><span class="keyword">unsigned</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="identifier">count</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span> <span class="identifier">values_</span><span class="special">[</span><span class="identifier">i</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">T</span><span class="special">();</span>
    <span class="identifier">size_</span> <span class="special">=</span> <span class="identifier">count</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="identifier">MaxSize</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">array</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">MaxSize</span><span class="special">&gt;::</span><span class="identifier">destructor_body</span><span class="special">()</span> <span class="special">{</span> <span class="keyword">delete</span><span class="special">[]</span> <span class="identifier">values_</span><span class="special">;</span> <span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="identifier">MaxSize</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">array</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">MaxSize</span><span class="special">&gt;::</span><span class="identifier">push_back_body</span><span class="special">(</span><span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">value</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">values_</span><span class="special">[</span><span class="identifier">size_</span><span class="special">++]</span> <span class="special">=</span> <span class="identifier">value</span><span class="special">;</span>
<span class="special">}</span>

<span class="comment">/* ... */</span>
</pre>
<p>
      </p>
<p>
        The same technique can be used for non-member, private, and protected functions.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
<p>
          When contracts are programmed in a separate <code class="literal">.cpp</code> files
          and also <span class="emphasis"><em>all</em></span> these library headers are <code class="computeroutput"><span class="preprocessor">#include</span></code>d only from <code class="literal">.cpp</code>
          files, then the <code class="literal">.cpp</code> files can be compiled disabling
          specific contract checking (for example, <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_NO_POSTCONDITIONS.html" title="Macro BOOST_CONTRACT_NO_POSTCONDITIONS">BOOST_CONTRACT_NO_POSTCONDITIONS</a></code>
          and <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_NO_EXIT_INVARIANTS.html" title="Macro BOOST_CONTRACT_NO_EXIT_INVARIANTS">BOOST_CONTRACT_NO_EXIT_INVARIANTS</a></code>,
          see <a class="link" href="advanced_topics.html#boost_contract.advanced_topics.disable_contract_checking" title="Disable Contract Checking">Disable
          Contract Checking</a>). The user code that will link to these <code class="literal">.cpp</code>
          files not be able to Then the code in these <code class="literal">.cpp</code> files
          will always have such contract checking disabled even when linked to some
          other user code that might have been compiled with a different set of disable
          contracts (i.e., a different <code class="computeroutput"><span class="identifier">BOOST_CONTRACT_NO_</span><span class="special">...</span></code> defined). This technique might be useful
          to ship a pre-compiled set of object files (e.g., for a library) that will
          never check some contracts (e.g., postconditions and exit invariants) regardless
          of the definition of the <code class="computeroutput"><span class="identifier">BOOST_CONTRACT_NO_</span><span class="special">...</span></code> macros used to compile code that uses
          such object files.
        </p>
<p>
          On the contrary, if contracts are programmed in header files and this library
          headers are <code class="computeroutput"><span class="preprocessor">#include</span></code>d
          in header files that are being shipped, then end users enable or disables
          contracts of the shipped code by defining <code class="computeroutput"><span class="identifier">BOOST_CONTRACT_NO_</span><span class="special">...</span></code> when they compiled the shipped header
          files as part of their code. This technique might be useful in other situations
          when programmers that ship code want instead to leave it up the their end
          users to decide which contracts in the shipped code should be checked at
          run-time.
        </p>
</td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_contract.advanced_topics.throw_on_failure"></a><a class="link" href="advanced_topics.html#boost_contract.advanced_topics.throw_on_failure" title="Throw on Failure">Throw
      on Failure</a>
</h3></div></div></div>
<p>
        If a condition checked using <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_ASSERT.html" title="Macro BOOST_CONTRACT_ASSERT">BOOST_CONTRACT_ASSERT</a></code>
        is <code class="computeroutput"><span class="keyword">false</span></code> or if code specified
        in preconditions, postconditions, and class invariants throws an exception,
        this library calls the <span class="emphasis"><em>contract failure handler</em></span> functions
        <code class="computeroutput">boost::contract::precondition_failure</code>,
        <code class="computeroutput">boost::contract::postcondition_failure</code>,
        <code class="computeroutput">boost::contract::entry_invariant_failure</code>,
        or <code class="computeroutput">boost::contract::exit_invariant_failure</code>
        respectively (in fact, <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_ASSERT.html" title="Macro BOOST_CONTRACT_ASSERT">BOOST_CONTRACT_ASSERT</a></code>
        simply expands to code that throws a <code class="computeroutput">boost::contract::assertion_failure</code>
        exception, see also <a class="link" href="advanced_topics.html#boost_contract.advanced_topics.no_macros__no_c__11_" title="No Macros (No C++11)">No
        Macros</a>).
      </p>
<p>
        By default, the contract failure handler functions print a message to the
        standard error <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">cerr</span></code> and then terminate the program calling
        <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">terminate</span></code>. <a href="#ftn.boost_contract.advanced_topics.throw_on_failure.f0" class="footnote" name="boost_contract.advanced_topics.throw_on_failure.f0"><sup class="footnote">[46]</sup></a> However, programmers can override the default contract failure
        handlers to perform any custom action on contract failure using <code class="computeroutput">boost::contract::set_precondition_failure</code>,
        <code class="computeroutput">boost::contract::set_postcondition_failure</code>,
        <code class="computeroutput">boost::contract::set_entry_invariant_failure</code>,
        <code class="computeroutput">boost::contract::set_exit_invariant_failure</code>,
        <code class="computeroutput">boost::contract::set_invariant_failure</code>
        (to set both entry and exit invariant failure handlers at once for convenience),
        or <code class="computeroutput">boost::contract::set_failure</code>
        (to set all failure handlers at once for convenience). For example (see also
        <a href="../../../example/features/throw_on_failure.cpp" target="_top"><code class="literal">throw_on_failure.cpp</code></a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">void</span> <span class="identifier">throwing_handler</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">from</span> <span class="identifier">context</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">if</span><span class="special">(</span><span class="identifier">context</span> <span class="special">==</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">from_destructor</span><span class="special">)</span> <span class="special">{</span>
        <span class="comment">// Ignore exception because destructors should never throw.</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">clog</span> <span class="special">&lt;&lt;</span> <span class="string">"destructor contract failed (ignored)"</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span>
    <span class="special">}</span> <span class="keyword">else</span> <span class="keyword">throw</span><span class="special">;</span> <span class="comment">// Re-throw (assertion_failure, too_large_error, etc.).</span>
<span class="special">}</span>

<span class="keyword">int</span> <span class="identifier">main</span><span class="special">()</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">set_failure</span><span class="special">(&amp;</span><span class="identifier">throwing_handler</span><span class="special">);</span>

    <span class="comment">/* ... */</span>
</pre>
<p>
      </p>
<p>
        Note that in order to comply with C++ and STL exception safety rules, destructors
        should never throw. This library passes a <code class="computeroutput">boost::contract::from</code>
        parameter to the contract failure handler functions that indicates if the
        contract failure occurred in a destructor, constructor, or function call.
        This way programmers can ensure to never throw from a destructor call (in
        the example above, contract failures from destructors are simply ignored
        even if that is probably never a safe thing to do in real code). <a href="#ftn.boost_contract.advanced_topics.throw_on_failure.f1" class="footnote" name="boost_contract.advanced_topics.throw_on_failure.f1"><sup class="footnote">[47]</sup></a>
      </p>
<p>
        The contract assertions can be programmed to throw <code class="computeroutput">boost::contract::assertion_failure</code>
        using <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_ASSERT.html" title="Macro BOOST_CONTRACT_ASSERT">BOOST_CONTRACT_ASSERT</a></code>
        (see also <a class="link" href="advanced_topics.html#boost_contract.advanced_topics.no_macros__no_c__11_" title="No Macros (No C++11)">No
        Macros</a>) or to throw any other exception using code similar to:
      </p>
<pre class="programlisting"><span class="keyword">if</span><span class="special">(</span><code class="literal"><span class="emphasis"><em>error-condition</em></span></code><span class="special">)</span> <span class="keyword">throw</span> <code class="literal"><span class="emphasis"><em>exception-object</em></span></code><span class="special">;</span>
</pre>
<p>
        For example (see also <a href="../../../example/features/throw_on_failure.cpp" target="_top"><code class="literal">throw_on_failure.cpp</code></a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">too_large_error</span> <span class="special">{};</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">MaxSize</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">cstring</span>
    <span class="preprocessor">#define</span> <span class="identifier">BASES</span> <span class="keyword">private</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">constructor_precondition</span><span class="special">&lt;</span><span class="identifier">cstring</span><span class="special">&lt;</span> <span class="special">\</span>
            <span class="identifier">MaxSize</span><span class="special">&gt;</span> <span class="special">&gt;</span>
    <span class="special">:</span> <span class="identifier">BASES</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">typedef</span> <span class="identifier">BOOST_CONTRACT_BASE_TYPES</span><span class="special">(</span><span class="identifier">BASES</span><span class="special">)</span> <span class="identifier">base_types</span><span class="special">;</span>
    <span class="preprocessor">#undef</span> <span class="identifier">BASES</span>

    <span class="comment">/* implicit */</span> <span class="identifier">cstring</span><span class="special">(</span><span class="keyword">char</span> <span class="keyword">const</span><span class="special">*</span> <span class="identifier">chars</span><span class="special">)</span> <span class="special">:</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">constructor_precondition</span><span class="special">&lt;</span><span class="identifier">cstring</span><span class="special">&gt;([&amp;]</span> <span class="special">{</span>
            <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">chars</span><span class="special">);</span> <span class="comment">// Throw `assertion_failure`.</span>
            <span class="comment">// Or, throw user-defined exception.</span>
            <span class="keyword">if</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">strlen</span><span class="special">(</span><span class="identifier">chars</span><span class="special">)</span> <span class="special">&gt;</span> <span class="identifier">MaxSize</span><span class="special">)</span> <span class="keyword">throw</span> <span class="identifier">too_large_error</span><span class="special">();</span>
        <span class="special">})</span>
    <span class="special">{</span>

        <span class="comment">/* ... */</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_contract.advanced_topics.disable_contract_checking"></a><a class="link" href="advanced_topics.html#boost_contract.advanced_topics.disable_contract_checking" title="Disable Contract Checking">Disable
      Contract Checking</a>
</h3></div></div></div>
<p>
        Checking contracts adds run-time overhead and can slow down program execution
        (see also <a class="link" href="contract_programming_overview.html#boost_contract.contract_programming_overview.benefits_and_costs" title="Benefits and Costs">Benefits
        and Costs</a>). Therefore, programmers can define the following macros
        (<code class="computeroutput"><span class="special">-</span><span class="identifier">D</span></code>
        option in Clang and GCC, <code class="computeroutput"><span class="special">/</span><span class="identifier">D</span></code>
        option in MSVC, etc.) to instruct this library to not check specific set
        of contracts at run-time: <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_NO_PRECONDITIONS.html" title="Macro BOOST_CONTRACT_NO_PRECONDITIONS">BOOST_CONTRACT_NO_PRECONDITIONS</a></code>
        (do not check preconditions), <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_NO_POSTCONDITIONS.html" title="Macro BOOST_CONTRACT_NO_POSTCONDITIONS">BOOST_CONTRACT_NO_POSTCONDITIONS</a></code>
        (do not check postconditions), <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_NO_ENTRY_INVARIANTS.html" title="Macro BOOST_CONTRACT_NO_ENTRY_INVARIANTS">BOOST_CONTRACT_NO_ENTRY_INVARIANTS</a></code>
        (do not check invariants at call entry), <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_NO_EXIT_INVARIANTS.html" title="Macro BOOST_CONTRACT_NO_EXIT_INVARIANTS">BOOST_CONTRACT_NO_EXIT_INVARIANTS</a></code>
        (do not check invariants at call exit), and <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_NO_INVARIANTS.html" title="Macro BOOST_CONTRACT_NO_INVARIANTS">BOOST_CONTRACT_NO_INVARIANTS</a></code>
        (do not check invariants at both call entry and exit). By default, none of
        these macros are defined so this library checks all contracts.
      </p>
<p>
        For example, programmers could decide to check all contracts during early
        development builds, but later check only preconditions and maybe entry invariants
        for release builds by defining <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_NO_POSTCONDITIONS.html" title="Macro BOOST_CONTRACT_NO_POSTCONDITIONS">BOOST_CONTRACT_NO_POSTCONDITIONS</a></code>
        and <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_NO_EXIT_INVARIANTS.html" title="Macro BOOST_CONTRACT_NO_EXIT_INVARIANTS">BOOST_CONTRACT_NO_EXIT_INVARIANTS</a></code>.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_contract.advanced_topics.disable_contract_compilation"></a><a class="link" href="advanced_topics.html#boost_contract.advanced_topics.disable_contract_compilation" title="Disable Contract Compilation">Disable
      Contract Compilation</a>
</h3></div></div></div>
<p>
        This library provides macros that can be used to disable compile-time overhead
        introduced by contracts but at the cost of manually programming <code class="computeroutput"><span class="preprocessor">#ifdef</span></code> statements around contract code.
        The authors of this library do not recommend to use this practice unless
        strictly necessary because it makes the contract code more verbose, less
        readable, and in most applications the compile-time overhead of contracts
        should not represent an issue (it should be sufficient to disable contract
        checking at run-time as indicated before).
      </p>
<p>
        In any case, the following example illustrates how to completely disable
        contract code compilation for non-member functions (see also <a href="../../../example/features/ifdef.cpp" target="_top"><code class="literal">ifdef.cpp</code></a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="preprocessor">#ifndef</span> <span class="identifier">BOOST_CONTRACT_NO_ALL</span>
    <span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">contract</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>
<span class="preprocessor">#endif</span>

<span class="keyword">int</span> <span class="identifier">inc</span><span class="special">(</span><span class="keyword">int</span><span class="special">&amp;</span> <span class="identifier">x</span><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">int</span> <span class="identifier">result</span><span class="special">;</span>
    <span class="preprocessor">#ifndef</span> <span class="identifier">BOOST_CONTRACT_NO_POSTCONDITIONS</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">old_ptr</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">old_x</span> <span class="special">=</span> <span class="identifier">BOOST_CONTRACT_OLDOF</span><span class="special">(</span><span class="identifier">x</span><span class="special">);</span>
    <span class="preprocessor">#endif</span>
    <span class="preprocessor">#ifndef</span> <span class="identifier">BOOST_CONTRACT_NO_FUNCTIONS</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">function</span><span class="special">()</span>
            <span class="preprocessor">#ifndef</span> <span class="identifier">BOOST_CONTRACT_NO_PRECONDITIONS</span>
                <span class="special">.</span><span class="identifier">precondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
                    <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">x</span> <span class="special">&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">numeric_limits</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;::</span><span class="identifier">max</span><span class="special">());</span>
                <span class="special">})</span>
            <span class="preprocessor">#endif</span>
            <span class="preprocessor">#ifndef</span> <span class="identifier">BOOST_CONTRACT_NO_POSTCONDITIONS</span>
                <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
                    <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">x</span> <span class="special">==</span> <span class="special">*</span><span class="identifier">old_x</span> <span class="special">+</span> <span class="number">1</span><span class="special">);</span>
                    <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">result</span> <span class="special">==</span> <span class="special">*</span><span class="identifier">old_x</span><span class="special">);</span>
                <span class="special">})</span>
            <span class="preprocessor">#endif</span>
        <span class="special">;</span>
    <span class="preprocessor">#endif</span>

    <span class="keyword">return</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">x</span><span class="special">++;</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        The same is done to disable contract code complication for private and protected
        functions. For constructors, destructors, and public functions instead (see
        also <a href="../../../example/features/ifdef.cpp" target="_top"><code class="literal">ifdef.cpp</code></a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">integers</span>
    <span class="preprocessor">#define</span> <span class="identifier">BASES</span> <span class="keyword">public</span> <span class="identifier">pushable</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span>
    <span class="special">:</span>
        <span class="preprocessor">#ifndef</span> <span class="identifier">BOOST_CONTRACT_NO_PRECONDITONS</span>
            <span class="keyword">private</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">constructor_precondition</span><span class="special">&lt;</span><span class="identifier">integers</span><span class="special">&gt;,</span> <span class="identifier">BASES</span>
        <span class="preprocessor">#else</span>
            <span class="identifier">BASES</span>
        <span class="preprocessor">#endif</span>
<span class="special">{</span>
    <span class="preprocessor">#ifndef</span> <span class="identifier">BOOST_CONTRACT_NO_ALL</span>
        <span class="keyword">friend</span> <span class="keyword">class</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">access</span><span class="special">;</span>
    <span class="preprocessor">#endif</span>

    <span class="preprocessor">#ifndef</span> <span class="identifier">BOOST_CONTRACT_NO_PUBLIC_FUNCTIONS</span>
        <span class="keyword">typedef</span> <span class="identifier">BOOST_CONTRACT_BASE_TYPES</span><span class="special">(</span><span class="identifier">BASES</span><span class="special">)</span> <span class="identifier">base_types</span><span class="special">;</span>
    <span class="preprocessor">#endif</span>
    <span class="preprocessor">#undef</span> <span class="identifier">BASES</span>

    <span class="preprocessor">#ifndef</span> <span class="identifier">BOOST_CONTRACT_NO_INVARIANTS</span>
        <span class="keyword">void</span> <span class="identifier">invariant</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span>
            <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">size</span><span class="special">()</span> <span class="special">&lt;=</span> <span class="identifier">capacity</span><span class="special">());</span>
        <span class="special">}</span>
    <span class="preprocessor">#endif</span>

<span class="keyword">public</span><span class="special">:</span>
    <span class="identifier">integers</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">from</span><span class="special">,</span> <span class="keyword">int</span> <span class="identifier">to</span><span class="special">)</span> <span class="special">:</span>
        <span class="preprocessor">#ifndef</span> <span class="identifier">BOOST_CONTRACT_NO_PRECONDITIONS</span>
            <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">constructor_precondition</span><span class="special">&lt;</span><span class="identifier">integers</span><span class="special">&gt;([&amp;]</span> <span class="special">{</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">from</span> <span class="special">&lt;=</span> <span class="identifier">to</span><span class="special">);</span>
            <span class="special">})</span>
            <span class="special">,</span>
        <span class="preprocessor">#endif</span>
        <span class="identifier">vect_</span><span class="special">(</span><span class="identifier">to</span> <span class="special">-</span> <span class="identifier">from</span> <span class="special">+</span> <span class="number">1</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="preprocessor">#ifndef</span> <span class="identifier">BOOST_CONTRACT_NO_CONSTRUCTORS</span>
            <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">constructor</span><span class="special">(</span><span class="keyword">this</span><span class="special">)</span>
                <span class="preprocessor">#ifndef</span> <span class="identifier">BOOST_CONTRACT_NO_POSTCONDITIONS</span>
                    <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
                        <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="keyword">int</span><span class="special">(</span><span class="identifier">size</span><span class="special">())</span> <span class="special">==</span> <span class="special">(</span><span class="identifier">to</span> <span class="special">-</span> <span class="identifier">from</span> <span class="special">+</span> <span class="number">1</span><span class="special">));</span>
                    <span class="special">})</span>
                <span class="preprocessor">#endif</span>
            <span class="special">;</span>
        <span class="preprocessor">#endif</span>

        <span class="keyword">for</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">x</span> <span class="special">=</span> <span class="identifier">from</span><span class="special">;</span> <span class="identifier">x</span> <span class="special">&lt;=</span> <span class="identifier">to</span><span class="special">;</span> <span class="special">++</span><span class="identifier">x</span><span class="special">)</span> <span class="identifier">vect_</span><span class="special">.</span><span class="identifier">at</span><span class="special">(</span><span class="identifier">x</span> <span class="special">-</span> <span class="identifier">from</span><span class="special">)</span> <span class="special">=</span> <span class="identifier">x</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="keyword">virtual</span> <span class="special">~</span><span class="identifier">integers</span><span class="special">()</span> <span class="special">{</span>
        <span class="preprocessor">#ifndef</span> <span class="identifier">BOOST_CONTRACT_NO_DESTRUCTORS</span>
            <span class="comment">// Check invariants.</span>
            <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">destructor</span><span class="special">(</span><span class="keyword">this</span><span class="special">);</span>
        <span class="preprocessor">#endif</span>
    <span class="special">}</span>

    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="identifier">push_back</span><span class="special">(</span>
        <span class="keyword">int</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">x</span>
        <span class="preprocessor">#ifndef</span> <span class="identifier">BOOST_CONTRACT_NO_PUBLIC_FUNCTIONS</span>
            <span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">virtual_</span><span class="special">*</span> <span class="identifier">v</span> <span class="special">=</span> <span class="number">0</span>
        <span class="preprocessor">#endif</span>
    <span class="special">)</span> <span class="comment">/* override */</span> <span class="special">{</span>
        <span class="preprocessor">#ifndef</span> <span class="identifier">BOOST_CONTRACT_NO_POSTCONDITIONS</span>
            <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">old_ptr</span><span class="special">&lt;</span><span class="keyword">unsigned</span><span class="special">&gt;</span> <span class="identifier">old_size</span><span class="special">;</span>
        <span class="preprocessor">#endif</span>
        <span class="preprocessor">#ifndef</span> <span class="identifier">BOOST_CONTRACT_NO_PUBLIC_FUNCTIONS</span>
            <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">&lt;</span>
                    <span class="identifier">override_push_back</span><span class="special">&gt;(</span><span class="identifier">v</span><span class="special">,</span> <span class="special">&amp;</span><span class="identifier">integers</span><span class="special">::</span><span class="identifier">push_back</span><span class="special">,</span> <span class="keyword">this</span><span class="special">,</span> <span class="identifier">x</span><span class="special">)</span>
                <span class="preprocessor">#ifndef</span> <span class="identifier">BOOST_CONTRACT_NO_PRECONDITIONS</span>
                    <span class="special">.</span><span class="identifier">precondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
                        <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">size</span><span class="special">()</span> <span class="special">&lt;</span> <span class="identifier">max_size</span><span class="special">());</span>
                    <span class="special">})</span>
                <span class="preprocessor">#endif</span>
                <span class="preprocessor">#ifndef</span> <span class="identifier">BOOST_CONTRACT_NO_POSTCONDITIONS</span>
                    <span class="special">.</span><span class="identifier">old</span><span class="special">([&amp;]</span> <span class="special">{</span>
                        <span class="identifier">old_size</span> <span class="special">=</span> <span class="identifier">BOOST_CONTRACT_OLDOF</span><span class="special">(</span><span class="identifier">v</span><span class="special">,</span> <span class="identifier">size</span><span class="special">());</span>
                    <span class="special">})</span>
                    <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
                        <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">size</span><span class="special">()</span> <span class="special">==</span> <span class="special">*</span><span class="identifier">old_size</span> <span class="special">+</span> <span class="number">1</span><span class="special">);</span>
                    <span class="special">})</span>
                <span class="preprocessor">#endif</span>
            <span class="special">;</span>
        <span class="preprocessor">#endif</span>

        <span class="identifier">vect_</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">x</span><span class="special">);</span>
    <span class="special">}</span>

<span class="keyword">private</span><span class="special">:</span>
    <span class="preprocessor">#ifndef</span> <span class="identifier">BOOST_CONTRACT_NO_PUBLIC_FUNCTIONS</span>
        <span class="identifier">BOOST_CONTRACT_OVERRIDE</span><span class="special">(</span><span class="identifier">push_back</span><span class="special">)</span>
    <span class="preprocessor">#endif</span>

    <span class="comment">/* ... */</span>
</pre>
<p>
      </p>
<p>
        As shown by the examples above:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            The <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_NO_PRECONDITIONS.html" title="Macro BOOST_CONTRACT_NO_PRECONDITIONS">BOOST_CONTRACT_NO_PRECONDITIONS</a></code>
            macro is defined by programmers and it can be used in <code class="computeroutput"><span class="preprocessor">#ifdef</span></code>
            statements to disable compilation of preconditions, including constructor
            preconditions (<code class="computeroutput"><a class="link" href="../boost/contract/constructor_precondition.html" title="Class template constructor_precondition">boost::contract::constructor_precondition</a></code>).
          </li>
<li class="listitem">
            The <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_NO_POSTCONDITIONS.html" title="Macro BOOST_CONTRACT_NO_POSTCONDITIONS">BOOST_CONTRACT_NO_POSTCONDITIONS</a></code>
            macro is defined by programmers and it can be used in <code class="computeroutput"><span class="preprocessor">#ifdef</span></code>
            statements to disable compilation of postconditions, old value declarations,
            and old value assignments at body (<code class="computeroutput"><span class="special">.</span><span class="identifier">old</span><span class="special">(...)</span></code>).
          </li>
<li class="listitem">
            The <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_NO_INVARIANTS.html" title="Macro BOOST_CONTRACT_NO_INVARIANTS">BOOST_CONTRACT_NO_INVARIANTS</a></code>
            macro is defined by programmers (or it will be automatically defined
            by this library if both <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_NO_ENTRY_INVARIANTS.html" title="Macro BOOST_CONTRACT_NO_ENTRY_INVARIANTS">BOOST_CONTRACT_NO_ENTRY_INVARIANTS</a></code>
            and <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_NO_EXIT_INVARIANTS.html" title="Macro BOOST_CONTRACT_NO_EXIT_INVARIANTS">BOOST_CONTRACT_NO_EXIT_INVARIANTS</a></code>
            are defined) and it can be used in <code class="computeroutput"><span class="preprocessor">#ifdef</span></code>
            statements to disable compilation of class invariants (including static
            and volatile class invariants). Also the <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_NO_ENTRY_INVARIANTS.html" title="Macro BOOST_CONTRACT_NO_ENTRY_INVARIANTS">BOOST_CONTRACT_NO_ENTRY_INVARIANTS</a></code>
            and <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_NO_EXIT_INVARIANTS.html" title="Macro BOOST_CONTRACT_NO_EXIT_INVARIANTS">BOOST_CONTRACT_NO_EXIT_INVARIANTS</a></code>
            macros are defined by programmers (or they will be both automatically
            defined by this library if <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_NO_INVARIANTS.html" title="Macro BOOST_CONTRACT_NO_INVARIANTS">BOOST_CONTRACT_NO_INVARIANTS</a></code>
            is defined) but these macros are not directly used to disable contract
            code compilation (only contract code run-time checking).
          </li>
<li class="listitem">
            The <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_NO_CONSTRUCTORS.html" title="Macro BOOST_CONTRACT_NO_CONSTRUCTORS">BOOST_CONTRACT_NO_CONSTRUCTORS</a></code>
            macro is automatically defined by this library (a compile-time error
            will be reported if programmes try to manually define this macro) and
            it can be used in <code class="computeroutput"><span class="preprocessor">#ifdef</span></code>
            statements to disable compilation of constructor contract guards.
          </li>
<li class="listitem">
            The <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_NO_DESTRUCTORS.html" title="Macro BOOST_CONTRACT_NO_DESTRUCTORS">BOOST_CONTRACT_NO_DESTRUCTORS</a></code>
            macro is automatically defined by this library (a compile-time error
            will be reported if programmers try to manually define this macro) and
            it can be used in <code class="computeroutput"><span class="preprocessor">#ifdef</span></code>
            statements to disable compilation of destructor contract guards.
          </li>
<li class="listitem">
            The <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_NO_PUBLIC_FUNCTIONS.html" title="Macro BOOST_CONTRACT_NO_PUBLIC_FUNCTIONS">BOOST_CONTRACT_NO_PUBLIC_FUNCTIONS</a></code>
            macro is automatically defined by this library (a compile-time error
            will be reported if programmers try to manually define this macro) and
            it can be used in <code class="computeroutput"><span class="preprocessor">#ifdef</span></code>
            statements to disable compilation of public member function contract
            guards, base type <code class="computeroutput"><span class="keyword">typedef</span></code>,
            extra <code class="computeroutput"><a class="link" href="../boost/contract/virtual_.html" title="Class virtual_">boost::contract::virtual_</a></code>
            function parameters, and <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OVERRIDE.html" title="Macro BOOST_CONTRACT_OVERRIDE">BOOST_CONTRACT_OVERRIDE</a></code>
            declarations.
          </li>
<li class="listitem">
            The <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_NO_FUNCTIONS.html" title="Macro BOOST_CONTRACT_NO_FUNCTIONS">BOOST_CONTRACT_NO_FUNCTIONS</a></code>
            macro is automatically defined by this library (a compile-time error
            will be reported if programmers try to manually define this macro) and
            it can be used in <code class="computeroutput"><span class="preprocessor">#ifdef</span></code>
            statements to disable compilation of contract guards for non-member functions
            as well as private and protected functions.
          </li>
<li class="listitem">
            The <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_NO_ALL.html" title="Macro BOOST_CONTRACT_NO_ALL">BOOST_CONTRACT_NO_ALL</a></code>
            macro is automatically defined by this library (a compile-time error
            will be reported if programmers try to manually define this macro) and
            it can be used in <code class="computeroutput"><span class="preprocessor">#ifdef</span></code>
            statements to disable <code class="computeroutput"><a class="link" href="../boost/contract/access.html" title="Class access">boost::contract::access</a></code>
            friendship declarations and also inclusions of <code class="computeroutput"><a class="link" href="../reference.html#header.boost.contract_hpp" title="Header &lt;boost/contract.hpp&gt;">boost/contract.hpp</a></code>
            (some of the other macros listed here can be used to selectively disable
            inclusion of <code class="literal">boost/contract/*.hpp</code> headers when they
            are used instead of <code class="computeroutput"><a class="link" href="../reference.html#header.boost.contract_hpp" title="Header &lt;boost/contract.hpp&gt;">boost/contract.hpp</a></code>.)
          </li>
</ul></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_contract.advanced_topics.no_macros__no_c__11_"></a><a class="link" href="advanced_topics.html#boost_contract.advanced_topics.no_macros__no_c__11_" title="No Macros (No C++11)">No
      Macros (No C++11)</a>
</h3></div></div></div>
<p>
        It is possible to specify contracts without using this library macros and
        programming the related code manually instead (a part from <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OVERRIDE.html" title="Macro BOOST_CONTRACT_OVERRIDE">BOOST_CONTRACT_OVERRIDE</a></code>,
        <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OVERRIDES.html" title="Macro BOOST_CONTRACT_OVERRIDES">BOOST_CONTRACT_OVERRIDES</a></code>,
        and <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_NAMED_OVERRIDE.html" title="Macro BOOST_CONTRACT_NAMED_OVERRIDE">BOOST_CONTRACT_NAMED_OVERRIDE</a></code>
        that cannot be programmed manually).
      </p>
<p>
        Some of this library macros are variadic macros, others are not (see below).
        Variadic macros were officially added to the language since C++11 but most
        compilers have been supporting variadic macros as an extension for a long
        time, plus essentially all compilers that support C++11 lambda functions
        also support C++11 variadic macros (and this library might rarely be used
        without the convenience of C++11 lambda functions, see also <a class="link" href="advanced_topics.html#boost_contract.advanced_topics.no_lambda_functions__no_c__11_" title="No Lambda Functions (No C++11)">No
        Lambda Functions</a>). Therefore, the following can be considered mainly
        a curiosity because programmers should seldom need to use this library without
        using its macros.
      </p>
<h5>
<a name="boost_contract.advanced_topics.no_macros__no_c__11_.h0"></a>
        <span class="phrase"><a name="boost_contract.advanced_topics.no_macros__no_c__11_.overrides"></a></span><a class="link" href="advanced_topics.html#boost_contract.advanced_topics.no_macros__no_c__11_.overrides">Overrides</a>
      </h5>
<p>
        As shown in <a class="link" href="tutorial.html#boost_contract.tutorial.public_function_overrides__subcontracting_" title="Public Function Overrides (Subcontracting)">Public
        Function Overrides</a> and <a class="link" href="advanced_topics.html#boost_contract.advanced_topics.named_overrides" title="Named Overrides">Named
        Overrides</a>, this library provides the <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OVERRIDE.html" title="Macro BOOST_CONTRACT_OVERRIDE">BOOST_CONTRACT_OVERRIDE</a></code>
        and <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_NAMED_OVERRIDE.html" title="Macro BOOST_CONTRACT_NAMED_OVERRIDE">BOOST_CONTRACT_NAMED_OVERRIDE</a></code>
        macros to program contracts for overriding public functions. These macros
        cannot be programmed manually but they are not variadic macros so programmers
        should be able to use them on all C++ compilers. <a href="#ftn.boost_contract.advanced_topics.no_macros__no_c__11_.f0" class="footnote" name="boost_contract.advanced_topics.no_macros__no_c__11_.f0"><sup class="footnote">[48]</sup></a> The <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OVERRIDES.html" title="Macro BOOST_CONTRACT_OVERRIDES">BOOST_CONTRACT_OVERRIDES</a></code>
        macro is a variadic macro instead but programmes can manually repeat the
        non-variadic macro <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OVERRIDE.html" title="Macro BOOST_CONTRACT_OVERRIDE">BOOST_CONTRACT_OVERRIDE</a></code>
        for each overriding public function name on compilers that do not support
        variadic macros.
      </p>
<h5>
<a name="boost_contract.advanced_topics.no_macros__no_c__11_.h1"></a>
        <span class="phrase"><a name="boost_contract.advanced_topics.no_macros__no_c__11_.assertions__not_variadic_"></a></span><a class="link" href="advanced_topics.html#boost_contract.advanced_topics.no_macros__no_c__11_.assertions__not_variadic_">Assertions
        (Not Variadic)</a>
      </h5>
<p>
        As shown in <a class="link" href="tutorial.html#boost_contract.tutorial.preconditions" title="Preconditions">Preconditions</a>,
        <a class="link" href="tutorial.html#boost_contract.tutorial.postconditions" title="Postconditions">Postconditions</a>,
        <a class="link" href="tutorial.html#boost_contract.tutorial.class_invariants" title="Class Invariants">Class Invariants</a>,
        etc. this library provides the <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_ASSERT.html" title="Macro BOOST_CONTRACT_ASSERT">BOOST_CONTRACT_ASSERT</a></code>
        macro to assert contract conditions. This is not a variadic macro and programmers
        should be able to use it on all C++ compilers. However, the macro invocation
        <code class="computeroutput"><span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span></code><code class="literal"><span class="emphasis"><em>condition</em></span></code><code class="computeroutput"><span class="special">)</span></code> simply expands to code equivalent to the
        following:
      </p>
<pre class="programlisting"><span class="keyword">if</span><span class="special">(!</span><code class="literal"><span class="emphasis"><em>condition</em></span></code><span class="special">)</span> <span class="special">{</span>
    <span class="keyword">throw</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">assertion_failure</span><span class="special">(</span><span class="identifier">__FILE__</span><span class="special">,</span> <span class="identifier">__LINE__</span><span class="special">,</span>
            <span class="identifier">BOOST_PP_STRINGIZE</span><span class="special">(</span><code class="literal"><span class="emphasis"><em>condition</em></span></code><span class="special">));</span>
<span class="special">}</span>
</pre>
<p>
        That is because this library considers any exception thrown from within preconditions,
        postconditions, and class invariants as a contract failure and reports it
        calling the related contract failure handler (<code class="computeroutput">boost::contract::precondition_failure</code>,
        etc., see also <a class="link" href="advanced_topics.html#boost_contract.advanced_topics.throw_on_failure" title="Throw on Failure">Throw
        on Failure</a>). In fact, if there is a need for it, programmers can always
        program contract assertions that throw an exception as follow (see <a href="../../../example/features/throw_on_failure.cpp" target="_top"><code class="literal">throw_on_failure.cpp</code></a>
        for an example):
      </p>
<pre class="programlisting"><span class="keyword">if</span><span class="special">(!</span><code class="literal"><span class="emphasis"><em>condition</em></span></code><span class="special">)</span> <span class="keyword">throw</span> <code class="literal"><span class="emphasis"><em>exception-type</em></span></code><span class="special">(...);</span>
</pre>
<p>
        However, using <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_ASSERT.html" title="Macro BOOST_CONTRACT_ASSERT">BOOST_CONTRACT_ASSERT</a></code>
        always allows this library to show detailed information about the assertion
        code, its file and line number, etc.
      </p>
<h5>
<a name="boost_contract.advanced_topics.no_macros__no_c__11_.h2"></a>
        <span class="phrase"><a name="boost_contract.advanced_topics.no_macros__no_c__11_.base_types__variadic_"></a></span><a class="link" href="advanced_topics.html#boost_contract.advanced_topics.no_macros__no_c__11_.base_types__variadic_">Base
        Types (Variadic)</a>
      </h5>
<p>
        As shown in <a class="link" href="tutorial.html#boost_contract.tutorial.base_classes__subcontracting_" title="Base Classes (Subcontracting)">Base
        Classes</a>, this library provides the <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_BASE_TYPES.html" title="Macro BOOST_CONTRACT_BASE_TYPES">BOOST_CONTRACT_BASE_TYPES</a></code>
        variadic macro to declare the <code class="computeroutput"><span class="identifier">base_types</span></code>
        member type that lists all public bases of a derived class. Programmers can
        also declare <code class="computeroutput"><span class="identifier">base_types</span></code> without
        using <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_BASE_TYPES.html" title="Macro BOOST_CONTRACT_BASE_TYPES">BOOST_CONTRACT_BASE_TYPES</a></code>
        at the cost of writing a bit more code manually, for example (see also <a href="../../../example/features/base_types_no_macros.cpp" target="_top"><code class="literal">base_types_no_macros.cpp</code></a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">mpl</span><span class="special">/</span><span class="identifier">vector</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">class</span> <span class="identifier">chars</span> <span class="special">:</span>
    <span class="keyword">private</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">constructor_precondition</span><span class="special">&lt;</span><span class="identifier">chars</span><span class="special">&gt;,</span>
    <span class="keyword">public</span> <span class="identifier">unique_chars</span><span class="special">,</span>
    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="identifier">pushable</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;,</span>
    <span class="keyword">virtual</span> <span class="keyword">protected</span> <span class="identifier">has_size</span><span class="special">,</span>
    <span class="keyword">private</span> <span class="identifier">has_empty</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="comment">// Program `base_types` without macros (list only public bases).</span>
    <span class="keyword">typedef</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">unique_chars</span><span class="special">,</span> <span class="identifier">pushable</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="identifier">base_types</span><span class="special">;</span>

    <span class="comment">/* ... */</span>
</pre>
<p>
      </p>
<p>
        The <code class="computeroutput"><span class="identifier">base_types</span></code> member type
        must be a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">vector</span></code>
        and it must list <span class="emphasis"><em>only</em></span> <code class="computeroutput"><span class="keyword">public</span></code>
        base classes (because only public bases subcontract, see also <a class="link" href="contract_programming_overview.html#boost_contract.contract_programming_overview.function_calls" title="Function Calls">Function
        Calls</a>). If the <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_BASE_TYPES.html" title="Macro BOOST_CONTRACT_BASE_TYPES">BOOST_CONTRACT_BASE_TYPES</a></code>
        macro is not used, it is the responsibility of the programmers to maintain
        the correct list of bases in the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mpl</span><span class="special">::</span><span class="identifier">vector</span></code> each time the derived class inheritance
        list changes (this might complicate maintenance). In general, it is recommended
        to use the <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_BASE_TYPES.html" title="Macro BOOST_CONTRACT_BASE_TYPES">BOOST_CONTRACT_BASE_TYPES</a></code>
        macro if possible.
      </p>
<h5>
<a name="boost_contract.advanced_topics.no_macros__no_c__11_.h3"></a>
        <span class="phrase"><a name="boost_contract.advanced_topics.no_macros__no_c__11_.old_values__variadic_"></a></span><a class="link" href="advanced_topics.html#boost_contract.advanced_topics.no_macros__no_c__11_.old_values__variadic_">Old
        Values (Variadic)</a>
      </h5>
<p>
        As shown in <a class="link" href="tutorial.html#boost_contract.tutorial.old_values" title="Old Values">Old Values</a>,
        this library provides the <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OLDOF.html" title="Macro BOOST_CONTRACT_OLDOF">BOOST_CONTRACT_OLDOF</a></code>
        variadic macro to assign old value copies. Programmers can also assign old
        values without using <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OLDOF.html" title="Macro BOOST_CONTRACT_OLDOF">BOOST_CONTRACT_OLDOF</a></code>
        at the cost of writing a bit more code manually, for example (see also <a href="../../../example/features/old_no_macros.cpp" target="_top"><code class="literal">old_no_macros.cpp</code></a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">vector</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="identifier">push_back</span><span class="special">(</span><span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">value</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">virtual_</span><span class="special">*</span> <span class="identifier">v</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="special">{</span>
        <span class="comment">// Program old value instead of using `OLDOF(size())` macro.</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">old_ptr</span><span class="special">&lt;</span><span class="keyword">unsigned</span><span class="special">&gt;</span> <span class="identifier">old_size</span> <span class="special">=</span>
            <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">make_old</span><span class="special">(</span><span class="identifier">v</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">copy_old</span><span class="special">(</span><span class="identifier">v</span><span class="special">)</span> <span class="special">?</span>
                    <span class="identifier">size</span><span class="special">()</span> <span class="special">:</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">null_old</span><span class="special">())</span>
        <span class="special">;</span>

        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">(</span><span class="identifier">v</span><span class="special">,</span> <span class="keyword">this</span><span class="special">)</span>
            <span class="special">.</span><span class="identifier">postcondition</span><span class="special">([&amp;]</span> <span class="special">{</span>
                <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">size</span><span class="special">()</span> <span class="special">==</span> <span class="special">*</span><span class="identifier">old_size</span> <span class="special">+</span> <span class="number">1</span><span class="special">);</span>
            <span class="special">})</span>
        <span class="special">;</span>

        <span class="identifier">vect_</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">value</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="comment">/* ... */</span>
</pre>
<p>
      </p>
<p>
        The ternary operator <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">copy_old</span><span class="special">(</span><span class="identifier">v</span><span class="special">)</span>
        <span class="special">?</span> <span class="identifier">size</span><span class="special">()</span> <span class="special">:</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">null_old</span><span class="special">()</span></code> must be used here to avoid evaluating and
        copying the old value expression <code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code> when <code class="computeroutput"><a class="link" href="../boost/contract/copy_old_id479932.html" title="Function copy_old">boost::contract::copy_old</a></code>
        returns <code class="computeroutput"><span class="keyword">false</span></code> because old values
        are not being copied (postcondition checking is disable at run-time, an overridden
        virtual function call is not checking postconditions yet, etc.). The enclosing
        <code class="computeroutput"><a class="link" href="../boost/contract/make_old_id478623.html" title="Function make_old">boost::contract::make_old</a></code>
        copies the old value expression and creates an old value pointer, while
        <code class="computeroutput"><a class="link" href="../boost/contract/null_old.html" title="Function null_old">boost::contract::null_old</a></code>
        indicates when a null old value pointer should be created.
      </p>
<p>
        The <code class="computeroutput"><a class="link" href="../boost/contract/make_old_id478623.html" title="Function make_old">boost::contract::make_old</a></code>
        and <code class="computeroutput"><a class="link" href="../boost/contract/copy_old_id479932.html" title="Function copy_old">boost::contract::copy_old</a></code>
        functions are used exactly as above but without the extra <code class="computeroutput"><span class="identifier">v</span></code>
        parameter when they are called from within non-virtual functions (see also
        <a class="link" href="tutorial.html#boost_contract.tutorial.public_function_overrides__subcontracting_" title="Public Function Overrides (Subcontracting)">Public
        Function Overrides</a>). The old value pointer returned by <code class="computeroutput"><a class="link" href="../boost/contract/make_old_id478623.html" title="Function make_old">boost::contract::make_old</a></code>
        can be assigned to either <code class="computeroutput"><a class="link" href="../boost/contract/old_ptr.html" title="Class template old_ptr">boost::contract::old_ptr</a></code>
        or <code class="computeroutput">boost::contract::noncoyable_old_ptr</code>
        (see also <a class="link" href="advanced_topics.html#boost_contract.advanced_topics.old_value_requirements" title="Old Value Requirements">Old
        Value Requirements</a>).
      </p>
<p>
        In general, it is recommended to use the <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OLDOF.html" title="Macro BOOST_CONTRACT_OLDOF">BOOST_CONTRACT_OLDOF</a></code>
        macro if possible.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_contract.advanced_topics.no_lambda_functions__no_c__11_"></a><a class="link" href="advanced_topics.html#boost_contract.advanced_topics.no_lambda_functions__no_c__11_" title="No Lambda Functions (No C++11)">No
      Lambda Functions (No C++11)</a>
</h3></div></div></div>
<p>
        This section shows how to use this library without C++11 lambda functions.
        This has some advantages:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            It allows to use this library on compilers that do not support C++11
            lambda functions (essentially most C++03 compilers can be used, see
            <a class="link" href="advanced_topics.html#boost_contract.advanced_topics.no_macros__no_c__11_" title="No Macros (No C++11)">No
            Macros</a> to also avoid using variadic macros).
          </li>
<li class="listitem">
            Contract functions (see the <code class="computeroutput"><span class="special">...</span><span class="identifier">_precondition</span></code>, <code class="computeroutput"><span class="special">...</span><span class="identifier">_old</span></code>, and <code class="computeroutput"><span class="special">...</span><span class="identifier">_postcondition</span></code> functions in the example
            below) can be programmed to fully enforce constant-correctness and other
            contract requirements at compile-time (see also <a class="link" href="contract_programming_overview.html#boost_contract.contract_programming_overview.constant_correctness" title="Constant-Correctness">Constant-Correctness</a>).
            <a href="#ftn.boost_contract.advanced_topics.no_lambda_functions__no_c__11_.f0" class="footnote" name="boost_contract.advanced_topics.no_lambda_functions__no_c__11_.f0"><sup class="footnote">[49]</sup></a>
          </li>
<li class="listitem">
            Contracts are separated from function body implementations (see also
            <a class="link" href="contract_programming_overview.html#boost_contract.contract_programming_overview.specification_and_implementation" title="Specification and Implementation">Specification
            and Implementation</a> and <a class="link" href="advanced_topics.html#boost_contract.advanced_topics.separate_body_implementation" title="Separate Body Implementation">Separate
            Body Implementation</a>).
          </li>
</ul></div>
<p>
        However, not using C++11 lambda functions comes to the significant cost of
        having to manually write a great deal of extra code to program the contract
        functions, for example (see also <a href="../../../example/features/no_lambdas.hpp" target="_top"><code class="literal">no_lambdas.hpp</code></a>
        and <a href="../../../example/features/no_lambdas.cpp" target="_top"><code class="literal">no_lambdas.cpp</code></a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="identifier">MaxSize</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">array</span> <span class="special">:</span>
        <span class="keyword">private</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">constructor_precondition</span><span class="special">&lt;</span><span class="identifier">array</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">MaxSize</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">static</span> <span class="keyword">void</span> <span class="identifier">static_invariant</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">instances</span><span class="special">()</span> <span class="special">&gt;=</span> <span class="number">0</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="keyword">void</span> <span class="identifier">invariant</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span>
        <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">size</span><span class="special">()</span> <span class="special">&lt;=</span> <span class="identifier">MaxSize</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="keyword">explicit</span> <span class="identifier">array</span><span class="special">(</span><span class="keyword">unsigned</span> <span class="identifier">count</span><span class="special">);</span>
        <span class="keyword">static</span> <span class="keyword">void</span> <span class="identifier">constructor_precondition</span><span class="special">(</span><span class="keyword">unsigned</span> <span class="keyword">const</span> <span class="identifier">count</span><span class="special">)</span> <span class="special">{</span>
            <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">count</span> <span class="special">&lt;=</span> <span class="identifier">MaxSize</span><span class="special">);</span>
        <span class="special">}</span>
        <span class="keyword">static</span> <span class="keyword">void</span> <span class="identifier">constructor_old</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">old_ptr</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;&amp;</span>
                <span class="identifier">old_instances</span><span class="special">)</span> <span class="special">{</span>
            <span class="identifier">old_instances</span> <span class="special">=</span> <span class="identifier">BOOST_CONTRACT_OLDOF</span><span class="special">(</span><span class="identifier">instances</span><span class="special">());</span>
        <span class="special">}</span>
        <span class="keyword">void</span> <span class="identifier">constructor_postcondition</span><span class="special">(</span><span class="keyword">unsigned</span> <span class="keyword">const</span> <span class="identifier">count</span><span class="special">,</span>
                <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">old_ptr</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">old_instances</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span>
            <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">size</span><span class="special">()</span> <span class="special">==</span> <span class="identifier">count</span><span class="special">);</span>
            <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">instances</span><span class="special">()</span> <span class="special">==</span> <span class="special">*</span><span class="identifier">old_instances</span> <span class="special">+</span> <span class="number">1</span><span class="special">);</span>
        <span class="special">}</span>

    <span class="keyword">virtual</span> <span class="special">~</span><span class="identifier">array</span><span class="special">();</span>
        <span class="keyword">void</span> <span class="identifier">destructor_old</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">old_ptr</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;&amp;</span> <span class="identifier">old_instances</span><span class="special">)</span>
                <span class="keyword">const</span> <span class="special">{</span>
            <span class="identifier">old_instances</span> <span class="special">=</span> <span class="identifier">BOOST_CONTRACT_OLDOF</span><span class="special">(</span><span class="identifier">instances</span><span class="special">());</span>
        <span class="special">}</span>
        <span class="keyword">static</span> <span class="keyword">void</span> <span class="identifier">destructor_postcondition</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">old_ptr</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="keyword">const</span>
                <span class="identifier">old_instances</span><span class="special">)</span> <span class="special">{</span>
            <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">instances</span><span class="special">()</span> <span class="special">==</span> <span class="special">*</span><span class="identifier">old_instances</span> <span class="special">-</span> <span class="number">1</span><span class="special">);</span>
        <span class="special">}</span>

    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="identifier">push_back</span><span class="special">(</span><span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">value</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">virtual_</span><span class="special">*</span> <span class="identifier">v</span> <span class="special">=</span> <span class="number">0</span><span class="special">);</span>
        <span class="keyword">void</span> <span class="identifier">push_back_precondition</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span>
            <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">size</span><span class="special">()</span> <span class="special">&lt;</span> <span class="identifier">MaxSize</span><span class="special">);</span>
        <span class="special">}</span>
        <span class="keyword">void</span> <span class="identifier">push_back_old</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">virtual_</span><span class="special">*</span> <span class="identifier">v</span><span class="special">,</span>
                <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">old_ptr</span><span class="special">&lt;</span><span class="keyword">unsigned</span><span class="special">&gt;&amp;</span> <span class="identifier">old_size</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span>
            <span class="identifier">old_size</span> <span class="special">=</span> <span class="identifier">BOOST_CONTRACT_OLDOF</span><span class="special">(</span><span class="identifier">v</span><span class="special">,</span> <span class="identifier">size</span><span class="special">());</span>
        <span class="special">}</span>
        <span class="keyword">void</span> <span class="identifier">push_back_postcondition</span><span class="special">(</span>
                <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">old_ptr</span><span class="special">&lt;</span><span class="keyword">unsigned</span><span class="special">&gt;</span> <span class="keyword">const</span> <span class="identifier">old_size</span><span class="special">)</span> <span class="keyword">const</span> <span class="special">{</span>
            <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">size</span><span class="special">()</span> <span class="special">==</span> <span class="special">*</span><span class="identifier">old_size</span> <span class="special">+</span> <span class="number">1</span><span class="special">);</span>
        <span class="special">}</span>

    <span class="keyword">unsigned</span> <span class="identifier">size</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>

    <span class="keyword">static</span> <span class="keyword">int</span> <span class="identifier">instances</span><span class="special">();</span>

<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">T</span><span class="special">*</span> <span class="identifier">values_</span><span class="special">;</span>
    <span class="keyword">unsigned</span> <span class="identifier">size_</span><span class="special">;</span>
    <span class="keyword">static</span> <span class="keyword">int</span> <span class="identifier">instances_</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="identifier">MaxSize</span><span class="special">&gt;</span>
<span class="identifier">array</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">MaxSize</span><span class="special">&gt;::</span><span class="identifier">array</span><span class="special">(</span><span class="keyword">unsigned</span> <span class="identifier">count</span><span class="special">)</span> <span class="special">:</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">constructor_precondition</span><span class="special">&lt;</span><span class="identifier">array</span><span class="special">&gt;(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(</span>
            <span class="special">&amp;</span><span class="identifier">array</span><span class="special">::</span><span class="identifier">constructor_precondition</span><span class="special">,</span> <span class="identifier">count</span><span class="special">)),</span>
    <span class="identifier">values_</span><span class="special">(</span><span class="keyword">new</span> <span class="identifier">T</span><span class="special">[</span><span class="identifier">MaxSize</span><span class="special">])</span> <span class="comment">// Member initializations can be here.</span>
<span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">old_ptr</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">old_instances</span><span class="special">;</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">constructor</span><span class="special">(</span><span class="keyword">this</span><span class="special">)</span>
        <span class="special">.</span><span class="identifier">old</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(&amp;</span><span class="identifier">array</span><span class="special">::</span><span class="identifier">constructor_old</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">old_instances</span><span class="special">)))</span>
        <span class="special">.</span><span class="identifier">postcondition</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(&amp;</span><span class="identifier">array</span><span class="special">::</span><span class="identifier">constructor_postcondition</span><span class="special">,</span> <span class="keyword">this</span><span class="special">,</span>
                <span class="identifier">boost</span><span class="special">::</span><span class="identifier">cref</span><span class="special">(</span><span class="identifier">count</span><span class="special">),</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">cref</span><span class="special">(</span><span class="identifier">old_instances</span><span class="special">)))</span>
    <span class="special">;</span>

    <span class="keyword">for</span><span class="special">(</span><span class="keyword">unsigned</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="identifier">count</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span> <span class="identifier">values_</span><span class="special">[</span><span class="identifier">i</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">T</span><span class="special">();</span>
    <span class="identifier">size_</span> <span class="special">=</span> <span class="identifier">count</span><span class="special">;</span>
    <span class="special">++</span><span class="identifier">instances_</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="identifier">MaxSize</span><span class="special">&gt;</span>
<span class="identifier">array</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">MaxSize</span><span class="special">&gt;::~</span><span class="identifier">array</span><span class="special">()</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">old_ptr</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">old_instances</span><span class="special">;</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">destructor</span><span class="special">(</span><span class="keyword">this</span><span class="special">)</span>
        <span class="special">.</span><span class="identifier">old</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(&amp;</span><span class="identifier">array</span><span class="special">::</span><span class="identifier">destructor_old</span><span class="special">,</span> <span class="keyword">this</span><span class="special">,</span>
                <span class="identifier">boost</span><span class="special">::</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">old_instances</span><span class="special">)))</span>
        <span class="special">.</span><span class="identifier">postcondition</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(&amp;</span><span class="identifier">array</span><span class="special">::</span><span class="identifier">destructor_postcondition</span><span class="special">,</span>
                <span class="identifier">boost</span><span class="special">::</span><span class="identifier">cref</span><span class="special">(</span><span class="identifier">old_instances</span><span class="special">)))</span>
    <span class="special">;</span>

    <span class="keyword">delete</span><span class="special">[]</span> <span class="identifier">values_</span><span class="special">;</span>
    <span class="special">--</span><span class="identifier">instances_</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="identifier">MaxSize</span><span class="special">&gt;</span>
<span class="keyword">void</span> <span class="identifier">array</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">MaxSize</span><span class="special">&gt;::</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">value</span><span class="special">,</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">virtual_</span><span class="special">*</span> <span class="identifier">v</span><span class="special">)</span> <span class="special">{</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">old_ptr</span><span class="special">&lt;</span><span class="keyword">unsigned</span><span class="special">&gt;</span> <span class="identifier">old_size</span><span class="special">;</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">(</span><span class="identifier">v</span><span class="special">,</span> <span class="keyword">this</span><span class="special">)</span>
        <span class="special">.</span><span class="identifier">precondition</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(&amp;</span><span class="identifier">array</span><span class="special">::</span><span class="identifier">push_back_precondition</span><span class="special">,</span> <span class="keyword">this</span><span class="special">))</span>
        <span class="special">.</span><span class="identifier">old</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(&amp;</span><span class="identifier">array</span><span class="special">::</span><span class="identifier">push_back_old</span><span class="special">,</span> <span class="keyword">this</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">cref</span><span class="special">(</span><span class="identifier">v</span><span class="special">),</span>
                <span class="identifier">boost</span><span class="special">::</span><span class="identifier">ref</span><span class="special">(</span><span class="identifier">old_size</span><span class="special">)))</span>
        <span class="special">.</span><span class="identifier">postcondition</span><span class="special">(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(&amp;</span><span class="identifier">array</span><span class="special">::</span><span class="identifier">push_back_postcondition</span><span class="special">,</span> <span class="keyword">this</span><span class="special">,</span>
                <span class="identifier">boost</span><span class="special">::</span><span class="identifier">cref</span><span class="special">(</span><span class="identifier">old_size</span><span class="special">)))</span>
    <span class="special">;</span>

    <span class="identifier">values_</span><span class="special">[</span><span class="identifier">size_</span><span class="special">++]</span> <span class="special">=</span> <span class="identifier">value</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="identifier">MaxSize</span><span class="special">&gt;</span>
<span class="keyword">unsigned</span> <span class="identifier">array</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">MaxSize</span><span class="special">&gt;::</span><span class="identifier">size</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span>
    <span class="comment">// Check invariants.</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">(</span><span class="keyword">this</span><span class="special">);</span>
    <span class="keyword">return</span> <span class="identifier">size_</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="identifier">MaxSize</span><span class="special">&gt;</span>
<span class="keyword">int</span> <span class="identifier">array</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">MaxSize</span><span class="special">&gt;::</span><span class="identifier">instances</span><span class="special">()</span> <span class="special">{</span>
    <span class="comment">// Check static invariants.</span>
    <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">&lt;</span><span class="identifier">array</span><span class="special">&gt;();</span>
    <span class="keyword">return</span> <span class="identifier">instances_</span><span class="special">;</span>
<span class="special">}</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="identifier">MaxSize</span><span class="special">&gt;</span>
<span class="keyword">int</span> <span class="identifier">array</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">MaxSize</span><span class="special">&gt;::</span><span class="identifier">instances_</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
</pre>
<p>
      </p>
<p>
        If programmers also want to fully enforce all contract programming constant-correctness
        requirements at compile-time, they should follow these rules when programming
        the contract functions (see also <a class="link" href="contract_programming_overview.html#boost_contract.contract_programming_overview.constant_correctness" title="Constant-Correctness">Constant-Correctness</a>):
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            Precondition functions (i.e., the <code class="computeroutput"><span class="special">...</span><span class="identifier">_precondition</span></code> functions in the example
            above) can take their arguments either by <code class="computeroutput"><span class="keyword">const</span></code>
            value or by <code class="computeroutput"><span class="keyword">const</span><span class="special">&amp;</span></code>,
            and they should be either <code class="computeroutput"><span class="keyword">static</span></code>
            or <code class="computeroutput"><span class="keyword">const</span></code> member functions.
          </li>
<li class="listitem">
            Postcondition functions (i.e., the <code class="computeroutput"><span class="special">...</span><span class="identifier">_postcondition</span></code> functions in the example
            above) should take their arguments by <code class="computeroutput"><span class="keyword">const</span><span class="special">&amp;</span></code>, and they should be either <code class="computeroutput"><span class="keyword">static</span></code> or <code class="computeroutput"><span class="keyword">const</span></code>
            member functions.
          </li>
<li class="listitem">
            Old value functions (i.e., the <code class="computeroutput"><span class="special">...</span><span class="identifier">_old</span></code> functions in the example above)
            should take their arguments by <code class="computeroutput"><span class="keyword">const</span><span class="special">&amp;</span></code> a part from old value pointers that
            should be taken by <code class="computeroutput"><span class="special">&amp;</span></code>
            (so only old value pointers can be modified), and they should be either
            <code class="computeroutput"><span class="keyword">static</span></code> or <code class="computeroutput"><span class="keyword">const</span></code> member functions.
          </li>
<li class="listitem">
            Constructor precondition and old value functions should be <code class="computeroutput"><span class="keyword">static</span></code> (because constructor preconditions
            and old values cannot access the object <code class="computeroutput"><span class="keyword">this</span></code>,
            see also <a class="link" href="contract_programming_overview.html#boost_contract.contract_programming_overview.constructor_calls" title="Constructor Calls">Constructor
            Calls</a>).
          </li>
<li class="listitem">
            Destructor postcondition functions should be <code class="computeroutput"><span class="keyword">static</span></code>
            (because destructor postconditions cannot access the object <code class="computeroutput"><span class="keyword">this</span></code>, see also <a class="link" href="contract_programming_overview.html#boost_contract.contract_programming_overview.destructor_calls" title="Destructor Calls">Destructor
            Calls</a>).
          </li>
</ul></div>
<p>
        Note that the extra contract functions also allow to program only the contract
        code in the header file (see also <a class="link" href="contract_programming_overview.html#boost_contract.contract_programming_overview.specification_and_implementation" title="Specification and Implementation">Specification
        and Implementation</a>). All function body implementation code was instead
        programmed in the source file (including the constructor member initialization
        list, that could not be done with the technique shown in <a class="link" href="advanced_topics.html#boost_contract.advanced_topics.separate_body_implementation" title="Separate Body Implementation">Separate
        Body Implementation</a>). <a href="#ftn.boost_contract.advanced_topics.no_lambda_functions__no_c__11_.f1" class="footnote" name="boost_contract.advanced_topics.no_lambda_functions__no_c__11_.f1"><sup class="footnote">[50]</sup></a> Also note that the contract functions can always be declared
        <code class="computeroutput"><span class="keyword">private</span></code> if programmers need
        to exactly control the public members of the class (this was not done in
        this example only for brevity, see also __Access__).
      </p>
<p>
        Alternatively, on compilers that do not support C++11 lambda functions but
        that support type-of (either native as an extension or via emulation, these
        should be most recent C++03 compilers), <a href="http://www.boost.org/doc/libs/release/libs/local_function/doc/html/index.html" target="_top">Boost.LocalFunction</a>
        can be used to program the contract functions, for example (see also <a href="../../../example/features/no_lambdas_local_func.cpp" target="_top"><code class="literal">no_lambda_local_func.cpp</code></a>):
      </p>
<p>
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">local_function</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="identifier">MaxSize</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">array</span> <span class="special">:</span>
        <span class="keyword">private</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">constructor_precondition</span><span class="special">&lt;</span><span class="identifier">array</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">MaxSize</span><span class="special">&gt;</span> <span class="special">&gt;</span> <span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">static</span> <span class="keyword">void</span> <span class="identifier">static_invariant</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">instances</span><span class="special">()</span> <span class="special">&gt;=</span> <span class="number">0</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="keyword">void</span> <span class="identifier">invariant</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span>
        <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">size</span><span class="special">()</span> <span class="special">&lt;=</span> <span class="identifier">MaxSize</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="keyword">static</span> <span class="keyword">void</span> <span class="identifier">constructor_pre</span><span class="special">(</span><span class="keyword">unsigned</span> <span class="keyword">const</span> <span class="identifier">count</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">count</span> <span class="special">&lt;=</span> <span class="identifier">MaxSize</span><span class="special">);</span>
    <span class="special">}</span>
    <span class="keyword">explicit</span> <span class="identifier">array</span><span class="special">(</span><span class="keyword">unsigned</span> <span class="identifier">count</span><span class="special">)</span> <span class="special">:</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">constructor_precondition</span><span class="special">&lt;</span><span class="identifier">array</span><span class="special">&gt;(</span><span class="identifier">boost</span><span class="special">::</span><span class="identifier">bind</span><span class="special">(</span>
                <span class="special">&amp;</span><span class="identifier">array</span><span class="special">::</span><span class="identifier">constructor_pre</span><span class="special">,</span> <span class="identifier">count</span><span class="special">)),</span>
        <span class="identifier">values_</span><span class="special">(</span><span class="keyword">new</span> <span class="identifier">T</span><span class="special">[</span><span class="identifier">MaxSize</span><span class="special">])</span>
    <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">old_ptr</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">old_instances</span><span class="special">;</span>
        <span class="keyword">void</span> <span class="identifier">BOOST_LOCAL_FUNCTION_TPL</span><span class="special">(</span><span class="identifier">bind</span><span class="special">&amp;</span> <span class="identifier">old_instances</span><span class="special">)</span> <span class="special">{</span>
            <span class="identifier">old_instances</span> <span class="special">=</span> <span class="identifier">BOOST_CONTRACT_OLDOF</span><span class="special">(</span><span class="identifier">array</span><span class="special">::</span><span class="identifier">instances</span><span class="special">());</span>
        <span class="special">}</span> <span class="identifier">BOOST_LOCAL_FUNCTION_NAME_TPL</span><span class="special">(</span><span class="identifier">old</span><span class="special">)</span>
        <span class="keyword">void</span> <span class="identifier">BOOST_LOCAL_FUNCTION_TPL</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">bind</span> <span class="identifier">this_</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">bind</span><span class="special">&amp;</span> <span class="identifier">count</span><span class="special">,</span>
                <span class="keyword">const</span> <span class="identifier">bind</span><span class="special">&amp;</span> <span class="identifier">old_instances</span><span class="special">)</span> <span class="special">{</span>
            <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">this_</span><span class="special">-&gt;</span><span class="identifier">size</span><span class="special">()</span> <span class="special">==</span> <span class="identifier">count</span><span class="special">);</span>
            <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">this_</span><span class="special">-&gt;</span><span class="identifier">instances</span><span class="special">()</span> <span class="special">==</span> <span class="special">*</span><span class="identifier">old_instances</span> <span class="special">+</span> <span class="number">1</span><span class="special">);</span>
        <span class="special">}</span> <span class="identifier">BOOST_LOCAL_FUNCTION_NAME_TPL</span><span class="special">(</span><span class="identifier">post</span><span class="special">)</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">constructor</span><span class="special">(</span><span class="keyword">this</span><span class="special">)</span>
                <span class="special">.</span><span class="identifier">old</span><span class="special">(</span><span class="identifier">old</span><span class="special">).</span><span class="identifier">postcondition</span><span class="special">(</span><span class="identifier">post</span><span class="special">);</span>

        <span class="keyword">for</span><span class="special">(</span><span class="keyword">unsigned</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;</span> <span class="identifier">count</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span> <span class="identifier">values_</span><span class="special">[</span><span class="identifier">i</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">T</span><span class="special">();</span>
        <span class="identifier">size_</span> <span class="special">=</span> <span class="identifier">count</span><span class="special">;</span>
        <span class="special">++</span><span class="identifier">instances_</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="keyword">virtual</span> <span class="special">~</span><span class="identifier">array</span><span class="special">()</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">old_ptr</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span> <span class="identifier">old_instances</span><span class="special">;</span>
        <span class="keyword">void</span> <span class="identifier">BOOST_LOCAL_FUNCTION_TPL</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">bind</span> <span class="identifier">this_</span><span class="special">,</span> <span class="identifier">bind</span><span class="special">&amp;</span> <span class="identifier">old_instances</span><span class="special">)</span> <span class="special">{</span>
            <span class="identifier">old_instances</span> <span class="special">=</span> <span class="identifier">BOOST_CONTRACT_OLDOF</span><span class="special">(</span><span class="identifier">this_</span><span class="special">-&gt;</span><span class="identifier">instances</span><span class="special">());</span>
        <span class="special">}</span> <span class="identifier">BOOST_LOCAL_FUNCTION_NAME_TPL</span><span class="special">(</span><span class="identifier">old</span><span class="special">)</span>
        <span class="keyword">void</span> <span class="identifier">BOOST_LOCAL_FUNCTION_TPL</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">bind</span><span class="special">&amp;</span> <span class="identifier">old_instances</span><span class="special">)</span> <span class="special">{</span>
            <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">array</span><span class="special">::</span><span class="identifier">instances</span><span class="special">()</span> <span class="special">==</span> <span class="special">*</span><span class="identifier">old_instances</span> <span class="special">-</span> <span class="number">1</span><span class="special">);</span>
        <span class="special">}</span> <span class="identifier">BOOST_LOCAL_FUNCTION_NAME_TPL</span><span class="special">(</span><span class="identifier">post</span><span class="special">)</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">destructor</span><span class="special">(</span><span class="keyword">this</span><span class="special">)</span>
                <span class="special">.</span><span class="identifier">old</span><span class="special">(</span><span class="identifier">old</span><span class="special">).</span><span class="identifier">postcondition</span><span class="special">(</span><span class="identifier">post</span><span class="special">);</span>

        <span class="keyword">delete</span><span class="special">[]</span> <span class="identifier">values_</span><span class="special">;</span>
        <span class="special">--</span><span class="identifier">instances_</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="identifier">push_back</span><span class="special">(</span><span class="identifier">T</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">value</span><span class="special">,</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">virtual_</span><span class="special">*</span> <span class="identifier">v</span> <span class="special">=</span> <span class="number">0</span><span class="special">)</span> <span class="special">{</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">old_ptr</span><span class="special">&lt;</span><span class="keyword">unsigned</span><span class="special">&gt;</span> <span class="identifier">old_size</span><span class="special">;</span>
        <span class="keyword">void</span> <span class="identifier">BOOST_LOCAL_FUNCTION_TPL</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">bind</span> <span class="identifier">this_</span><span class="special">)</span> <span class="special">{</span>
            <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">this_</span><span class="special">-&gt;</span><span class="identifier">size</span><span class="special">()</span> <span class="special">&lt;</span> <span class="identifier">MaxSize</span><span class="special">);</span>
        <span class="special">}</span> <span class="identifier">BOOST_LOCAL_FUNCTION_NAME_TPL</span><span class="special">(</span><span class="identifier">pre</span><span class="special">)</span>
        <span class="keyword">void</span> <span class="identifier">BOOST_LOCAL_FUNCTION_TPL</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">bind</span> <span class="identifier">v</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">bind</span> <span class="identifier">this_</span><span class="special">,</span>
                <span class="identifier">bind</span><span class="special">&amp;</span> <span class="identifier">old_size</span><span class="special">)</span> <span class="special">{</span>
            <span class="identifier">old_size</span> <span class="special">=</span> <span class="identifier">BOOST_CONTRACT_OLDOF</span><span class="special">(</span><span class="identifier">v</span><span class="special">,</span> <span class="identifier">this_</span><span class="special">-&gt;</span><span class="identifier">size</span><span class="special">());</span>
        <span class="special">}</span> <span class="identifier">BOOST_LOCAL_FUNCTION_NAME_TPL</span><span class="special">(</span><span class="identifier">old</span><span class="special">)</span>
        <span class="keyword">void</span> <span class="identifier">BOOST_LOCAL_FUNCTION_TPL</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">bind</span> <span class="identifier">this_</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">bind</span><span class="special">&amp;</span> <span class="identifier">old_size</span><span class="special">)</span> <span class="special">{</span>
            <span class="identifier">BOOST_CONTRACT_ASSERT</span><span class="special">(</span><span class="identifier">this_</span><span class="special">-&gt;</span><span class="identifier">size</span><span class="special">()</span> <span class="special">==</span> <span class="special">*</span><span class="identifier">old_size</span> <span class="special">+</span> <span class="number">1</span><span class="special">);</span>
        <span class="special">}</span> <span class="identifier">BOOST_LOCAL_FUNCTION_NAME_TPL</span><span class="special">(</span><span class="identifier">post</span><span class="special">)</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">(</span><span class="identifier">v</span><span class="special">,</span> <span class="keyword">this</span><span class="special">)</span>
                <span class="special">.</span><span class="identifier">precondition</span><span class="special">(</span><span class="identifier">pre</span><span class="special">).</span><span class="identifier">old</span><span class="special">(</span><span class="identifier">old</span><span class="special">).</span><span class="identifier">postcondition</span><span class="special">(</span><span class="identifier">post</span><span class="special">);</span>

        <span class="identifier">values_</span><span class="special">[</span><span class="identifier">size_</span><span class="special">++]</span> <span class="special">=</span> <span class="identifier">value</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="keyword">unsigned</span> <span class="identifier">size</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span>
        <span class="comment">// Check invariants.</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">(</span><span class="keyword">this</span><span class="special">);</span>
        <span class="keyword">return</span> <span class="identifier">size_</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="keyword">static</span> <span class="keyword">int</span> <span class="identifier">instances</span><span class="special">()</span> <span class="special">{</span>
        <span class="comment">// Check static invariants.</span>
        <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">guard</span> <span class="identifier">c</span> <span class="special">=</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">contract</span><span class="special">::</span><span class="identifier">public_function</span><span class="special">&lt;</span><span class="identifier">array</span><span class="special">&gt;();</span>
        <span class="keyword">return</span> <span class="identifier">instances_</span><span class="special">;</span>
    <span class="special">}</span>

<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">T</span><span class="special">*</span> <span class="identifier">values_</span><span class="special">;</span>
    <span class="keyword">unsigned</span> <span class="identifier">size_</span><span class="special">;</span>
    <span class="keyword">static</span> <span class="keyword">int</span> <span class="identifier">instances_</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">template</span><span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">T</span><span class="special">,</span> <span class="keyword">unsigned</span> <span class="identifier">MaxSize</span><span class="special">&gt;</span>
<span class="keyword">int</span> <span class="identifier">array</span><span class="special">&lt;</span><span class="identifier">T</span><span class="special">,</span> <span class="identifier">MaxSize</span><span class="special">&gt;::</span><span class="identifier">instances_</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
</pre>
<p>
      </p>
<p>
        This code is somewhat less verbose than the previous example (about 30% less
        lines of code) but the contract code is hard to ready.
      </p>
<p>
        Other libraries could also be used to program the contract functions without
        C++11 lambda functions (Boost.Lambda, Boost.Fusion, etc.) but like the techniques
        shown above, they will all result in contract code more verbose, or harder
        to read and maintain than the contract code programmed using C++11 lambda
        functions. Therefore, authors think this library is most useful when used
        together with C++11 lambda functions.
      </p>
</div>
<div class="footnotes">
<br><hr style="width:100; text-align:left;margin-left: 0">
<div id="ftn.boost_contract.advanced_topics.old_values_at_body.f0" class="footnote"><p><a href="#boost_contract.advanced_topics.old_values_at_body.f0" class="para"><sup class="para">[33] </sup></a>
          <span class="bold"><strong>Rationale:</strong></span> Functors for preconditions,
          old value assignments, and postconditions are all optional but when specified,
          they must be specified in this order. Such order is enforced by the fact
          that <code class="computeroutput">boost::contract::specify_precondition_old_postconditions</code>,
          <code class="computeroutput"><a class="link" href="../boost/contract/specify_old_postcondition.html" title="Class template specify_old_postcondition">boost::contract::specify_old_postcondition</a></code>,
          <code class="computeroutput"><a class="link" href="../boost/contract/specify_postcondition_only.html" title="Class template specify_postcondition_only">boost::contract::specify_postcondition_only</a></code>,
          and <code class="computeroutput"><a class="link" href="../boost/contract/specify_nothing.html" title="Class specify_nothing">boost::contract::specify_nothing</a></code>
          provide a progressively decreasing subset of the <code class="computeroutput"><span class="special">.</span><span class="identifier">precondition</span><span class="special">(...)</span></code>,
          <code class="computeroutput"><span class="special">.</span><span class="identifier">old</span><span class="special">(...)</span></code> and <code class="computeroutput"><span class="special">.</span><span class="identifier">postcondition</span><span class="special">(...)</span></code>
          member functions. The enforced order of preconditions, old value assignments,
          and postconditions is logical because it reflects the order in which they
          are executed at run-time. Other contract programming frameworks allow to
          mix this order, that could have been implemented for this library too but
          it would have complicated a somewhat the library implementation while adding
          no real value (arguably creating confusion because allowing for less logical
          orderings).
        </p></div>
<div id="ftn.boost_contract.advanced_topics.old_values_at_body.f1" class="footnote"><p><a href="#boost_contract.advanced_topics.old_values_at_body.f1" class="para"><sup class="para">[34] </sup></a>
          <span class="bold"><strong>Rationale:</strong></span> If old value pointers are assigned
          at the point of their construction instead of using <code class="computeroutput"><span class="special">.</span><span class="identifier">old</span><span class="special">(...)</span></code>
          then an exception thrown by the old value expression <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OLDOF.html" title="Macro BOOST_CONTRACT_OLDOF">BOOST_CONTRACT_OLDOF</a></code>
          or more in general any exception thrown by the old value pointer initialization
          will result in that exception being thrown up the stack by the contracted
          function. This is arguably less correct than calling <code class="computeroutput">boost::contract::postcondition_failure</code>
          because an exception thrown by an old value copy causes the program to
          fail checking its postconditions and should not technically causes the
          contracted function to thrown an exception (however, this might not be
          a significant difference in practice). Note that while it would be possible
          to wrap all old value operations ([refclass boost::contract::old_ptr
        </p></div>
<div id="ftn.boost_contract.advanced_topics.optional_return_value.f0" class="footnote"><p><a href="#boost_contract.advanced_topics.optional_return_value.f0" class="para"><sup class="para">[35] </sup></a>
          <span class="bold"><strong>Rationale:</strong></span> <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">optional</span></code>
          was used instead of <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">optional</span></code>
          because this library is designed to work well with Boost and because <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">optional</span></code> is not part of the C++ standard
          yet.
        </p></div>
<div id="ftn.boost_contract.advanced_topics.optional_return_value.f1" class="footnote"><p><a href="#boost_contract.advanced_topics.optional_return_value.f1" class="para"><sup class="para">[36] </sup></a>
          <span class="bold"><strong>Rationale:</strong></span> This library requires the postcondition
          functor parameter to be of type <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">optional</span><span class="special">&lt;...</span> <span class="keyword">const</span><span class="special">&amp;&gt;</span></code> so the return value does not have
          to be copied (because of <code class="computeroutput"><span class="special">&amp;</span></code>)
          while postconditions are still prevented from changing it (because of
          <code class="computeroutput"><span class="keyword">const</span></code>, see also <a class="link" href="contract_programming_overview.html#boost_contract.contract_programming_overview.constant_correctness" title="Constant-Correctness">Constant-Correctness</a>).
          Note that the library cannot require the actual functor parameter <code class="computeroutput"><span class="identifier">result</span></code> to be <code class="computeroutput"><span class="keyword">const</span><span class="special">&amp;</span></code> instead (because programmers can always
          program the functor without specifying the <code class="computeroutput"><span class="keyword">const</span><span class="special">&amp;</span></code> outside the <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">optional</span><span class="special">&lt;...</span> <span class="keyword">const</span><span class="special">&amp;&gt;</span></code> type).
        </p></div>
<div id="ftn.boost_contract.advanced_topics.overloaded_functions.f0" class="footnote"><p><a href="#boost_contract.advanced_topics.overloaded_functions.f0" class="para"><sup class="para">[37] </sup></a>
          <span class="bold"><strong>Rationale:</strong></span> In oder to avoid copies, this
          library takes all contracted function arguments and the return value as
          references when passed to <code class="computeroutput"><a class="link" href="../boost/contract/public_function_id480248.html" title="Function template public_function">boost::contract::public_function</a></code>
          for overriding public functions. Therefore, the library cannot differentiate
          the actual argument and return types of the contracted functions when they
          are passed by reference and when they are not. As a result, the library
          cannot automatically reconstruct the contracted function pointer type which
          must be instead deduced from the function pointer explicitly passed by
          programmers to <code class="computeroutput"><a class="link" href="../boost/contract/public_function_id480248.html" title="Function template public_function">boost::contract::public_function</a></code>
          (in turn this requires using <code class="computeroutput"><span class="keyword">static_cast</span></code>
          to resolve ambiguities as usual in C++ when obtaining the pointer of overloaded
          functions).
        </p></div>
<div id="ftn.boost_contract.advanced_topics.named_overrides.f0" class="footnote"><p><a href="#boost_contract.advanced_topics.named_overrides.f0" class="para"><sup class="para">[38] </sup></a>
          <span class="bold"><strong>Rationale:</strong></span> A different macro <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_NAMED_OVERRIDE.html" title="Macro BOOST_CONTRACT_NAMED_OVERRIDE">BOOST_CONTRACT_NAMED_OVERRIDE</a></code>
          is used instead of overloading <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OVERRIDE.html" title="Macro BOOST_CONTRACT_OVERRIDE">BOOST_CONTRACT_OVERRIDE</a></code>
          using variadic macros because the override macros cannot be programmed
          manually by the users so making them variadic would prevent the use of
          this library on compilers that do not support variadic macros (see also
          <a class="link" href="advanced_topics.html#boost_contract.advanced_topics.no_macros__no_c__11_" title="No Macros (No C++11)">No
          Macros</a>).
        </p></div>
<div id="ftn.boost_contract.advanced_topics.move_operations.f0" class="footnote"><p><a href="#boost_contract.advanced_topics.move_operations.f0" class="para"><sup class="para">[39] </sup></a>
              If not anything else, this requires that class invariants are maintained
              by move operations because the destructor of the moved-from object
              requires that class invariants are true at its entry (as always with
              destructors, see also <a class="link" href="contract_programming_overview.html#boost_contract.contract_programming_overview.destructor_calls" title="Destructor Calls">Destructor
              Calls</a>).
            </p></div>
<div id="ftn.boost_contract.advanced_topics.volatile_class_invariants.f0" class="footnote"><p><a href="#boost_contract.advanced_topics.volatile_class_invariants.f0" class="para"><sup class="para">[40] </sup></a>
          <span class="bold"><strong>Rationale:</strong></span> Constructors and destructors
          check <code class="computeroutput"><span class="keyword">const</span> <span class="keyword">volatile</span></code>
          and <code class="computeroutput"><span class="keyword">const</span></code> invariants in that
          order because the qualifier that limits the calls the least is checked
          first (note that a <code class="computeroutput"><span class="keyword">const</span> <span class="keyword">volatile</span></code> calls can be made on any object
          while <code class="computeroutput"><span class="keyword">const</span></code> calls cannot be
          made on <code class="computeroutput"><span class="keyword">volatile</span></code> non-<code class="computeroutput"><span class="keyword">const</span></code> objects, in that sense the <code class="computeroutput"><span class="keyword">const</span> <span class="keyword">volatile</span></code>
          qualifier limits calls on an object less than <code class="computeroutput"><span class="keyword">const</span></code>
          alone does). This is consistent with <code class="computeroutput"><span class="keyword">static</span></code>
          class invariants that are checked even before <code class="computeroutput"><span class="keyword">const</span>
          <span class="keyword">volatile</span></code> invariants (the <code class="computeroutput"><span class="keyword">static</span></code> classifier limits calls even less
          than <code class="computeroutput"><span class="keyword">const</span> <span class="keyword">volatile</span></code>
          in the sense that an object is not even needed to make static calls). While
          there is a more important reason to check <code class="computeroutput"><span class="keyword">static</span></code>
          invariants before all other invariants (see <a class="link" href="contract_programming_overview.html" title="Contract Programming Overview">Contract
          Programming Overview</a>), the above is the only reason why this library
          checks <code class="computeroutput"><span class="keyword">const</span> <span class="keyword">volatile</span></code>
          invariants before <code class="computeroutput"><span class="keyword">const</span></code> invariants
          for constructors and destructors.
        </p></div>
<div id="ftn.boost_contract.advanced_topics.volatile_class_invariants.f1" class="footnote"><p><a href="#boost_contract.advanced_topics.volatile_class_invariants.f1" class="para"><sup class="para">[41] </sup></a>
          <span class="bold"><strong>Rationale:</strong></span> Note that while all public
          member functions can be made to check <code class="computeroutput"><span class="keyword">const</span>
          <span class="keyword">volatile</span></code> invariants, it is never
          possible to make volatile public member functions check <code class="computeroutput"><span class="keyword">const</span></code>
          non-volatile invariants. That is because both <code class="computeroutput"><span class="keyword">const</span></code>
          and <code class="computeroutput"><span class="keyword">volatile</span></code> can always be
          added but never stripped in C++ (a part from forcefully via <code class="computeroutput"><span class="keyword">const_cast</span></code>) but <code class="computeroutput"><span class="keyword">const</span></code>
          is always automatically added by this library in order to enforce contract
          constant-correctness (see <a class="link" href="contract_programming_overview.html#boost_contract.contract_programming_overview.constant_correctness" title="Constant-Correctness">Constant-Correctness</a>).
          That said, it would be incorrect for this library to also automatically
          add <code class="computeroutput"><span class="keyword">volatile</span></code> and require all
          functions to check <code class="computeroutput"><span class="keyword">const</span> <span class="keyword">volatile</span></code> (not just <code class="computeroutput"><span class="keyword">const</span></code>)
          invariants because only <code class="computeroutput"><span class="keyword">volatile</span></code>
          members can be accessed from <code class="computeroutput"><span class="keyword">const</span>
          <span class="keyword">volatile</span></code> invariants so there could
          be many <code class="computeroutput"><span class="keyword">const</span></code> (but not <code class="computeroutput"><span class="keyword">const</span> <span class="keyword">volatile</span></code>)
          members that are accessible from <code class="computeroutput"><span class="keyword">const</span></code>
          invariants but not from <code class="computeroutput"><span class="keyword">const</span> <span class="keyword">volatile</span></code> invariants. To avoid this confusion,
          this library has chosen to draw a clear dichotomy between <code class="computeroutput"><span class="keyword">const</span></code> and <code class="computeroutput"><span class="keyword">const</span>
          <span class="keyword">volatile</span></code> invariants so that only
          volatile members check <code class="computeroutput"><span class="keyword">const</span> <span class="keyword">volatile</span></code> invariants and only non-volatile
          members check <code class="computeroutput"><span class="keyword">const</span></code> (but not
          <code class="computeroutput"><span class="keyword">const</span> <span class="keyword">volatile</span></code>)
          invariants. This is simple and should serve most cases. If programmers
          need non-volatile members to check <code class="computeroutput"><span class="keyword">const</span>
          <span class="keyword">volatile</span></code> invariants, they can explicitly
          do so by calling the <code class="computeroutput"><span class="keyword">const</span> <span class="keyword">volatile</span></code> invariant function from the <code class="computeroutput"><span class="keyword">const</span></code> invariant function as shown in this
          documentation.
        </p></div>
<div id="ftn.boost_contract.advanced_topics.old_value_requirements.f0" class="footnote"><p><a href="#boost_contract.advanced_topics.old_value_requirements.f0" class="para"><sup class="para">[42] </sup></a>
              <span class="bold"><strong>Rationale:</strong></span> When C++11 <code class="computeroutput"><span class="keyword">auto</span></code> declarations are used, this library
              defaults the type of <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OLDOF.html" title="Macro BOOST_CONTRACT_OLDOF">BOOST_CONTRACT_OLDOF</a></code>
              to <code class="computeroutput"><a class="link" href="../boost/contract/old_ptr.html" title="Class template old_ptr">boost::contract::old_ptr</a></code>
              because it generates a compile-time error for non-copyable types so
              it is in general more conservative than <code class="computeroutput"><a class="link" href="../boost/contract/old_ptr_noncopyable.html" title="Class template old_ptr_noncopyable">boost::contract::old_ptr_noncopyable</a></code>.
            </p></div>
<div id="ftn.boost_contract.advanced_topics.assertion_requirements__static_if_.f0" class="footnote"><p><a href="#boost_contract.advanced_topics.assertion_requirements__static_if_.f0" class="para"><sup class="para">[43] </sup></a>
          <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">hana</span><span class="special">::</span><span class="identifier">if_</span></code> can also be used to emulate function
          scope <code class="computeroutput"><span class="keyword">static</span> <span class="keyword">if</span></code>
          with C++14 generic lambdas.
        </p></div>
<div id="ftn.boost_contract.advanced_topics.access_specifiers.f0" class="footnote"><p><a href="#boost_contract.advanced_topics.access_specifiers.f0" class="para"><sup class="para">[44] </sup></a>
              <span class="bold"><strong>Rationale:</strong></span> The internals of the <code class="computeroutput"><span class="identifier">override_</span><span class="special">...</span></code>
              type generated by <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OVERRIDE.html" title="Macro BOOST_CONTRACT_OVERRIDE">BOOST_CONTRACT_OVERRIDE</a></code>
              use names reserved by this library to users should not actually use
              such a type even when it is defined <code class="computeroutput"><span class="keyword">public</span></code>.
              (On a related note, in theory using C++14 generic lambdas, the <code class="computeroutput"><a class="link" href="../BOOST_CONTRACT_OVERRIDE.html" title="Macro BOOST_CONTRACT_OVERRIDE">BOOST_CONTRACT_OVERRIDE</a></code> macro
              could be re-implemented in a way so it can be expanded at function
              scoped, instead of class scoped.)
            </p></div>
<div id="ftn.boost_contract.advanced_topics.access_specifiers.f1" class="footnote"><p><a href="#boost_contract.advanced_topics.access_specifiers.f1" class="para"><sup class="para">[45] </sup></a>
          There is some variability among compiler implementations: the <code class="computeroutput"><span class="identifier">base_types</span></code> member type needs to be declared
          <code class="computeroutput"><span class="keyword">public</span></code> on all MSVC, GCC, ang
          CLang; the <code class="computeroutput"><span class="identifier">invariant</span></code> and
          <code class="computeroutput"><span class="identifier">static_invariant</span></code> member
          functions need to be declared <code class="computeroutput"><span class="keyword">public</span></code>
          on MSVC, but not on GCC and CLang; the <code class="computeroutput"><span class="identifier">override_</span><span class="special">...</span></code> member types do not have to be declared
          <code class="computeroutput"><span class="keyword">public</span></code> on any compiler. In
          any case, declaring the <code class="computeroutput"><a class="link" href="../boost/contract/access.html" title="Class access">boost::contract::access</a></code>
          class <code class="computeroutput"><span class="keyword">friend</span></code> allows to always
          declare all these extra members <code class="computeroutput"><span class="keyword">private</span></code>
          on all compilers.
        </p></div>
<div id="ftn.boost_contract.advanced_topics.throw_on_failure.f0" class="footnote"><p><a href="#boost_contract.advanced_topics.throw_on_failure.f0" class="para"><sup class="para">[46] </sup></a>
          <span class="bold"><strong>Rationale:</strong></span> In general, when a contract
          fails the only safe thing to do is to terminate the program execution (because
          the contract failure indicates a bug in the program, and in general the
          program is in a state for which no operation can be successfully performed,
          so the program should be stopped). Therefore, this library terminates the
          program by default. However, for specific applications, programmers could
          implement some fail-safe mechanism for which some mission-critical operation
          can always be performed upon handling failures so this library allows programmers
          to override the default contract failure handlers to fully customize how
          to handle contract failures.
        </p></div>
<div id="ftn.boost_contract.advanced_topics.throw_on_failure.f1" class="footnote"><p><a href="#boost_contract.advanced_topics.throw_on_failure.f1" class="para"><sup class="para">[47] </sup></a>
          It is the responsibility of the programmers to decide how to handle contract
          failures from destructors when they reprogram the contract failure handlers
          to throw exceptions instead of terminating the program (given that C++
          and STL exception safety rules requires destructors to never throw). This
          is not a simple dilemma and it might be one more reason to terminate the
          program instead of throwing exceptions when contract assertions fail (as
          this library does by default).
        </p></div>
<div id="ftn.boost_contract.advanced_topics.no_macros__no_c__11_.f0" class="footnote"><p><a href="#boost_contract.advanced_topics.no_macros__no_c__11_.f0" class="para"><sup class="para">[48] </sup></a>
          <span class="bold"><strong>Rationale:</strong></span> These macros expand SFINAE-based
          introspection templates that cannot be reasonably programmed by users (that
          remains the case even if C++14 generic lambdas were to be used here).
        </p></div>
<div id="ftn.boost_contract.advanced_topics.no_lambda_functions__no_c__11_.f0" class="footnote"><p><a href="#boost_contract.advanced_topics.no_lambda_functions__no_c__11_.f0" class="para"><sup class="para">[49] </sup></a>
              If C++ allowed lambda functions to capture variables by constant reference
              (e.g., <code class="computeroutput"><span class="special">[</span><span class="keyword">const</span><span class="special">&amp;]</span> <span class="special">(...)</span>
              <span class="special">{</span> <span class="special">...</span>
              <span class="special">}</span></code> or <code class="computeroutput"><span class="special">[</span><span class="keyword">const</span><span class="special">&amp;</span>
              </code><code class="literal"><span class="emphasis"><em>variable-name</em></span></code><code class="computeroutput"><span class="special">]</span> <span class="special">(...)</span> <span class="special">{</span> <span class="special">...</span> <span class="special">}</span></code>) also lambdas could be used to program
              contract functors that fully enforce <a class="link" href="contract_programming_overview.html#boost_contract.contract_programming_overview.constant_correctness" title="Constant-Correctness">Constant-Correctness</a>
              at compile-time. Note that C++11 lambda allows to capture variables
              by value (<code class="computeroutput"><span class="special">[=]</span> <span class="special">(...)</span>
              <span class="special">{</span> <span class="special">...</span>
              <span class="special">}</span></code> and <code class="computeroutput"><span class="special">[</span></code><code class="literal"><span class="emphasis"><em>variable-name</em></span></code><code class="computeroutput"><span class="special">]</span> <span class="special">(...)</span> <span class="special">{</span> <span class="special">...</span> <span class="special">}</span></code>), these value captures are <code class="computeroutput"><span class="keyword">const</span></code> (unless the lambda is explicitly
              declared <code class="computeroutput"><span class="keyword">mutable</span></code>) but
              they are not suitable to program postconditions using this library
              (see <a class="link" href="tutorial.html#boost_contract.tutorial.postconditions" title="Postconditions">Postconditions</a>),
              plus they introduce an extra copy that might be too expensive in general.
            </p></div>
<div id="ftn.boost_contract.advanced_topics.no_lambda_functions__no_c__11_.f1" class="footnote"><p><a href="#boost_contract.advanced_topics.no_lambda_functions__no_c__11_.f1" class="para"><sup class="para">[50] </sup></a>
          In this example, <code class="computeroutput"><span class="identifier">bind</span></code> was
          used to generate nullary functors from the contract functions. As always
          with <code class="computeroutput"><span class="identifier">bind</span></code>, <code class="computeroutput"><span class="identifier">cref</span></code> and <code class="computeroutput"><span class="identifier">ref</span></code>
          must be used to bind arguments by <code class="computeroutput"><span class="keyword">const</span><span class="special">&amp;</span></code> and <code class="computeroutput"><span class="special">&amp;</span></code>
          respectively, plus it might be necessary to explicitly <code class="computeroutput"><span class="keyword">static_cast</span></code>
          the function pointer passed to <code class="computeroutput"><span class="identifier">bind</span></code>
          in case the bound function name is overloaded.
        </p></div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2008-2016 Lorenzo
      Caminiti<p>
        Distributed under the Boost Software License, Version 1.0 (see accompanying
        file LICENSE_1_0.txt or a copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="tutorial.html"><img src="../../..//doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../..//doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../..//doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="../reference.html"><img src="../../..//doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>

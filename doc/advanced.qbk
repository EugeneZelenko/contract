
[/ Copyright (C) 2008-2017 Lorenzo Caminiti]
[/ Distributed under the Boost Software License, Version 1.0 (see accompanying]
[/ file LICENSE_1_0.txt or a copy at http://www.boost.org/LICENSE_1_0.txt).]
[/ See: http://www.boost.org/doc/libs/release/libs/contract/doc/html/index.html]

[section Advanced]

This section is a guide to advanced usages of this library.

[section Pure Virtual Public Functions]

In C++, pure virtual functions are allowed to have a /default implementation/ as long as such implementation is programmed out-of-line so defined outside the class declaring the pure virtual function `virtual ... = 0;`.

Contracts for pure virtual public functions are programmed using the [funcref boost::contract::public_function] function like for (non-pure) virtual public functions (all consideration made in __Virtual_Public_Functions__ apply).
However, contracts have to be programmed out-of-line, in the default implementation of the pure virtual function.
For example (see [@../../example/features/pure_virtual_public.cpp =pure_virtual_public.cpp=]):

[import ../example/features/pure_virtual_public.cpp]
[pure_virtual_public_base_begin]
[pure_virtual_public_base_end]
[pure_virtual_public_base_impl]

This library will never actually execute the pure virtual function body while it is calling the pure virtual function default implementation to check contracts for subcontracting.
Therefore, programmers can safely `assert(false)` at the beginning of the body if they intend for that body to never be executed (or they can program a working body in case they need to use C++ pure virtual function default implementation as usual with C++).

[heading Subcontracting Preconditions Always True/False]

As seen in __Public_Function_Overrides__, preconditions of overriding public functions are checked in __OR__ with preconditions of overridden virtual public functions.
Therefore, if a virtual public function in a base class specifies no precondition then preconditions specified by all its overriding functions in derived classes will have no effect (because when checked in __OR__ with the overridden function from the base class that has no preconditions, they will always pass).
This correctly reflects the fact that the overridden function in the base class can be called from any context (because it has no precondition) and so must all its overriding functions in all derived classes in accordance to the __substitution_principle__.
This is equivalent to declare the virtual public function in a base class with a single precondition `BOOST_CONTRACT_ASSERT(true)` that will always pass:

    // In a virtual public function of a base class.
    boost::contract::check c = boost::contract::public_function(v, this)
        .precondition([&] {
            BOOST_CONTRACT_ASSERT(true); // Prevent preconditions of overrides.
        })
        ...
    ;

On the flip side, programmers might sometimes consider to declare a pure virtual public function in a base class with a single precondition `BOOST_CONTRACT_ASSERT(false)` that will always fail.
This indicates that the pure virtual public function can never be called unless it is redefined by a derived class (which is actually the case with C++ pure virtual functions) and also that the base class designers have intentionally left it up to derived classes to specify preconditions for the pure virtual function in question.
This technique might make sense only for preconditions of pure virtual public functions (otherwise `BOOST_CONTRACT_ASSERT(false)` will prevent calling virtual public functions in concrete bases).
For example (see [@../../example/features/named_override.cpp =named_override.cpp=]):

[import ../example/features/named_override.cpp]
[named_override_pure_virtual_assert_false]

That said, the need to declare such a precondition `BOOST_CONTRACT_ASSERT(false)` that will always fail might be an indication that the base class interface is not correctly designed.
In general, the base class interface should still contain all functions (eventually as pure virtual) that are necessary to program its contracts.

[endsect]

[section Optional Return Value]

It is possible to use `boost::optional` to handle return values when programmers cannot construct the result variable at its point of declaration before the contract (e.g., because an appropriate constructor for the return type is not available at that point, or just because it would be too expensive to execute an extra initialization of the return value at run-time).
[footnote
*Rationale:*
`boost::optional` is used instead of `std::optional` because `std::optional` is not part of C++ standards prior to C++17.
]
For example (see [@../../example/features/optional_result.cpp =optional_result.cpp=]):

[import ../example/features/optional_result.cpp]
[optional_result]

In this example the return type is a reference so it does not have default constructor that can be used to initialize `result` when it is declared before the contract declaration.
In addition, `Index` needs to be validated to be smaller than `size()` by the precondition before it can be used to retrieve the reference to be assigned to `result` so `vect[Index]` cannot be used to initialize `result` when it is declared before the contract declaration.
Therefore, `boost::optional` is used to defer `result` proper initialization until the execution of the function body after the contract declaration when `Index` has been validated by the precondition and `vect[Index]` can be safely evaluated to initialize `result`.

As seen in __Return_Value__, it is the responsibility of the programmers to ensure that `result` is always set to the return value (when the function exits without trowing an exception).
This also ensures that `result` is always set before the postconditions are checked so programmers can always dereference `result` in postconditions to access the return value (using `operator*` and `operator->` as usual with `boost::optional`, and without having to explicitly check if `result` is an empty `boost::optional` object or not).
This can be easily done by making sure that /all/ return statements in the function are of the form:
    
    boost::optional<...> result;
    ...
    return *(result = ...); // Assign `result` at each return.

[heading Optional Results in Virtual Public Functions]

Similarly, `boost::optional` can be used to handle the return value passed to contracts of virtual public functions (pure or not) and of public function overrides.
As seen in __Pure_Virtual_Public_Functions__, __Virtual_Public_Functions__, and __Public_Function_Overrides__, in these cases the return value `result` must be passed as a parameter to [funcref boost::contract::public_function] right after the parameter `v` of type [classref boost::contract::virtual_]`*`.
Then the functor passed to `.postcondition(...)` takes one single parameter of type `boost::optional<`[^['result-type]]` const&> const&`.
For example (see [@../../example/features/optional_result_virtual.cpp =optional_result_virtual.cpp=]):

[import ../example/features/optional_result_virtual.cpp]
[optional_result_virtual]
    
The inner `const&` in the postcondition functor parameter type `boost::optional<... const&> ...` is mandatory (while the outer `const&` in the postcondition functor parameter type `boost::optional<...> const&` is not).
[footnote
*Rationale:*
This library requires the postcondition functor parameter to be of type `boost::optional<... const&>` so the return value does not have to be copied (because of `&`) while postconditions are still not allowed to change its value (because of `const`, see __Constant_Correctness__).
In addition, programmers are encouraged to declare the postcondition functor to take its argument also as a constant reference `boost::optional<... const&> const&` to avoid possibly expensive copies of the `boost::optional` type.
]

[endsect]

[section Private and Protected Functions]

Private and protected functions do not check class invariants (because they are not part of the public class interface) and they do not subcontract (because they are not accessible at the calling site where the __substitution_principle__ applies, see __Function_Calls__).
However, programmers may still want to specify preconditions and postconditions for private and protected functions when they want to check correctness of their implementation and usage from within the class, base classes, and friend classes or functions.
When programmers decide to specify contracts for private and protected functions, they shall use [funcref boost::contract::function] (like for non-member functions).
For example (see [@../../example/features/private_protected.cpp =private_protected.cpp=]):

[import ../example/features/private_protected.cpp]
[private_protected]

Considerations made in __Non_Member_Functions__ apply to private and protected functions as well.

See __Constructors__ and __Destructors__ on how to program contracts for private and protected constructors and destructors instead.

[heading Virtual Private and Protected Functions]

When private and protected functions are virtual they should still declare the extra virtual parameter of type [classref boost::contract::virtual_]`*` with default value `0` (see __Virtual_Public_Functions__) even if that parameter does not have to be passed to [macroref BOOST_CONTRACT_OLDOF] and [funcref boost::contract::function] takes no argument (so the extra virtual parameter will remain unused and it does not need a name).
[footnote
Technically, the extra virtual parameter can still be passed to [macroref BOOST_CONTRACT_OLDOF] but that is not necessary and it has no effect so it is not done in this documentation.
]
That is necessary otherwise the private and protected virtual functions cannot be overridden by public functions in derived classes that specify contracts (because the [classref boost::contract::virtual_]`* = 0` parameter has to be part of signatures for public function overrides).
For example (see [@../../example/features/private_protected_virtual.cpp =private_protected_virtual.cpp=]):

[import ../example/features/private_protected_virtual.cpp]
[private_protected_virtual_counter]

However, public functions in derived classes overriding private or protected virtual functions from base classes shall not specify the extra `override_...` template parameter to [funcref boost::contract::public_function] because the overridden functions are private or protected and, not being public, they do not participate to subcontracting (this library will generate a compile-time error if `override_...` is specified because there will be no virtual public function to override from the base class).
For example (see [@../../example/features/private_protected_virtual.cpp =private_protected_virtual.cpp=]):

[private_protected_virtual_counter10]

Furthermore, using multiple inheritance it is possible to override functions that are private or protected from one base but public from another base.
In this case, public function overrides in derived classes will specify the extra `override_...` template parameter to [funcref boost::contract::public_function] (because the overridden functions are private or protected in one base and those do not participate to subcontracting, but public in another base and these participate to subcontracting instead).
For example (see [@../../example/features/private_protected_virtual_multi.cpp =private_protected_virtual_multi.cpp=]):

[import ../example/features/private_protected_virtual_multi.cpp]
[private_protected_virtual_multi_countable]
[private_protected_virtual_multi_counter10]

[warning
Unfortunately, the code above does not compile on MSVC (at least up to Visual Studio 2015) because MSVC incorrectly gives a compile-time error when SFINAE fails due to private or protected access levels.
Instead, GCC and Clang correctly implement SFINAE failures due to private and protected functions so the code above correctly complies on GCC and Clang.
Therefore, currently it is not possible to override a function that is public in one base but private or protected in other base using this library on MSVC, but that can be done on GCC or CLang instead.
]

[endsect]

[section Friend Functions]

Friend functions are not member functions so [funcref boost::contract::function] can used to program contracts for them and all considerations made in __Non_Member_Functions__ apply.
For example (see [@../../example/features/friend.cpp =friend.cpp=]):

[import ../example/features/friend.cpp]
[friend_byte]
[friend_bytes]

However, in some cases a friend function might take an object as parameter and it can be logically considered an extension of that object's public interface (essentially at the same level as the object's public functions).
In these cases, programmers might chose to program the friend function contracts using [funcref boost::contract::public_function] (instead of [funcref boost::contract::function]) so to also check the class invariants of the object passed as parameter (and not just the pre- and postconditions of the friend function).
For example (see [@../../example/features/friend_invariant.cpp =friend_invariant.cpp=]):
[footnote
*Rationale:*
Contract programming proposals for C++ like __N1962__ do not provide a mechanism for friend functions to check class invariants of objects passed as parameters.
In other words, these proposals do not enable contracts to recognize that in C++ some friend functions logically act as if they were part of the public interface of the objects they take as parameters.
This is actually reasonable for proposals that add contracts to the core language because friend functions are not always meant to extend an object public interface and C++ does not provide a mechanism to programmatically specify when they do and when they do not.
However, this library adds the flexibility to let programmers manually specify when friend functions should also check class invariants of the objects they take as parameters (using [funcref boost::contract::public_function]) and when they should not (using [funcref boost::contract::function] instead).
]

[import ../example/features/friend_invariant.cpp]
[friend_invariant]

This technique can also be extended to friend functions that take multiple objects as parameters and can be logically considered extensions to the public interfaces of each of these objects.
For example:

    // Can be considered an extension of multiple objects' public interfaces.
    friend void f(class1& object1, class2* object2, type3& value3) {
        // Check preconditions.
        boost::contract::check pre = boost::contract::function()
            .precondition([&] {
                BOOST_CONTRACT_ASSERT(object2 != nullptr);
                ...
            })
        ;
        // Check class invariants for each object (programmers chose the order).
        boost::contract::check inv1 = boost::contract::public_function(&object1);
        boost::contract::check inv2 = boost::contract::public_function(object2);
        // Check postconditions and exception guarantees.
        boost::contract::check post_except = boost::contract::function()
            .postcondition(...)
            .except(...)
        ;

        ... // Function body.
    }

Changing the order of the [classref boost::contract::check] declarations above, programmers can chose the order for checking class invariants among the different objects passed to the friend function and also whether to check these invariants before or after preconditions, postconditions, and exception guarantees at function entry and exit respectively (see __Non_Member_Functions__ and __Public_Functions__ for information on how the RAII objects returned by [funcref boost::contract::function] and [funcref boost::contract::public_function] check contract conditions).
The example above is programmed to check `class1` invariants before `class2` invariants (but the order could have been inverted if programmers so chose).

[note
In the example above, preconditions are intentionally programmed to be checked before class invariants so the objects passed to the friend function can be validated by the preconditions before they are passed as pointers to [funcref boost::contract::public_function] (e.g., check `object2` is not null).
(Within member functions instead, the object pointer `this` is always well-formed, its validation is never needed, and [funcref boost::contract::public_function] checks class invariants before checking preconditions so programming preconditions can be simplified assuming the class invariants are satisfied already, see __Public_Function_Calls__.)
]

[endsect]

[section Function Overloads]

As seen in __Public_Function_Overrides__, [funcref boost::contract::public_function] takes a pointer to the enclosing function as a parameter when used in public function overrides.
When names of public function overrides are overloaded, the function pointer cannot be automatically deduced by the compiler so programmers have to use `static_cast` to resolve ambiguities (as usual with pointers to overloaded functions in C++).
[footnote
*Rationale:*
In order to avoid copies, this library takes all function arguments and the return value passed to [funcref boost::contract::public_function] as references when used within public function overrides.
Therefore, the library cannot differentiate when the actual function argument and return types are passed by reference and when they are not.
As a result, the library cannot automatically reconstruct the type of the enclosing public function so this type must be deduced from the function pointer passed by programmers to [funcref boost::contract::public_function].
When this automatic deduction is not possible due to overloaded function names, programmers must explicitly use `static_cast` to resolve ambiguities as usual in C++ with pointers to overloaded functions.
]
For example, note how `static_cast` is used in the following calls to [funcref boost::contract::public_function] (see [@../../example/features/overload.cpp =overload.cpp=]):

[import ../example/features/overload.cpp]
[overload]

Overloaded functions have the same function name so the same [^override_['function-name]] type can be reused as template parameter for all [funcref boost::contract::public_function] calls.
Therefore, [macroref BOOST_CONTRACT_OVERRIDE] only needs to be invoked once for any given function name even when that function name is overloaded.

[endsect]

[section Lambdas, Loops, Code Blocks (and `constexpr`)]

While contracts are usually most useful to program specifications of functions and class interfaces, this library also allows to check contract conditions for implementation code (lambda functions, loops, code blocks, etc.).

Lambda functions are not member functions, they are not part of class public interfaces so they do not check class invariants or participate int subcontracting.
They can use [funcref boost::contract::function] to specify preconditions, postconditions, and exception guarantees (considerations made in __Non_Member_Functions__ apply).
For example (see [@../../example/features/lambda.cpp =lambda.cpp=]):

[import ../example/features/lambda.cpp]
[lambda]

Similarly, [funcref boost::contract::function] can be used to program preconditions, postconditions, and exception guarantees for loops.
For example, for a for-loop but same for while- and all other loops (see [@../../example/features/loop.cpp =loop.cpp=]):

[import ../example/features/loop.cpp]
[loop]

More in general, [funcref boost::contract::function] can be used to program preconditions, postconditions, and exception guarantees of any block of code in a given function.
For example (see [@../../example/features/code_block.cpp =code_block.cpp=]):

[import ../example/features/code_block.cpp]
[code_block]

Finally, at the moment this library does not support contracts for functions and classes declared `constexpr`.
[footnote
*Rationale:*
In general, it might be useful to specify contracts for `constexpr` functions and literal classes.
However, the implementation of this library cannot support contracts for these functions and classes because C++ does not currently allow `constexpr` functions to do the following:
Declare local variables of (literal) types with non-trivial `constexpr` destructors (this RAII technique is used by this library to check invariants, postconditions, and exceptions guarantees at exit);
Call other `constexpr` functions using try-catch statements (used by this library to report contract assertion failures and catch any other exception that might be thrown when evaluating the asserted conditions);
Use lambda functions (used by this library for convenience to program functors that that check preconditions, postconditions, and exception guarantees).
Also note that even if supported, contracts for `constexpr` functions probably would not use old values (because `constexpr` prevents functions from having any side effect visible to the caller and variables recording such side-effects are usually the candidates for old value copies) and subcontracting (because `constexpr` functions cannot be virtual).
]

[endsect]

[section Implementation Checks]

This library provides a mechanism to check assertions within implementation code outside of preconditions, postconditions, exceptions guarantees, and class invariants.
These implementation checks can be programmed using [macroref BOOST_CONTRACT_ASSERT] in a nullary functor that is directly assigned to [classref boost::contract::check] at the place within the code where the checks have to be executed (so without using [funcref boost::contract::function], [funcref boost::contract::public_function], etc.).
For example (see [@ ../../example/features/check.cpp =check.cpp=]):

[import ../example/features/check.cpp]
[check_class]

Alternatively, this library provides the [macroref BOOST_CONTRACT_CHECK] macro that allows to completely remove run- and compile-time overhead of implementation checks when [macroref BOOST_CONTRACT_NO_CHECKS] is defined.
For example (see [@ ../../example/features/check.cpp =check.cpp=]):

[check_macro]

(See __Disable_Contract_Checking__ and __Disable_Contract_Compilation__ for macros to completely remove run- and compile-time overhead of preconditions, postconditions, exception guarantees, and class invariants.)

These implementation checks are essentially equivalent to using the C-style `assert` macro a part from the following:

* A failure of the implementation checks will call [funcref boost::contract::check_failure] (see [funcref boost::contract::set_check_failure] and [funcref boost::contract::get_check_failure]).
* Implementation checks are automatically disabled when other contract conditions specified using this libraries are already being checked (to avoid infinite recursion, see [macroref BOOST_CONTRACT_ALL_DISABLE_NO_ASSERTION]).
* Implementation checks are disabled defining [macroref BOOST_CONTRACT_NO_CHECKS] (instead of `NDEBUG` for disabling `assert`).

[endsect]

[section Old Copies at Body]

In the examples seen so far, old value variables of type [classref boost::contract::old_ptr] are initialized to a copy of the expression passed to [macroref BOOST_CONTRACT_OLDOF] at the point of their declaration.
This is correctly done before the function body is executed but it is also done before the contract is declared, therefore even before class invariants (for public functions) and preconditions are checked at function entry.

This might work well in most cases, however in general old values should be copied before executing the function body but after checking entry class invariants and preconditions (see __Assertions__).
Specifically, there could be cases in which it makes sense to evaluate the expressions passed to [macroref BOOST_CONTRACT_OLDOF] only assuming that the assertions programmed in the class invariants and preconditions are first checked to be true.

This library allows to construct [classref boost::contract::old_ptr] variables using their default constructor (equivalent to a null pointer) and then to assign them later to a copy of the expression passed to [macroref BOOST_CONTRACT_OLDOF] in a nullary functor [^['d]]`()` passed to `.old(`[^['d]]`)`.
The functor [^['d]]`()` is called by this library before the function body is executed but only after class invariants and preconditions are checked:
[footnote
*Rationale:*
Functors for preconditions, old value assignments, postconditions, and exception guarantees are all optional but when specified, they must be specified in that order.
Such order is enforced by the fact that [classref boost::contract::specify_precondition_old_postcondition_except], [classref boost::contract::specify_old_postcondition_except], [classref boost::contract::specify_postcondition_except], [classref boost::contract::specify_except], and [classref boost::contract::specify_nothing] provide a progressively decreasing subset of the `.precondition(...)`, `.old(...)`, `.postcondition(...)`, and `.except(...)` member functions.
The enforced order for specifying preconditions, old value assignments, postconditions, and exception guarantees makes logical sense because it follows the order at which these are executed at run-time.
Other contract programming frameworks allow to mix this order, that could have been implemented for this library as well but it would have complicated somewhat the library implementation while adding no real value (arguably creating confusion in user code by not enforcing a consistent order for specifying contract conditions).
]

    boost::contract::old_ptr<...> old_``[^['name]]``;                 // Default constructor (i.e., null pointer).
    ...
    boost::contract::guard c = boost::contract::function()  // Same for all other contracts.
        ...
        .old([&] {                                          // Capture by reference...
            old_``[^['name]]`` = BOOST_CONTRACT_OLDOF(``[^['expression]]``);    // ...but modify only old values.
            ...
        })
        .postcondition([&] {
            BOOST_CONTRACT_ASSERT(*old_``[^['name]]`` ...);           // Never null here.
            ...
        })
        .except([&] {
            BOOST_CONTRACT_ASSERT(*old_``[^['name]]`` ...);           // Never null here.
            ...
        })
    ;

For example, the following old value expression `s[index]` passed to [macroref BOOST_CONTRACT_OLDOF] is valid only after the precondition has checked that `index` is within valid range `index < s.size()`.
Therefore, `old_y` is first declared using its default constructor (i.e., initialized to a null pointer) and later assigned to a copy of `s[index]` in `.old(...)` after the precondition has checked `index` (see [@../../example/features/old.cpp =old.cpp=]):

[import ../example/features/old.cpp]
[old]

The functor passed to `.old(...)` should capture all variables it needs to evaluate to copy the old value expressions passed to [macroref BOOST_CONTRACT_OLDOF].
In general, these variables should be captured by reference and not by value (because old values need to make copies of the values the captured variables will have just before executing the function body, and not copy the values these variables had when the functor passed to `.old(...)` was first declared).
In any case, the functor passed to `.old(...)` should modify only old values and not the values of other captured variables (see __Constant_Correctness__).

This library will automatically call the failure handler [funcref boost::contract::old_failure] if calling the functor specified via `.old(...)` throws an exception (by default, this handler prints an error message to `std::cerr` and terminates the program calling `std::terminate`, but see __Throw_on_Failure__ to throw exceptions, exit the program with an error code, etc.).

[note
If old value pointers are initialized at the point of their construction instead of using `.old(...)` then an exception thrown by the old value expression passed to [macroref BOOST_CONTRACT_OLDOF], or more in general any exception thrown by the old value pointer initialization, will result in that exception being thrown up the stack by the enclosing function.
This is arguably less correct than calling [funcref boost::contract::old_failure] because an exception thrown by an old value copy causes the program to fail checking its postconditions and exception guarantees but should not automatically causes the enclosing function to thrown an exception (this might not be a significant difference in practice, but it could be an additional reason to use `.old(...)` instead of copying old values when they are declared before the contract).
[footnote
*Rationale:*
It would be possible to wrap all old value operations ([classref boost::contract::old_ptr] copy constructor, [funcref boost::contract::make_old], etc.) in try-catch statements so this library will call [funcref boost::contract::old_failure] also when old values are copied when they are constructed outside `.old(...)`.
However, that will prevent this library from knowing the [enumref boost::contract::from] parameter and that would be problematic (specifically because destructors can have postconditions so that parameter is necessary to make sure user-defined failure handlers can be programmed to never throw from destructors as C++ usually requires).
]
]

[endsect]

[section Named Overrides]

The function names passed to [macroref BOOST_CONTRACT_OVERRIDE] and [macroref BOOST_CONTRACT_OVERRIDES] should never start with an underscore to avoid generating names containing double underscores `override__...` (which are reserved by the C++ standard).
There is a separate macro [macroref BOOST_CONTRACT_NAMED_OVERRIDE] that can be used to explicitly specify the name of the type that will be passed to [funcref boost::contract::public_function] as a template argument:
[footnote
*Rationale:*
A different macro [macroref BOOST_CONTRACT_NAMED_OVERRIDE] is used instead of overloading [macroref BOOST_CONTRACT_OVERRIDE] using variadic macros because the override macros cannot be programmed manually by users so making it a variadic would prevent to use this library on compilers that do not support variadic macros (see __No_Macros__).
]

    BOOST_CONTRACT_OVERRIDE(``[^['function-name]]``)                  // Generate `override_...`.
    BOOST_CONTRACT_NAMED_OVERRIDE(``[^['type-name]]``, ``[^['function-name]]``) // Generate `type-name`.

For example, the following public function override is named `_1` so `BOOST_CONTRACT_OVERRIDE(_1)` would generate a type named `override__1` (which is reserved in C++ because it contains double underscores `__`), `BOOST_CONTRACT_NAMED_OVERRIDE(override1, _1)` is used to name the type `override1` instead (see [@../../example/features/named_override.cpp =named_override.cpp=]):

[named_override]

The [macroref BOOST_CONTRACT_NAMED_OVERRIDE] macro can also be used when the name `override_`[^['function-name]] generated by [macroref BOOST_CONTRACT_OVERRIDE] would clash with other names in user code, to generate names in CamelCase or in any other preferred style, and in any other case when programmers need or prefer to generate names different from `override_...`.

Note that there is not a `BOOST_CONTRACT_NAMED_OVERRIDES` macro so [macroref BOOST_CONTRACT_NAMED_OVERRIDE] needs to be invoked separately on each function name (there is instead a [macroref BOOST_CONTRACT_OVERRIDES] macro as seen in __Public_Function_Overrides__).
[footnote
*Rationale:*
The syntax for invoking a possible `BOOST_CONTRACT_NAMED_OVERRIDES` macro would need to be something like `BOOST_CONTRACT_NAMED_OVERRIDES(`[^['type-name1]]`, `[^['function-name1]]`, `[^['type-name2]]`, `[^['function-name2]]`, ...)`.
The authors felt this syntax is less readable than repeating single `BOOST_CONTRACT_NAMED_OVERRIDE` invocations `BOOST_CONTRACT_NAMED_OVERRIDE(`[^['type-name1]]`, `[^['function-name1]]`) BOOST_CONTRACT_NAMED_OVERRIDE(`[^['type-name2]]`, `[^['function-name2]]`) ...` so decided not to provide the `BOOST_CONTRACT_NAMED_OVERRIDES` macro.
]

[endsect]

[section Access Specifiers]

As we have seen so far, programmers are required to decorate their classes declaring extra members that are internally used by this library to check contracts:

* The `invariant` and `static_invariant` member functions (used to check class invariants, see __Class_Invariants__).
* The `base_types` member type declared via [macroref BOOST_CONTRACT_BASE_TYPES] (used to implement subcontracting, see __Public_Function_Overrides__).
* The `override_...` member types declared via [macroref BOOST_CONTRACT_OVERRIDE], [macroref BOOST_CONTRACT_NAMED_OVERRIDE], and [macroref BOOST_CONTRACT_OVERRIDES] (used to implement subcontracting for overriding functions, see __Public_Function_Overrides__).
[footnote
*Rationale:*
The internals of the `override_...` type generated by [macroref BOOST_CONTRACT_OVERRIDE] use names reserved by this library so programmers should not actually use such a type even when it is declared `public`.
]

In general, these members must be declared `public` in the user class in order for this library to be able to access them.
[footnote
There is some variability among compiler implementations:
The `base_types` member type needs to be declared `public` on MSVC, GCC, ang CLang;
The `invariant` and `static_invariant` member functions need to be declared `public` on MSVC, but not on GCC and CLang;
The `override_...` member types do not have to be declared `public` on any compiler.
In any case, declaring the [classref boost::contract::access] class `friend` allows to always declare all these extra members `private` on all compilers.
]
However, programmers might need to more precisely control the public members of their classes to prevent incorrect access of encapsulated members.
All these members can be declared `private` as long as the [classref boost::contract::access] class is declared as `friend` of the user class.
For example (see [@../../example/features/access.cpp =access.cpp=]):

[import ../example/features/access.cpp]
[access]

This technique is not used in most examples of this documentation only for brevity, but programmers are encouraged to use it in real code.

[warning
Not declaring this class friend of user classes might cause compiler errors on some compilers (e.g., MSVC) because the private members needed to check the contracts will not be accessible.
On other compilers (e.g., GCC and CLang), the private access will instead fail SFINAE and no compiler error will be reported while invariants and subcontracting will be silently skipped at run-time.
Therefore, programmers should always make sure to either declare invariant functions and base types `typedef` as public members or to declare the [classref boost::contract::access] class as friend.
]

[endsect]

[section Throw on Failure (and `noexcept`)]

If a conditions checked using [macroref BOOST_CONTRACT_ASSERT] is evaluated to be `false` or more in general if any of the specified contract code throws an exception ([macroref BOOST_CONTRACT_ASSERT] simply expands to code that throws a [classref boost::contract::assertion_failure] exception, see __No_Macros__), this library will call an appropriate /contract failure handler/ function as follow:

* Preconditions: False [macroref BOOST_CONTRACT_ASSERT] assertions and exceptions thrown from within `.precondition(...)` call [funcref boost::contract::precondition_failure].
* Postconditions: False [macroref BOOST_CONTRACT_ASSERT] assertions and exceptions thrown from within `.postcondition(...)` call [funcref boost::contract::postcondition_failure].
* Exceptions guarantees: False [macroref BOOST_CONTRACT_ASSERT] assertions and exceptions thrown from within `.except(...)` call [funcref boost::contract::except_failure].
* Class invariants: False [macroref BOOST_CONTRACT_ASSERT] assertions and exceptions thrown from `invariant()` and `static_invariant()` call [funcref boost::contract::entry_invariant_failure] when checked at function entry and [funcref boost::contract::exit_invariant_failure] when checked at function exit.
* Old copies at body: Exceptions thrown from old value copies at body within `.old(...)` call [funcref boost::contract::old_failure].
* Implementation checks: False [macroref BOOST_CONTRACT_ASSERT] assertions and exceptions thrown from implementation checks `boost::contract::check c = `[^['nullary-functor]] and [macroref BOOST_CONTRACT_CHECK] calls [funcref boost::contract::check_failure].

By default, these contract failure handlers print a message to the standard error `std::cerr` and then terminate the program calling `std::terminate`.
[footnote
*Rationale:*
In general, when a contract fails the only safe thing to do is to terminate program execution (because the contract failure indicates a bug in the program, and in general the program is in a state for which no operation can be successfully performed, so the program should be stopped).
Therefore, this library terminates the program by default.
However, for specific applications, programmers could implement some fail-safe mechanism for which some mission-critical operation could always be performed upon handling failures so this library allows programmers to override the default contract failure handlers to fully customize how to handle contract failures.
]
However, programmers can override the default contract failure handlers to perform any custom action on contract failure using the following functions respectively:

* Preconditions: [funcref boost::contract::set_precondition_failure].
* Postconditions: [funcref boost::contract::set_postcondition_failure].
* Exception guarantees: [funcref boost::contract::set_except_failure].
* Class invariants: [funcref boost::contract::set_entry_invariant_failure] and [funcref boost::contract::set_exit_invariant_failure], or [funcref boost::contract::set_invariant_failure] (to set both entry and exit invariant failure handlers at once for convenience).
* Old copies at body: [funcref boost::contract::set_old_failure].
* Implementation checks: [funcref boost::contract::set_check_failure].

These `set_..._failure(`[^['f]]`)` function calls return the contract failure handler functor [^['f]] that they take as input parameter.
For example (see [@../../example/features/throw_on_failure.cpp =throw_on_failure.cpp=]):
[footnote
*Rationale:*
Even if somewhat different from `std::set_terminate`, the `set_..._failure` functions take a functor as parameter (so to handle not just function pointers, but also lambdas, binds, etc.) and return this same functor as result (so they can be concatenated).
The related `get_..._failure` functions can be used to query the functors currently set as failure handlers.
]

[import ../example/features/throw_on_failure.cpp]
[throw_on_failure_handlers]

When programming custom failure handlers that trow exceptions instead of terminating the program, programmers should be wary of the following:

* In order to comply with C++ and STL exception safety, destructors should never throw.
This library passes a [enumref boost::contract::from] parameter to the contract failure handlers for preconditions ([funcref boost::contract::precondition_failure]), postconditions ([funcref boost::contract::postcondition_failure]), class invariants ([funcref boost::contract::entry_invariant_failure] and [funcref boost::contract::exit_invariant_failure]), and old value copies at body ([funcref boost::contract::old_failure]).
This [enumref boost::contract::from] parameter indicates if the contract failure occurred in a destructor, constructor, or function call so programmers can use it to code custom contract failure hander functions that never throw from destructors.
(In the example above, contract failures from destructors are simply ignored even if that is probably never a safe thing to do in real code.)
* C++ stack-unwinding will execute base class destructors even when the derived class destructor trows an exception.
Therefore, the contracts of base class destructors will continue to be checked when contract failure handlers are programmed to throw exceptions on contract failures from destructors (yet another reason to not throw exception from destructors, not even for contract failures).
* Implementation checks can appear in any code, including destructor implementation code, so [funcref boost::contract::check_failure] should also never throw, or implementation checks should never be used in destructors (note that [funcref boost::contract::check_failure] does not provide the [enumref boost::contract::from] parameter so it is not possible to differentiate from implementation checks failing from destructors instead than from other parts of the code).
* The contract failure handler for exception guarantees [funcref boost::contract::except_failure] should also never throw (regardless of the value of its [enumref boost::contract::from] parameter) because when [funcref boost::contract::except_failure] is called there is already an active exception on the stack, the exception that triggered the exception guarantees to be checked in the first place (and throwing an exception while there is already an active exception will force C++ to terminate the program or lead to undefined behaviour).

[note
It is the responsibility of the programmers to decide how to handle contract failures from destructors when they program custom contract failure handlers that throw exceptions instead of terminating the program (given that C++ and STL exception safety rules requires destructors to never throw).
This is not a simple dilemma and it might be a good reason to terminate the program instead of throwing exceptions when assertions fail in C++ (as this library and also C-style `assert` do by default).
]

Contract assertions can be programmed to throw [classref boost::contract::assertion_failure] using [macroref BOOST_CONTRACT_ASSERT]`(`[^['condition]]`)` as we have seen so far (see __No_Macros__).
Alternatively, contract assertions can be programmed to throw any other exception (including user-defined exceptions) using code similar to the following:

    if(!``[^['condition]]``) throw ``[^['exception-object]]``;

For example, if the following precondition functor throws the user-defined exception `too_large_error` then the contract failure handler [funcref boost::contract::precondition_failure] will be called (same as when preconditions programmed using [macroref BOOST_CONTRACT_ASSERT] fail, see [@../../example/features/throw_on_failure.cpp =throw_on_failure.cpp=]):

[throw_on_failure_class_begin]
[throw_on_failure_ctor]
[throw_on_failure_class_end]

Finally, note that the exception specifiers `noexcept` (since C++11) and `throw` (deprecated in C++11) of the enclosing operation declaring the contract correctly apply to the contract code as well.
Therefore, even if the contract failure handlers are reprogrammed to throw exceptions in case of contract failures, those exceptions will never be thrown outside the context of the enclosing operation if that is not in accordance with the exception specifiers of that operation (e.g., note that all destructors are implicitly declared `noexcept` in C++11).
For example, the following code will correctly never throw from the `noexcept` destructor, not even if the class invariants checked at destructor entry throw `too_large_error` and the contract failure handlers for invariants are programmed to throw from destructors (the program will always terminate in this case instead, see [@../../example/features/throw_on_failure.cpp =throw_on_failure.cpp=]):

[throw_on_failure_class_begin]
[throw_on_failure_dtor]
[throw_on_failure_class_end]
[throw_on_failure_bad_handler]

[endsect]

[endsect]

